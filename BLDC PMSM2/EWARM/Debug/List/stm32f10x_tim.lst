###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.1.53790/W32 for ARM     24/Feb/2014  19:26:50 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\stm32\STM32F10XFWLIB\src\stm32f10x_tim.c              #
#    Command line =  D:\stm32\STM32F10XFWLIB\src\stm32f10x_tim.c -D           #
#                    VECT_TAB_FLASH -lCN "D:\stm32\BLDC                       #
#                    PMSM2\EWARM\Debug\List\" --diag_error Pe068,Pe069 -o     #
#                    "D:\stm32\BLDC PMSM2\EWARM\Debug\Obj\" --debug           #
#                    --endian=little --cpu=Cortex-M3 --fpu=None               #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 6.4\arm\INC\c\DLib_Config_Normal.h" -I         #
#                    "D:\stm32\BLDC PMSM2\EWARM\..\" -I "D:\stm32\BLDC        #
#                    PMSM2\EWARM\..\..\STM32F10XFWLIB\inc\" -I                #
#                    "D:\stm32\BLDC PMSM2\EWARM\..\inc\" -Oh                  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  D:\stm32\BLDC PMSM2\EWARM\Debug\List\stm32f10x_tim.lst   #
#    Object file  =  D:\stm32\BLDC PMSM2\EWARM\Debug\Obj\stm32f10x_tim.o      #
#                                                                             #
#                                                                             #
###############################################################################

D:\stm32\STM32F10XFWLIB\src\stm32f10x_tim.c
      1          /******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
      2          * File Name          : stm32f10x_tim.c
      3          * Author             : MCD Application Team
      4          * Version            : V2.0
      5          * Date               : 05/23/2008
      6          * Description        : This file provides all the TIM firmware functions.
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          * FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
     15          * IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
     16          *******************************************************************************/
     17          
     18          /* Includes ------------------------------------------------------------------*/
     19          #include "stm32f10x_tim.h"
     20          #include "stm32f10x_rcc.h"
     21          
     22          /* Private typedef -----------------------------------------------------------*/
     23          /* Private define ------------------------------------------------------------*/
     24          /* ---------------------- TIM registers bit mask ------------------------ */
     25          #define CR1_CEN_Set                 ((u16)0x0001)
     26          #define CR1_CEN_Reset               ((u16)0x03FE)
     27          #define CR1_UDIS_Set                ((u16)0x0002)
     28          #define CR1_UDIS_Reset              ((u16)0x03FD)
     29          #define CR1_URS_Set                 ((u16)0x0004)
     30          #define CR1_URS_Reset               ((u16)0x03FB)
     31          #define CR1_OPM_Reset               ((u16)0x03F7)
     32          #define CR1_CounterMode_Mask        ((u16)0x038F)
     33          #define CR1_ARPE_Set                ((u16)0x0080)
     34          #define CR1_ARPE_Reset              ((u16)0x037F)
     35          #define CR1_CKD_Mask                ((u16)0x00FF)
     36          
     37          #define CR2_CCPC_Set                ((u16)0x0001)
     38          #define CR2_CCPC_Reset              ((u16)0xFFFE)
     39          #define CR2_CCUS_Set                ((u16)0x0004)
     40          #define CR2_CCUS_Reset              ((u16)0xFFFB)
     41          #define CR2_CCDS_Set                ((u16)0x0008)
     42          #define CR2_CCDS_Reset              ((u16)0xFFF7)
     43          #define CR2_MMS_Mask                ((u16)0xFF8F)
     44          #define CR2_TI1S_Set                ((u16)0x0080)
     45          #define CR2_TI1S_Reset              ((u16)0xFF7F)
     46          #define CR2_OIS1_Reset              ((u16)0x7EFF)
     47          #define CR2_OIS1N_Reset             ((u16)0x7DFF)
     48          #define CR2_OIS2_Reset              ((u16)0x7BFF)
     49          #define CR2_OIS2N_Reset             ((u16)0x77FF)
     50          #define CR2_OIS3_Reset              ((u16)0x6FFF)
     51          #define CR2_OIS3N_Reset             ((u16)0x5FFF)
     52          #define CR2_OIS4_Reset              ((u16)0x3FFF)
     53          
     54          #define SMCR_SMS_Mask               ((u16)0xFFF8)
     55          #define SMCR_ETR_Mask               ((u16)0x00FF)
     56          #define SMCR_TS_Mask                ((u16)0xFF8F)
     57          #define SMCR_MSM_Reset              ((u16)0xFF7F)
     58          #define SMCR_ECE_Set                ((u16)0x4000)
     59          
     60          #define CCMR_CC13S_Mask             ((u16)0xFFFC)
     61          #define CCMR_CC24S_Mask             ((u16)0xFCFF)
     62          #define CCMR_TI13Direct_Set         ((u16)0x0001)
     63          #define CCMR_TI24Direct_Set         ((u16)0x0100)
     64          #define CCMR_OC13FE_Reset           ((u16)0xFFFB)
     65          #define CCMR_OC24FE_Reset           ((u16)0xFBFF)
     66          #define CCMR_OC13PE_Reset           ((u16)0xFFF7)
     67          #define CCMR_OC24PE_Reset           ((u16)0xF7FF)
     68          #define CCMR_OC13M_Mask             ((u16)0xFF8F)
     69          #define CCMR_OC24M_Mask             ((u16)0x8FFF) 
     70          
     71          #define CCMR_OC13CE_Reset           ((u16)0xFF7F)
     72          #define CCMR_OC24CE_Reset           ((u16)0x7FFF)
     73          
     74          #define CCMR_IC13PSC_Mask           ((u16)0xFFF3)
     75          #define CCMR_IC24PSC_Mask           ((u16)0xF3FF)
     76          #define CCMR_IC13F_Mask             ((u16)0xFF0F)
     77          #define CCMR_IC24F_Mask             ((u16)0x0FFF)
     78          
     79          #define CCMR_Offset                 ((u16)0x0018)
     80          #define CCER_CCE_Set                ((u16)0x0001)
     81          #define	CCER_CCNE_Set               ((u16)0x0004)
     82          
     83          #define CCER_CC1P_Reset             ((u16)0xFFFD)
     84          #define CCER_CC2P_Reset             ((u16)0xFFDF)
     85          #define CCER_CC3P_Reset             ((u16)0xFDFF)
     86          #define CCER_CC4P_Reset             ((u16)0xDFFF)
     87          
     88          #define CCER_CC1NP_Reset            ((u16)0xFFF7)
     89          #define CCER_CC2NP_Reset            ((u16)0xFF7F)
     90          #define CCER_CC3NP_Reset            ((u16)0xF7FF)
     91          
     92          #define CCER_CC1E_Set               ((u16)0x0001)
     93          #define CCER_CC1E_Reset             ((u16)0xFFFE)
     94          
     95          #define CCER_CC1NE_Reset            ((u16)0xFFFB)
     96          
     97          #define CCER_CC2E_Set               ((u16)0x0010)
     98          #define CCER_CC2E_Reset             ((u16)0xFFEF)
     99          
    100          #define CCER_CC2NE_Reset            ((u16)0xFFBF)
    101          
    102          #define CCER_CC3E_Set               ((u16)0x0100)
    103          #define CCER_CC3E_Reset             ((u16)0xFEFF)
    104          
    105          #define CCER_CC3NE_Reset            ((u16)0xFBFF)
    106          
    107          #define CCER_CC4E_Set               ((u16)0x1000)
    108          #define CCER_CC4E_Reset             ((u16)0xEFFF)
    109          
    110          #define BDTR_MOE_Set                ((u16)0x8000)
    111          #define BDTR_MOE_Reset              ((u16)0x7FFF)
    112          
    113          /* Private macro -------------------------------------------------------------*/
    114          /* Private variables ---------------------------------------------------------*/
    115          /* Private function prototypes -----------------------------------------------*/
    116          static void TI1_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
    117                                 u16 TIM_ICFilter);
    118          static void TI2_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
    119                                 u16 TIM_ICFilter);
    120          static void TI3_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
    121                                 u16 TIM_ICFilter);
    122          static void TI4_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
    123                                 u16 TIM_ICFilter);
    124          /* Private macro -------------------------------------------------------------*/
    125          /* Private variables ---------------------------------------------------------*/
    126          /* Private function prototypes -----------------------------------------------*/
    127          /* Private functions ---------------------------------------------------------*/
    128          /*******************************************************************************
    129          * Function Name  : TIM_DeInit
    130          * Description    : Deinitializes the TIMx peripheral registers to their default
    131          *                  reset values.
    132          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
    133          * Output         : None
    134          * Return         : None
    135          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    136          void TIM_DeInit(TIM_TypeDef* TIMx)
    137          {
   \                     TIM_DeInit:
   \   00000000   0xB580             PUSH     {R7,LR}
    138            /* Check the parameters */
    139            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
    140           
    141            switch (*(u32*)&TIMx)
   \   00000002   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \   00000006   0xD01E             BEQ.N    ??TIM_DeInit_0
   \   00000008   0x....             LDR.N    R1,??DataTable4  ;; 0x40000400
   \   0000000A   0x4288             CMP      R0,R1
   \   0000000C   0xD022             BEQ.N    ??TIM_DeInit_1
   \   0000000E   0x....             LDR.N    R1,??DataTable4_1  ;; 0x40000800
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xD026             BEQ.N    ??TIM_DeInit_2
   \   00000014   0x....             LDR.N    R1,??DataTable4_2  ;; 0x40000c00
   \   00000016   0x4288             CMP      R0,R1
   \   00000018   0xD02A             BEQ.N    ??TIM_DeInit_3
   \   0000001A   0x....             LDR.N    R1,??DataTable4_3  ;; 0x40001000
   \   0000001C   0x4288             CMP      R0,R1
   \   0000001E   0xD02E             BEQ.N    ??TIM_DeInit_4
   \   00000020   0x....             LDR.N    R1,??DataTable4_4  ;; 0x40001400
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xD032             BEQ.N    ??TIM_DeInit_5
   \   00000026   0x....             LDR.N    R1,??DataTable4_5  ;; 0x40012c00
   \   00000028   0x4288             CMP      R0,R1
   \   0000002A   0xD003             BEQ.N    ??TIM_DeInit_6
   \   0000002C   0x....             LDR.N    R1,??DataTable4_6  ;; 0x40013400
   \   0000002E   0x4288             CMP      R0,R1
   \   00000030   0xD036             BEQ.N    ??TIM_DeInit_7
   \   00000032   0xBD01             POP      {R0,PC}
    142            {
    143              case TIM1_BASE:
    144                RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
   \                     ??TIM_DeInit_6:
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0xF44F 0x6000      MOV      R0,#+2048
   \   0000003A   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    145                RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0xF44F 0x6000      MOV      R0,#+2048
   \   00000044   0xE034             B.N      ??TIM_DeInit_8
    146                break; 
    147                
    148              case TIM2_BASE:
    149                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
   \                     ??TIM_DeInit_0:
   \   00000046   0x2101             MOVS     R1,#+1
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    150                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
   \   0000004E   0x2100             MOVS     R1,#+0
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0xE021             B.N      ??TIM_DeInit_9
    151                break;
    152           
    153              case TIM3_BASE:
    154                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
   \                     ??TIM_DeInit_1:
   \   00000054   0x2101             MOVS     R1,#+1
   \   00000056   0x2002             MOVS     R0,#+2
   \   00000058   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    155                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
   \   0000005C   0x2100             MOVS     R1,#+0
   \   0000005E   0x2002             MOVS     R0,#+2
   \   00000060   0xE01A             B.N      ??TIM_DeInit_9
    156                break;
    157           
    158              case TIM4_BASE:
    159                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
   \                     ??TIM_DeInit_2:
   \   00000062   0x2101             MOVS     R1,#+1
   \   00000064   0x2004             MOVS     R0,#+4
   \   00000066   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    160                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0x2004             MOVS     R0,#+4
   \   0000006E   0xE013             B.N      ??TIM_DeInit_9
    161                break;
    162                
    163              case TIM5_BASE:
    164                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
   \                     ??TIM_DeInit_3:
   \   00000070   0x2101             MOVS     R1,#+1
   \   00000072   0x2008             MOVS     R0,#+8
   \   00000074   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    165                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
   \   00000078   0x2100             MOVS     R1,#+0
   \   0000007A   0x2008             MOVS     R0,#+8
   \   0000007C   0xE00C             B.N      ??TIM_DeInit_9
    166                break;
    167                
    168              case TIM6_BASE:
    169                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
   \                     ??TIM_DeInit_4:
   \   0000007E   0x2101             MOVS     R1,#+1
   \   00000080   0x2010             MOVS     R0,#+16
   \   00000082   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    170                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
   \   00000086   0x2100             MOVS     R1,#+0
   \   00000088   0x2010             MOVS     R0,#+16
   \   0000008A   0xE005             B.N      ??TIM_DeInit_9
    171                break;
    172                
    173              case TIM7_BASE:
    174                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
   \                     ??TIM_DeInit_5:
   \   0000008C   0x2101             MOVS     R1,#+1
   \   0000008E   0x2020             MOVS     R0,#+32
   \   00000090   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    175                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
   \   00000094   0x2100             MOVS     R1,#+0
   \   00000096   0x2020             MOVS     R0,#+32
   \                     ??TIM_DeInit_9:
   \   00000098   0xE8BD 0x4004      POP      {R2,LR}
   \   0000009C   0x.... 0x....      B.W      RCC_APB1PeriphResetCmd
    176                break;
    177                
    178              case TIM8_BASE:
    179                RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
   \                     ??TIM_DeInit_7:
   \   000000A0   0x2101             MOVS     R1,#+1
   \   000000A2   0xF44F 0x5000      MOV      R0,#+8192
   \   000000A6   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    180                RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
   \   000000AA   0x2100             MOVS     R1,#+0
   \   000000AC   0xF44F 0x5000      MOV      R0,#+8192
   \                     ??TIM_DeInit_8:
   \   000000B0   0xE8BD 0x4004      POP      {R2,LR}
   \   000000B4   0x.... 0x....      B.W      RCC_APB2PeriphResetCmd
    181                break; 
    182                
    183              default:
    184                break;
    185            }
    186          }
    187          
    188          /*******************************************************************************
    189          * Function Name  : TIM_TimeBaseInit
    190          * Description    : Initializes the TIMx Time Base Unit peripheral according to 
    191          *                  the specified parameters in the TIM_TimeBaseInitStruct.
    192          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
    193          *                    peripheral.
    194          *                  - TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef
    195          *                   structure that contains the configuration information for
    196          *                   the specified TIM peripheral.
    197          * Output         : None
    198          * Return         : None
    199          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    200          void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
    201          {
    202            /* Check the parameters */
    203            assert_param(IS_TIM_123458_PERIPH(TIMx)); 
    204            assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
    205            assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
    206          
    207            /* Select the Counter Mode and set the clock division */
    208            TIMx->CR1 &= CR1_CKD_Mask & CR1_CounterMode_Mask;
   \                     TIM_TimeBaseInit:
   \   00000000   0x8802             LDRH     R2,[R0, #+0]
   \   00000002   0xF002 0x028F      AND      R2,R2,#0x8F
   \   00000006   0x8002             STRH     R2,[R0, #+0]
    209            TIMx->CR1 |= (u32)TIM_TimeBaseInitStruct->TIM_ClockDivision |
    210                          TIM_TimeBaseInitStruct->TIM_CounterMode;
   \   00000008   0x8802             LDRH     R2,[R0, #+0]
   \   0000000A   0x88CB             LDRH     R3,[R1, #+6]
   \   0000000C   0xF8B1 0xC002      LDRH     R12,[R1, #+2]
   \   00000010   0xEA4C 0x0303      ORR      R3,R12,R3
   \   00000014   0x431A             ORRS     R2,R3,R2
   \   00000016   0x8002             STRH     R2,[R0, #+0]
    211            /* Set the Autoreload value */
    212            TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
   \   00000018   0x888A             LDRH     R2,[R1, #+4]
   \   0000001A   0x8582             STRH     R2,[R0, #+44]
    213          
    214            /* Set the Prescaler value */
    215            TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
   \   0000001C   0x880A             LDRH     R2,[R1, #+0]
   \   0000001E   0x8502             STRH     R2,[R0, #+40]
    216          
    217            /* Generate an update event to reload the Prescaler value immediatly */
    218            TIMx->EGR = TIM_PSCReloadMode_Immediate;
   \   00000020   0x2201             MOVS     R2,#+1
   \   00000022   0x8282             STRH     R2,[R0, #+20]
    219              
    220            if (((*(u32*)&TIMx) == TIM1_BASE) || ((*(u32*)&TIMx) == TIM8_BASE))  
   \   00000024   0x....             LDR.N    R2,??DataTable4_5  ;; 0x40012c00
   \   00000026   0x4290             CMP      R0,R2
   \   00000028   0xBF19             ITTEE    NE 
   \   0000002A   0x....             LDRNE.N  R2,??DataTable4_6  ;; 0x40013400
   \   0000002C   0x4290             CMPNE    R0,R2
   \   0000002E   0x7A09             LDRBEQ   R1,[R1, #+8]
   \   00000030   0x8601             STRHEQ   R1,[R0, #+48]
    221            {
    222              /* Set the Repetition Counter value */
    223              TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
    224            }        
    225          }
   \   00000032   0x4770             BX       LR               ;; return
    226          
    227          /*******************************************************************************
    228          * Function Name  : TIM_OC1Init
    229          * Description    : Initializes the TIMx Channel1 according to the specified
    230          *                  parameters in the TIM_OCInitStruct.
    231          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
    232          *                    peripheral.
    233          *                  - TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    234          *                    that contains the configuration information for the specified
    235          *                    TIM peripheral.
    236          * Output         : None
    237          * Return         : None
    238          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    239          void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    240          {
   \                     TIM_OC1Init:
   \   00000000   0xB430             PUSH     {R4,R5}
    241            u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    242             
    243            /* Check the parameters */
    244            assert_param(IS_TIM_123458_PERIPH(TIMx)); 
    245            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    246            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    247            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    248          
    249            /* Disable the Channel 1: Reset the CC1E Bit */
    250            TIMx->CCER &= CCER_CC1E_Reset;
   \   00000002   0x8C02             LDRH     R2,[R0, #+32]
   \   00000004   0xF64F 0x73FE      MOVW     R3,#+65534
   \   00000008   0x401A             ANDS     R2,R3,R2
   \   0000000A   0x8402             STRH     R2,[R0, #+32]
    251            
    252            /* Get the TIMx CCER register value */
    253            tmpccer = TIMx->CCER;
   \   0000000C   0x8C04             LDRH     R4,[R0, #+32]
    254          
    255            /* Get the TIMx CR2 register value */
    256            tmpcr2 =  TIMx->CR2;
   \   0000000E   0x8882             LDRH     R2,[R0, #+4]
    257            
    258            /* Get the TIMx CCMR1 register value */
    259            tmpccmrx = TIMx->CCMR1;
    260              
    261            /* Reset the Output Compare Mode Bits */
    262            tmpccmrx &= CCMR_OC13M_Mask;
    263            
    264            /* Select the Output Compare Mode */
    265            tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
   \   00000010   0x8B03             LDRH     R3,[R0, #+24]
   \   00000012   0xF64F 0x758F      MOVW     R5,#+65423
   \   00000016   0x402B             ANDS     R3,R5,R3
   \   00000018   0x880D             LDRH     R5,[R1, #+0]
   \   0000001A   0x432B             ORRS     R3,R5,R3
    266            
    267            /* Reset the Output Polarity level */
    268            tmpccer &= CCER_CC1P_Reset;
    269          
    270            /* Set the Output Compare Polarity */
    271            tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
    272            
    273            /* Set the Output State */
    274            tmpccer |= TIM_OCInitStruct->TIM_OutputState;
   \   0000001C   0xF64F 0x75FD      MOVW     R5,#+65533
   \   00000020   0x402C             ANDS     R4,R5,R4
   \   00000022   0x890D             LDRH     R5,[R1, #+8]
   \   00000024   0x432C             ORRS     R4,R5,R4
   \   00000026   0x884D             LDRH     R5,[R1, #+2]
   \   00000028   0x432C             ORRS     R4,R5,R4
    275            
    276            /* Set the Capture Compare Register value */
    277            TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
   \   0000002A   0x88CD             LDRH     R5,[R1, #+6]
   \   0000002C   0x8685             STRH     R5,[R0, #+52]
    278            
    279            if((*(u32*)&TIMx == TIM1_BASE) || (*(u32*)&TIMx == TIM8_BASE))
   \   0000002E   0x....             LDR.N    R5,??DataTable4_5  ;; 0x40012c00
   \   00000030   0x42A8             CMP      R0,R5
   \   00000032   0xBF1C             ITT      NE 
   \   00000034   0x....             LDRNE.N  R5,??DataTable4_6  ;; 0x40013400
   \   00000036   0x42A8             CMPNE    R0,R5
   \   00000038   0xD110             BNE.N    ??TIM_OC1Init_0
    280            {
    281              assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    282              assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    283              assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    284              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    285              
    286              /* Reset the Output N Polarity level */
    287              tmpccer &= CCER_CC1NP_Reset;
    288          
    289              /* Set the Output N Polarity */
    290              tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
    291          
    292              /* Reset the Output N State */
    293              tmpccer &= CCER_CC1NE_Reset;
    294              
    295              /* Set the Output N State */
    296              tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
   \   0000003A   0xF64F 0x75F7      MOVW     R5,#+65527
   \   0000003E   0x402C             ANDS     R4,R5,R4
   \   00000040   0x894D             LDRH     R5,[R1, #+10]
   \   00000042   0x432C             ORRS     R4,R5,R4
   \   00000044   0xF64F 0x75FB      MOVW     R5,#+65531
   \   00000048   0x402C             ANDS     R4,R5,R4
   \   0000004A   0x888D             LDRH     R5,[R1, #+4]
   \   0000004C   0x432C             ORRS     R4,R5,R4
    297          
    298              /* Reset the Ouput Compare and Output Compare N IDLE State */
    299              tmpcr2 &= CR2_OIS1_Reset;
    300              tmpcr2 &= CR2_OIS1N_Reset;
    301          
    302              /* Set the Output Idle state */
    303              tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
    304          
    305              /* Set the Output N Idle state */
    306              tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
   \   0000004E   0xF647 0x45FF      MOVW     R5,#+31999
   \   00000052   0x402A             ANDS     R2,R5,R2
   \   00000054   0x898D             LDRH     R5,[R1, #+12]
   \   00000056   0x432A             ORRS     R2,R5,R2
   \   00000058   0x89C9             LDRH     R1,[R1, #+14]
   \   0000005A   0x430A             ORRS     R2,R1,R2
    307            }
    308            /* Write to TIMx CR2 */
    309            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC1Init_0:
   \   0000005C   0x8082             STRH     R2,[R0, #+4]
    310            
    311            /* Write to TIMx CCMR1 */
    312            TIMx->CCMR1 = tmpccmrx;
   \   0000005E   0x8303             STRH     R3,[R0, #+24]
    313            
    314            /* Write to TIMx CCER */
    315            TIMx->CCER = tmpccer;
   \   00000060   0x8404             STRH     R4,[R0, #+32]
    316          }
   \   00000062   0xBC30             POP      {R4,R5}
   \   00000064   0x4770             BX       LR               ;; return
    317          
    318          /*******************************************************************************
    319          * Function Name  : TIM_OC2Init
    320          * Description    : Initializes the TIMx Channel2 according to the specified
    321          *                  parameters in the TIM_OCInitStruct.
    322          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
    323          *                    peripheral.
    324          *                  - TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    325          *                    that contains the configuration information for the specified
    326          *                    TIM peripheral.
    327          * Output         : None
    328          * Return         : None
    329          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    330          void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    331          {
   \                     TIM_OC2Init:
   \   00000000   0xB470             PUSH     {R4-R6}
    332            u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    333             
    334            /* Check the parameters */
    335            assert_param(IS_TIM_123458_PERIPH(TIMx)); 
    336            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    337            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    338            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    339          
    340            /* Disable the Channel 2: Reset the CC2E Bit */
    341            TIMx->CCER &= CCER_CC2E_Reset;
   \   00000002   0x8C02             LDRH     R2,[R0, #+32]
   \   00000004   0xF64F 0x73EF      MOVW     R3,#+65519
   \   00000008   0x401A             ANDS     R2,R3,R2
   \   0000000A   0x8402             STRH     R2,[R0, #+32]
    342            
    343            /* Get the TIMx CCER register value */  
    344            tmpccer = TIMx->CCER;
   \   0000000C   0x8C04             LDRH     R4,[R0, #+32]
    345          
    346            /* Get the TIMx CR2 register value */
    347            tmpcr2 =  TIMx->CR2;
   \   0000000E   0x8882             LDRH     R2,[R0, #+4]
    348            
    349            /* Get the TIMx CCMR1 register value */
    350            tmpccmrx = TIMx->CCMR1;
    351              
    352            /* Reset the Output Compare Mode Bits */
    353            tmpccmrx &= CCMR_OC24M_Mask;
    354            
    355            /* Select the Output Compare Mode */
    356            tmpccmrx |= (u16)(TIM_OCInitStruct->TIM_OCMode << 8);
   \   00000010   0x8B03             LDRH     R3,[R0, #+24]
   \   00000012   0xF648 0x75FF      MOVW     R5,#+36863
   \   00000016   0x402B             ANDS     R3,R5,R3
   \   00000018   0x880D             LDRH     R5,[R1, #+0]
   \   0000001A   0xEA43 0x2305      ORR      R3,R3,R5, LSL #+8
    357            
    358            /* Reset the Output Polarity level */
    359            tmpccer &= CCER_CC2P_Reset;
    360          
    361            /* Set the Output Compare Polarity */
    362            tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCPolarity << 4);
    363            
    364            /* Set the Output State */
    365            tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputState << 4);
   \   0000001E   0xF64F 0x75DF      MOVW     R5,#+65503
   \   00000022   0x402C             ANDS     R4,R5,R4
   \   00000024   0x890D             LDRH     R5,[R1, #+8]
   \   00000026   0x884E             LDRH     R6,[R1, #+2]
   \   00000028   0x4335             ORRS     R5,R6,R5
   \   0000002A   0xEA44 0x1405      ORR      R4,R4,R5, LSL #+4
    366            
    367            /* Set the Capture Compare Register value */
    368            TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
   \   0000002E   0x88CD             LDRH     R5,[R1, #+6]
   \   00000030   0x8705             STRH     R5,[R0, #+56]
    369            
    370            if((*(u32*)&TIMx == TIM1_BASE) || (*(u32*)&TIMx == TIM8_BASE))
   \   00000032   0x....             LDR.N    R5,??DataTable4_5  ;; 0x40012c00
   \   00000034   0x42A8             CMP      R0,R5
   \   00000036   0xBF1C             ITT      NE 
   \   00000038   0x....             LDRNE.N  R5,??DataTable4_6  ;; 0x40013400
   \   0000003A   0x42A8             CMPNE    R0,R5
   \   0000003C   0xD113             BNE.N    ??TIM_OC2Init_0
    371            {
    372              assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    373              assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    374              assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    375              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    376              
    377              /* Reset the Output N Polarity level */
    378              tmpccer &= CCER_CC2NP_Reset;
    379          
    380              /* Set the Output N Polarity */
    381              tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
    382          
    383              /* Reset the Output N State */
    384              tmpccer &= CCER_CC2NE_Reset;
    385              
    386              /* Set the Output N State */
    387              tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputNState << 4);
   \   0000003E   0xF64F 0x757F      MOVW     R5,#+65407
   \   00000042   0x402C             ANDS     R4,R5,R4
   \   00000044   0x894D             LDRH     R5,[R1, #+10]
   \   00000046   0xEA44 0x1405      ORR      R4,R4,R5, LSL #+4
   \   0000004A   0xF64F 0x75BF      MOVW     R5,#+65471
   \   0000004E   0x402C             ANDS     R4,R5,R4
   \   00000050   0x888D             LDRH     R5,[R1, #+4]
   \   00000052   0xEA44 0x1405      ORR      R4,R4,R5, LSL #+4
    388          
    389              /* Reset the Ouput Compare and Output Compare N IDLE State */
    390              tmpcr2 &= CR2_OIS2_Reset;
    391              tmpcr2 &= CR2_OIS2N_Reset;
    392          
    393              /* Set the Output Idle state */
    394              tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCIdleState << 2);
    395          
    396              /* Set the Output N Idle state */
    397              tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
   \   00000056   0xF247 0x35FF      MOVW     R5,#+29695
   \   0000005A   0x402A             ANDS     R2,R5,R2
   \   0000005C   0x898D             LDRH     R5,[R1, #+12]
   \   0000005E   0x89C9             LDRH     R1,[R1, #+14]
   \   00000060   0x4329             ORRS     R1,R1,R5
   \   00000062   0xEA42 0x0281      ORR      R2,R2,R1, LSL #+2
    398            }
    399          
    400            /* Write to TIMx CR2 */
    401            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC2Init_0:
   \   00000066   0x8082             STRH     R2,[R0, #+4]
    402            
    403            /* Write to TIMx CCMR1 */
    404            TIMx->CCMR1 = tmpccmrx;
   \   00000068   0x8303             STRH     R3,[R0, #+24]
    405            
    406            /* Write to TIMx CCER */
    407            TIMx->CCER = tmpccer;
   \   0000006A   0x....             B.N      ??Subroutine2_0
    408          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   0x8082             STRH     R2,[R0, #+4]
   \   00000002   0x8383             STRH     R3,[R0, #+28]
   \                     ??Subroutine2_0:
   \   00000004   0x8404             STRH     R4,[R0, #+32]
   \   00000006   0xBC70             POP      {R4-R6}
   \   00000008   0x4770             BX       LR               ;; return
    409          
    410          /*******************************************************************************
    411          * Function Name  : TIM_OC3Init
    412          * Description    : Initializes the TIMx Channel3 according to the specified
    413          *                  parameters in the TIM_OCInitStruct.
    414          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
    415          *                    peripheral.
    416          *                  - TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    417          *                    that contains the configuration information for the specified
    418          *                    TIM peripheral.
    419          * Output         : None
    420          * Return         : None
    421          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    422          void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    423          {
   \                     TIM_OC3Init:
   \   00000000   0xB470             PUSH     {R4-R6}
    424            u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    425             
    426            /* Check the parameters */
    427            assert_param(IS_TIM_123458_PERIPH(TIMx)); 
    428            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    429            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    430            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    431          
    432            /* Disable the Channel 2: Reset the CC2E Bit */
    433            TIMx->CCER &= CCER_CC3E_Reset;
   \   00000002   0x8C02             LDRH     R2,[R0, #+32]
   \   00000004   0xF64F 0x63FF      MOVW     R3,#+65279
   \   00000008   0x401A             ANDS     R2,R3,R2
   \   0000000A   0x8402             STRH     R2,[R0, #+32]
    434            
    435            /* Get the TIMx CCER register value */
    436            tmpccer = TIMx->CCER;
   \   0000000C   0x8C04             LDRH     R4,[R0, #+32]
    437          
    438            /* Get the TIMx CR2 register value */
    439            tmpcr2 =  TIMx->CR2;
   \   0000000E   0x8882             LDRH     R2,[R0, #+4]
    440            
    441            /* Get the TIMx CCMR2 register value */
    442            tmpccmrx = TIMx->CCMR2;
    443              
    444            /* Reset the Output Compare Mode Bits */
    445            tmpccmrx &= CCMR_OC13M_Mask;
    446            
    447            /* Select the Output Compare Mode */
    448            tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
   \   00000010   0x8B83             LDRH     R3,[R0, #+28]
   \   00000012   0xF64F 0x758F      MOVW     R5,#+65423
   \   00000016   0x402B             ANDS     R3,R5,R3
   \   00000018   0x880D             LDRH     R5,[R1, #+0]
   \   0000001A   0x432B             ORRS     R3,R5,R3
    449            
    450            /* Reset the Output Polarity level */
    451            tmpccer &= CCER_CC3P_Reset;
    452          
    453            /* Set the Output Compare Polarity */
    454            tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCPolarity << 8);
    455            
    456            /* Set the Output State */
    457            tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputState << 8);
   \   0000001C   0xF64F 0x55FF      MOVW     R5,#+65023
   \   00000020   0x402C             ANDS     R4,R5,R4
   \   00000022   0x890D             LDRH     R5,[R1, #+8]
   \   00000024   0x884E             LDRH     R6,[R1, #+2]
   \   00000026   0x4335             ORRS     R5,R6,R5
   \   00000028   0xEA44 0x2405      ORR      R4,R4,R5, LSL #+8
    458            
    459            /* Set the Capture Compare Register value */
    460            TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
   \   0000002C   0x88CD             LDRH     R5,[R1, #+6]
   \   0000002E   0x8785             STRH     R5,[R0, #+60]
    461            
    462            if((*(u32*)&TIMx == TIM1_BASE) || (*(u32*)&TIMx == TIM8_BASE))
   \   00000030   0x....             LDR.N    R5,??DataTable4_5  ;; 0x40012c00
   \   00000032   0x42A8             CMP      R0,R5
   \   00000034   0xBF1C             ITT      NE 
   \   00000036   0x....             LDRNE.N  R5,??DataTable4_6  ;; 0x40013400
   \   00000038   0x42A8             CMPNE    R0,R5
   \   0000003A   0xD113             BNE.N    ??TIM_OC3Init_0
    463            {
    464              assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    465              assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    466              assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    467              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    468              
    469              /* Reset the Output N Polarity level */
    470              tmpccer &= CCER_CC3NP_Reset;
    471          
    472              /* Set the Output N Polarity */
    473              tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
    474          
    475              /* Reset the Output N State */
    476              tmpccer &= CCER_CC3NE_Reset;
    477              
    478              /* Set the Output N State */
    479              tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputNState << 8);
   \   0000003C   0xF24F 0x75FF      MOVW     R5,#+63487
   \   00000040   0x402C             ANDS     R4,R5,R4
   \   00000042   0x894D             LDRH     R5,[R1, #+10]
   \   00000044   0xEA44 0x2405      ORR      R4,R4,R5, LSL #+8
   \   00000048   0xF64F 0x35FF      MOVW     R5,#+64511
   \   0000004C   0x402C             ANDS     R4,R5,R4
   \   0000004E   0x888D             LDRH     R5,[R1, #+4]
   \   00000050   0xEA44 0x2405      ORR      R4,R4,R5, LSL #+8
    480          
    481              /* Reset the Ouput Compare and Output Compare N IDLE State */
    482              tmpcr2 &= CR2_OIS3_Reset;
    483              tmpcr2 &= CR2_OIS3N_Reset;
    484          
    485              /* Set the Output Idle state */
    486              tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCIdleState << 4);
    487          
    488              /* Set the Output N Idle state */
    489              tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
   \   00000054   0xF644 0x75FF      MOVW     R5,#+20479
   \   00000058   0x402A             ANDS     R2,R5,R2
   \   0000005A   0x898D             LDRH     R5,[R1, #+12]
   \   0000005C   0x89C9             LDRH     R1,[R1, #+14]
   \   0000005E   0x4329             ORRS     R1,R1,R5
   \   00000060   0xEA42 0x1201      ORR      R2,R2,R1, LSL #+4
    490            }
    491          
    492            /* Write to TIMx CR2 */
    493            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC3Init_0:
   \   00000064   0x....             B.N      ?Subroutine2
    494            
    495            /* Write to TIMx CCMR2 */
    496            TIMx->CCMR2 = tmpccmrx;
    497            
    498            /* Write to TIMx CCER */
    499            TIMx->CCER = tmpccer;
    500          }
    501          
    502          /*******************************************************************************
    503          * Function Name  : TIM_OC4Init
    504          * Description    : Initializes the TIMx Channel4 according to the specified
    505          *                  parameters in the TIM_OCInitStruct.
    506          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
    507          *                    peripheral.
    508          *                  - TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    509          *                    that contains the configuration information for the specified
    510          *                    TIM peripheral.
    511          * Output         : None
    512          * Return         : None
    513          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    514          void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    515          {
   \                     TIM_OC4Init:
   \   00000000   0xB470             PUSH     {R4-R6}
    516            u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    517             
    518            /* Check the parameters */
    519            assert_param(IS_TIM_123458_PERIPH(TIMx)); 
    520            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    521            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    522            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    523          
    524            /* Disable the Channel 2: Reset the CC4E Bit */
    525            TIMx->CCER &= CCER_CC4E_Reset;
   \   00000002   0x8C02             LDRH     R2,[R0, #+32]
   \   00000004   0xF64E 0x73FF      MOVW     R3,#+61439
   \   00000008   0x401A             ANDS     R2,R3,R2
   \   0000000A   0x8402             STRH     R2,[R0, #+32]
    526            
    527            /* Get the TIMx CCER register value */
    528            tmpccer = TIMx->CCER;
   \   0000000C   0x8C04             LDRH     R4,[R0, #+32]
    529          
    530            /* Get the TIMx CR2 register value */
    531            tmpcr2 =  TIMx->CR2;
   \   0000000E   0x8882             LDRH     R2,[R0, #+4]
    532            
    533            /* Get the TIMx CCMR2 register value */
    534            tmpccmrx = TIMx->CCMR2;
    535              
    536            /* Reset the Output Compare Mode Bits */
    537            tmpccmrx &= CCMR_OC24M_Mask;
    538            
    539            /* Select the Output Compare Mode */
    540            tmpccmrx |= (u16)(TIM_OCInitStruct->TIM_OCMode << 8);
   \   00000010   0x8B83             LDRH     R3,[R0, #+28]
   \   00000012   0xF648 0x75FF      MOVW     R5,#+36863
   \   00000016   0x402B             ANDS     R3,R5,R3
   \   00000018   0x880D             LDRH     R5,[R1, #+0]
   \   0000001A   0xEA43 0x2305      ORR      R3,R3,R5, LSL #+8
    541            
    542            /* Reset the Output Polarity level */
    543            tmpccer &= CCER_CC4P_Reset;
    544          
    545            /* Set the Output Compare Polarity */
    546            tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCPolarity << 12);
    547            
    548            /* Set the Output State */
    549            tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputState << 12);
   \   0000001E   0xF64D 0x75FF      MOVW     R5,#+57343
   \   00000022   0x402C             ANDS     R4,R5,R4
   \   00000024   0x890D             LDRH     R5,[R1, #+8]
   \   00000026   0x884E             LDRH     R6,[R1, #+2]
   \   00000028   0x4335             ORRS     R5,R6,R5
   \   0000002A   0xEA44 0x3405      ORR      R4,R4,R5, LSL #+12
    550            
    551            /* Set the Capture Compare Register value */
    552            TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
   \   0000002E   0x88CD             LDRH     R5,[R1, #+6]
   \   00000030   0xF8A0 0x5040      STRH     R5,[R0, #+64]
    553            
    554            if((*(u32*)&TIMx == TIM1_BASE) || (*(u32*)&TIMx == TIM8_BASE))
   \   00000034   0x4D02             LDR.N    R5,??TIM_OC4Init_0  ;; 0x40012c00
   \   00000036   0x42A8             CMP      R0,R5
   \   00000038   0xBF1C             ITT      NE 
   \   0000003A   0x4D02             LDRNE.N  R5,??TIM_OC4Init_0+0x4  ;; 0x40013400
   \   0000003C   0x42A8             CMPNE    R0,R5
   \   0000003E   0xE003             B.N      ??TIM_OC4Init_1
   \                     ??TIM_OC4Init_0:
   \   00000040   0x40012C00         DC32     0x40012c00
   \   00000044   0x40013400         DC32     0x40013400
   \                     ??TIM_OC4Init_1:
   \   00000048   0xD104             BNE.N    ??TIM_OC4Init_2
    555            {
    556              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    557          
    558              /* Reset the Ouput Compare IDLE State */
    559              tmpcr2 &= CR2_OIS4_Reset;
    560          
    561              /* Set the Output Idle state */
    562              tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCIdleState << 6);
   \   0000004A   0x0492             LSLS     R2,R2,#+18
   \   0000004C   0x0C92             LSRS     R2,R2,#+18
   \   0000004E   0x8989             LDRH     R1,[R1, #+12]
   \   00000050   0xEA42 0x1281      ORR      R2,R2,R1, LSL #+6
    563            }
    564          
    565            /* Write to TIMx CR2 */
    566            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC4Init_2:
   \   00000054                      REQUIRE ?Subroutine2
   \   00000054                      ;; // Fall through to label ?Subroutine2
    567            
    568            /* Write to TIMx CCMR2 */  
    569            TIMx->CCMR2 = tmpccmrx;
    570            
    571            /* Write to TIMx CCER */
    572            TIMx->CCER = tmpccer;
    573          }
    574          
    575          /*******************************************************************************
    576          * Function Name  : TIM_ICInit
    577          * Description    : Initializes the TIM peripheral according to the specified
    578          *                  parameters in the TIM_ICInitStruct.
    579          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
    580          *                    peripheral.
    581          *                  - TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
    582          *                    that contains the configuration information for the specified
    583          *                    TIM peripheral.
    584          * Output         : None
    585          * Return         : None
    586          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    587          void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
    588          {
   \                     TIM_ICInit:
   \   00000000   0xB4FC             PUSH     {R2-R7}
    589            /* Check the parameters */
    590            assert_param(IS_TIM_123458_PERIPH(TIMx));
    591            assert_param(IS_TIM_CHANNEL(TIM_ICInitStruct->TIM_Channel));
    592            assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
    593            assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
    594            assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
    595            assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
    596            
    597            if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
   \   00000002   0x884A             LDRH     R2,[R1, #+2]
   \   00000004   0x888B             LDRH     R3,[R1, #+4]
   \   00000006   0x890C             LDRH     R4,[R1, #+8]
   \   00000008   0x880D             LDRH     R5,[R1, #+0]
   \   0000000A   0xB9BD             CBNZ.N   R5,??TIM_ICInit_0
    598            {
    599              /* TI1 Configuration */
    600              TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
    601                         TIM_ICInitStruct->TIM_ICSelection,
    602                         TIM_ICInitStruct->TIM_ICFilter);
   \   0000000C   0x8C05             LDRH     R5,[R0, #+32]
   \   0000000E   0xF64F 0x76FE      MOVW     R6,#+65534
   \   00000012   0x4035             ANDS     R5,R6,R5
   \   00000014   0x8405             STRH     R5,[R0, #+32]
   \   00000016   0x8B05             LDRH     R5,[R0, #+24]
   \   00000018   0x8C06             LDRH     R6,[R0, #+32]
   \   0000001A   0xF64F 0x770C      MOVW     R7,#+65292
   \   0000001E   0x403D             ANDS     R5,R7,R5
   \   00000020   0x432B             ORRS     R3,R3,R5
   \   00000022   0xEA43 0x1304      ORR      R3,R3,R4, LSL #+4
   \   00000026   0x8303             STRH     R3,[R0, #+24]
   \   00000028   0xF64F 0x73FD      MOVW     R3,#+65533
   \   0000002C   0x4033             ANDS     R3,R3,R6
   \   0000002E   0x431A             ORRS     R2,R2,R3
   \   00000030   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000034   0x8402             STRH     R2,[R0, #+32]
    603          
    604              /* Set the Input Capture Prescaler value */
    605              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   00000036   0x88C9             LDRH     R1,[R1, #+6]
   \   00000038   0xBCFC             POP      {R2-R7}
   \   0000003A   0x....             B.N      TIM_SetIC1Prescaler
    606            }
    607            else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
   \                     ??TIM_ICInit_0:
   \   0000003C   0x2D04             CMP      R5,#+4
   \   0000003E   0xD119             BNE.N    ??TIM_ICInit_1
    608            {
    609              /* TI2 Configuration */
    610              TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
    611                         TIM_ICInitStruct->TIM_ICSelection,
    612                         TIM_ICInitStruct->TIM_ICFilter);
   \   00000040   0x8C05             LDRH     R5,[R0, #+32]
   \   00000042   0xF64F 0x76EF      MOVW     R6,#+65519
   \   00000046   0x4035             ANDS     R5,R6,R5
   \   00000048   0x8405             STRH     R5,[R0, #+32]
   \   0000004A   0x8B05             LDRH     R5,[R0, #+24]
   \   0000004C   0x8C06             LDRH     R6,[R0, #+32]
   \   0000004E   0xF640 0x47FF      MOVW     R7,#+3327
   \   00000052   0x403D             ANDS     R5,R7,R5
   \   00000054   0xEA45 0x3404      ORR      R4,R5,R4, LSL #+12
   \   00000058   0xEA44 0x2303      ORR      R3,R4,R3, LSL #+8
   \   0000005C   0x8303             STRH     R3,[R0, #+24]
   \   0000005E   0xF64F 0x73DF      MOVW     R3,#+65503
   \   00000062   0x4033             ANDS     R3,R3,R6
   \   00000064   0xEA43 0x1202      ORR      R2,R3,R2, LSL #+4
   \   00000068   0xF042 0x0210      ORR      R2,R2,#0x10
   \   0000006C   0x8402             STRH     R2,[R0, #+32]
    613          
    614              /* Set the Input Capture Prescaler value */
    615              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   0000006E   0x88C9             LDRH     R1,[R1, #+6]
   \   00000070   0xBCFC             POP      {R2-R7}
   \   00000072   0x....             B.N      TIM_SetIC2Prescaler
    616            }
    617            else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
   \                     ??TIM_ICInit_1:
   \   00000074   0x2D08             CMP      R5,#+8
   \   00000076   0x8C05             LDRH     R5,[R0, #+32]
   \   00000078   0xD117             BNE.N    ??TIM_ICInit_2
    618            {
    619              /* TI3 Configuration */
    620              TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
    621                         TIM_ICInitStruct->TIM_ICSelection,
    622                         TIM_ICInitStruct->TIM_ICFilter);
   \   0000007A   0xF64F 0x66FF      MOVW     R6,#+65279
   \   0000007E   0x4035             ANDS     R5,R6,R5
   \   00000080   0x8405             STRH     R5,[R0, #+32]
   \   00000082   0x8B85             LDRH     R5,[R0, #+28]
   \   00000084   0x8C06             LDRH     R6,[R0, #+32]
   \   00000086   0xF64F 0x770C      MOVW     R7,#+65292
   \   0000008A   0x403D             ANDS     R5,R7,R5
   \   0000008C   0x432B             ORRS     R3,R3,R5
   \   0000008E   0xEA43 0x1304      ORR      R3,R3,R4, LSL #+4
   \   00000092   0x8383             STRH     R3,[R0, #+28]
   \   00000094   0xF64F 0x53FF      MOVW     R3,#+65023
   \   00000098   0x4033             ANDS     R3,R3,R6
   \   0000009A   0xEA43 0x2202      ORR      R2,R3,R2, LSL #+8
   \   0000009E   0xF442 0x7280      ORR      R2,R2,#0x100
   \   000000A2   0x8402             STRH     R2,[R0, #+32]
    623          
    624              /* Set the Input Capture Prescaler value */
    625              TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   000000A4   0x88C9             LDRH     R1,[R1, #+6]
   \   000000A6   0xBCFC             POP      {R2-R7}
   \   000000A8   0x....             B.N      TIM_SetIC3Prescaler
    626            }
    627            else
    628            {
    629              /* TI4 Configuration */
    630              TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
    631                         TIM_ICInitStruct->TIM_ICSelection,
    632                         TIM_ICInitStruct->TIM_ICFilter);
   \                     ??TIM_ICInit_2:
   \   000000AA   0xF64E 0x76FF      MOVW     R6,#+61439
   \   000000AE   0x4035             ANDS     R5,R6,R5
   \   000000B0   0x8405             STRH     R5,[R0, #+32]
   \   000000B2   0x8B85             LDRH     R5,[R0, #+28]
   \   000000B4   0x8C06             LDRH     R6,[R0, #+32]
   \   000000B6   0xF640 0x47FF      MOVW     R7,#+3327
   \   000000BA   0x403D             ANDS     R5,R7,R5
   \   000000BC   0xEA45 0x2303      ORR      R3,R5,R3, LSL #+8
   \   000000C0   0xEA43 0x3304      ORR      R3,R3,R4, LSL #+12
   \   000000C4   0x8383             STRH     R3,[R0, #+28]
   \   000000C6   0xF64D 0x73FF      MOVW     R3,#+57343
   \   000000CA   0x4033             ANDS     R3,R3,R6
   \   000000CC   0xEA43 0x3202      ORR      R2,R3,R2, LSL #+12
   \   000000D0   0xF442 0x5280      ORR      R2,R2,#0x1000
   \   000000D4   0x8402             STRH     R2,[R0, #+32]
    633          
    634              /* Set the Input Capture Prescaler value */
    635              TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   000000D6   0x88C9             LDRH     R1,[R1, #+6]
   \   000000D8   0xBCFC             POP      {R2-R7}
   \   000000DA   0x....             B.N      TIM_SetIC4Prescaler
    636            }
    637          }
    638          
    639          /*******************************************************************************
    640          * Function Name  : TIM_PWMIConfig
    641          * Description    : Configures the TIM peripheral according to the specified
    642          *                  parameters in the TIM_ICInitStruct to measure an external PWM
    643          *                  signal.
    644          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
    645          *                    peripheral.
    646          *                  - TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
    647          *                    that contains the configuration information for the specified
    648          *                    TIM peripheral.
    649          * Output         : None
    650          * Return         : None
    651          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    652          void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
    653          {
   \                     TIM_PWMIConfig:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    654            u16 icoppositepolarity = TIM_ICPolarity_Rising;
   \   00000008   0x2600             MOVS     R6,#+0
    655            u16 icoppositeselection = TIM_ICSelection_DirectTI;
   \   0000000A   0x2701             MOVS     R7,#+1
    656          
    657            /* Check the parameters */
    658            assert_param(IS_TIM_123458_PERIPH(TIMx));
    659          
    660            /* Select the Opposite Input Polarity */
    661            if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
   \   0000000C   0x8868             LDRH     R0,[R5, #+2]
   \   0000000E   0xB900             CBNZ.N   R0,??TIM_PWMIConfig_0
    662            {
    663              icoppositepolarity = TIM_ICPolarity_Falling;
   \   00000010   0x2602             MOVS     R6,#+2
    664            }
    665            else
    666            {
    667              icoppositepolarity = TIM_ICPolarity_Rising;
    668            }
    669          
    670            /* Select the Opposite Input */
    671            if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
   \                     ??TIM_PWMIConfig_0:
   \   00000012   0x88A9             LDRH     R1,[R5, #+4]
   \   00000014   0x2901             CMP      R1,#+1
   \   00000016   0xBF08             IT       EQ 
   \   00000018   0x2702             MOVEQ    R7,#+2
    672            {
    673              icoppositeselection = TIM_ICSelection_IndirectTI;
    674            }
    675            else
    676            {
    677              icoppositeselection = TIM_ICSelection_DirectTI;
    678            }
    679          
    680            if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
   \   0000001A   0x892A             LDRH     R2,[R5, #+8]
   \   0000001C   0xF640 0x48FF      MOVW     R8,#+3327
   \   00000020   0x882B             LDRH     R3,[R5, #+0]
   \   00000022   0x2B00             CMP      R3,#+0
   \   00000024   0x8C23             LDRH     R3,[R4, #+32]
   \   00000026   0xD137             BNE.N    ??TIM_PWMIConfig_1
    681            {
    682              /* TI1 Configuration */
    683              TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
    684                         TIM_ICInitStruct->TIM_ICFilter);
   \   00000028   0xF64F 0x7CFE      MOVW     R12,#+65534
   \   0000002C   0xEA0C 0x0303      AND      R3,R12,R3
   \   00000030   0x8423             STRH     R3,[R4, #+32]
   \   00000032   0xF8B4 0xC018      LDRH     R12,[R4, #+24]
   \   00000036   0x8C23             LDRH     R3,[R4, #+32]
   \   00000038   0xF64F 0x7E0C      MOVW     LR,#+65292
   \   0000003C   0xEA0E 0x0C0C      AND      R12,LR,R12
   \   00000040   0xEA41 0x010C      ORR      R1,R1,R12
   \   00000044   0xEA41 0x1102      ORR      R1,R1,R2, LSL #+4
   \   00000048   0x8321             STRH     R1,[R4, #+24]
   \   0000004A   0xF64F 0x71FD      MOVW     R1,#+65533
   \   0000004E   0x4019             ANDS     R1,R1,R3
   \   00000050   0x4308             ORRS     R0,R0,R1
   \   00000052   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000056   0x8420             STRH     R0,[R4, #+32]
    685          
    686              /* Set the Input Capture Prescaler value */
    687              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   00000058   0x88E9             LDRH     R1,[R5, #+6]
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0x.... 0x....      BL       TIM_SetIC1Prescaler
    688          
    689              /* TI2 Configuration */
    690              TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
   \   00000060   0x8928             LDRH     R0,[R5, #+8]
   \   00000062   0x8C21             LDRH     R1,[R4, #+32]
   \   00000064   0xF64F 0x72EF      MOVW     R2,#+65519
   \   00000068   0x4011             ANDS     R1,R2,R1
   \   0000006A   0x8421             STRH     R1,[R4, #+32]
   \   0000006C   0x8B21             LDRH     R1,[R4, #+24]
   \   0000006E   0x8C22             LDRH     R2,[R4, #+32]
   \   00000070   0xEA08 0x0101      AND      R1,R8,R1
   \   00000074   0xEA41 0x3000      ORR      R0,R1,R0, LSL #+12
   \   00000078   0xEA40 0x2007      ORR      R0,R0,R7, LSL #+8
   \   0000007C   0x8320             STRH     R0,[R4, #+24]
   \   0000007E   0xF64F 0x70DF      MOVW     R0,#+65503
   \   00000082   0x4010             ANDS     R0,R0,R2
   \   00000084   0xEA40 0x1006      ORR      R0,R0,R6, LSL #+4
   \   00000088   0xF040 0x0010      ORR      R0,R0,#0x10
   \   0000008C   0x8420             STRH     R0,[R4, #+32]
    691          
    692              /* Set the Input Capture Prescaler value */
    693              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   0000008E   0x88E9             LDRH     R1,[R5, #+6]
   \   00000090   0x4620             MOV      R0,R4
   \   00000092   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   00000096   0x....             B.N      TIM_SetIC2Prescaler
    694            }
    695            else
    696            { 
    697              /* TI2 Configuration */
    698              TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
    699                         TIM_ICInitStruct->TIM_ICFilter);
   \                     ??TIM_PWMIConfig_1:
   \   00000098   0xF64F 0x7CEF      MOVW     R12,#+65519
   \   0000009C   0xEA0C 0x0303      AND      R3,R12,R3
   \   000000A0   0x8423             STRH     R3,[R4, #+32]
   \   000000A2   0x8B23             LDRH     R3,[R4, #+24]
   \   000000A4   0xF8B4 0xC020      LDRH     R12,[R4, #+32]
   \   000000A8   0xEA08 0x0303      AND      R3,R8,R3
   \   000000AC   0xEA43 0x3202      ORR      R2,R3,R2, LSL #+12
   \   000000B0   0xEA42 0x2101      ORR      R1,R2,R1, LSL #+8
   \   000000B4   0x8321             STRH     R1,[R4, #+24]
   \   000000B6   0xF64F 0x71DF      MOVW     R1,#+65503
   \   000000BA   0xEA01 0x010C      AND      R1,R1,R12
   \   000000BE   0xEA41 0x1000      ORR      R0,R1,R0, LSL #+4
   \   000000C2   0xF040 0x0010      ORR      R0,R0,#0x10
   \   000000C6   0x8420             STRH     R0,[R4, #+32]
    700          
    701              /* Set the Input Capture Prescaler value */
    702              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   000000C8   0x88E9             LDRH     R1,[R5, #+6]
   \   000000CA   0x4620             MOV      R0,R4
   \   000000CC   0x.... 0x....      BL       TIM_SetIC2Prescaler
    703          
    704              /* TI1 Configuration */
    705              TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
   \   000000D0   0x8928             LDRH     R0,[R5, #+8]
   \   000000D2   0x8C21             LDRH     R1,[R4, #+32]
   \   000000D4   0xF64F 0x72FE      MOVW     R2,#+65534
   \   000000D8   0x4011             ANDS     R1,R2,R1
   \   000000DA   0x8421             STRH     R1,[R4, #+32]
   \   000000DC   0x8B21             LDRH     R1,[R4, #+24]
   \   000000DE   0x8C22             LDRH     R2,[R4, #+32]
   \   000000E0   0xF64F 0x730C      MOVW     R3,#+65292
   \   000000E4   0x4019             ANDS     R1,R3,R1
   \   000000E6   0x4339             ORRS     R1,R7,R1
   \   000000E8   0xEA41 0x1000      ORR      R0,R1,R0, LSL #+4
   \   000000EC   0x8320             STRH     R0,[R4, #+24]
   \   000000EE   0xF64F 0x70FD      MOVW     R0,#+65533
   \   000000F2   0x4010             ANDS     R0,R0,R2
   \   000000F4   0x4330             ORRS     R0,R6,R0
   \   000000F6   0xF040 0x0001      ORR      R0,R0,#0x1
   \   000000FA   0x8420             STRH     R0,[R4, #+32]
    706          
    707              /* Set the Input Capture Prescaler value */
    708              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   \   000000FC   0x88E9             LDRH     R1,[R5, #+6]
   \   000000FE   0x4620             MOV      R0,R4
   \   00000100   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   00000104   0x....             B.N      TIM_SetIC1Prescaler
    709            }
    710          }
    711          
    712          /*******************************************************************************
    713          * Function Name  : TIM_BDTRConfig
    714          * Description    : Configures the: Break feature, dead time, Lock level, the OSSI,
    715          *                  the OSSR State and the AOE(automatic output enable).
    716          * Input          :- TIMx: where x can be  1 or 8 to select the TIM 
    717          *                 - TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef
    718          *                    structure that contains the BDTR Register configuration
    719          *                    information for the TIM peripheral.
    720          * Output         : None
    721          * Return         : None
    722          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    723          void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
    724          {
    725            /* Check the parameters */
    726            assert_param(IS_TIM_18_PERIPH(TIMx));
    727            assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
    728            assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
    729            assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
    730            assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
    731            assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
    732            assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
    733          
    734            /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
    735               the OSSI State, the dead time value and the Automatic Output Enable Bit */
    736          
    737            TIMx->BDTR = (u32)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
    738                       TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
    739                       TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
    740                       TIM_BDTRInitStruct->TIM_AutomaticOutput;
   \                     TIM_BDTRConfig:
   \   00000000   0x880A             LDRH     R2,[R1, #+0]
   \   00000002   0x884B             LDRH     R3,[R1, #+2]
   \   00000004   0x431A             ORRS     R2,R3,R2
   \   00000006   0x888B             LDRH     R3,[R1, #+4]
   \   00000008   0x431A             ORRS     R2,R3,R2
   \   0000000A   0x88CB             LDRH     R3,[R1, #+6]
   \   0000000C   0x431A             ORRS     R2,R3,R2
   \   0000000E   0x890B             LDRH     R3,[R1, #+8]
   \   00000010   0x431A             ORRS     R2,R3,R2
   \   00000012   0x894B             LDRH     R3,[R1, #+10]
   \   00000014   0x431A             ORRS     R2,R3,R2
   \   00000016   0x8989             LDRH     R1,[R1, #+12]
   \   00000018   0x4311             ORRS     R1,R1,R2
   \   0000001A   0x....             B.N      ?Subroutine12
    741          
    742          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12:
   \   00000000   0xF8A0 0x1044      STRH     R1,[R0, #+68]
   \   00000004   0x4770             BX       LR               ;; return
    743          
    744          /*******************************************************************************
    745          * Function Name  : TIM_TimeBaseStructInit
    746          * Description    : Fills each TIM_TimeBaseInitStruct member with its default value.
    747          * Input          : - TIM_TimeBaseInitStruct : pointer to a TIM_TimeBaseInitTypeDef
    748          *                    structure which will be initialized.
    749          * Output         : None
    750          * Return         : None
    751          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    752          void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
    753          {
    754            /* Set the default configuration */
    755            TIM_TimeBaseInitStruct->TIM_Period = 0xFFFF;
   \                     TIM_TimeBaseStructInit:
   \   00000000   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000004   0x8081             STRH     R1,[R0, #+4]
    756            TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x8001             STRH     R1,[R0, #+0]
    757            TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
   \   0000000A   0x80C1             STRH     R1,[R0, #+6]
    758            TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
   \   0000000C   0x8041             STRH     R1,[R0, #+2]
    759            TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
   \   0000000E   0x7201             STRB     R1,[R0, #+8]
    760          }
   \   00000010   0x4770             BX       LR               ;; return
    761          
    762          /*******************************************************************************
    763          * Function Name  : TIM_OCStructInit
    764          * Description    : Fills each TIM_OCInitStruct member with its default value.
    765          * Input          : - TIM_OCInitStruct : pointer to a TIM_OCInitTypeDef structure
    766          *                    which will be initialized.
    767          * Output         : None
    768          * Return         : None
    769          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    770          void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
    771          {
    772            /* Set the default configuration */
    773            TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
   \                     TIM_OCStructInit:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    774            TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
   \   00000004   0x8041             STRH     R1,[R0, #+2]
    775            TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
   \   00000006   0x8081             STRH     R1,[R0, #+4]
    776            TIM_OCInitStruct->TIM_Pulse = 0x0000;
   \   00000008   0x80C1             STRH     R1,[R0, #+6]
    777            TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
   \   0000000A   0x8101             STRH     R1,[R0, #+8]
    778            TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
   \   0000000C   0x8141             STRH     R1,[R0, #+10]
    779            TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
   \   0000000E   0x8181             STRH     R1,[R0, #+12]
    780            TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
   \   00000010   0x81C1             STRH     R1,[R0, #+14]
    781          }
   \   00000012   0x4770             BX       LR               ;; return
    782          
    783          /*******************************************************************************
    784          * Function Name  : TIM_ICStructInit
    785          * Description    : Fills each TIM_ICInitStruct member with its default value.
    786          * Input          : - TIM_ICInitStruct : pointer to a TIM_ICInitTypeDef structure
    787          *                    which will be initialized.
    788          * Output         : None
    789          * Return         : None
    790          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    791          void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
    792          {
    793            /* Set the default configuration */
    794            TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
   \                     TIM_ICStructInit:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    795            TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
   \   00000004   0x8041             STRH     R1,[R0, #+2]
    796            TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x8081             STRH     R1,[R0, #+4]
    797            TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x80C1             STRH     R1,[R0, #+6]
    798            TIM_ICInitStruct->TIM_ICFilter = 0x00;
   \   0000000E   0x8101             STRH     R1,[R0, #+8]
    799          }
   \   00000010   0x4770             BX       LR               ;; return
    800          
    801          /*******************************************************************************
    802          * Function Name  : TIM_BDTRStructInit
    803          * Description    : Fills each TIM_BDTRInitStruct member with its default value.
    804          * Input          : - TIM_BDTRInitStruct : pointer to a TIM_BDTRInitTypeDef
    805          *                    structure which will be initialized.
    806          * Output         : None
    807          * Return         : None
    808          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    809          void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
    810          {
    811            /* Set the default configuration */
    812            TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
   \                     TIM_BDTRStructInit:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    813            TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
   \   00000004   0x8041             STRH     R1,[R0, #+2]
    814            TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
   \   00000006   0x8081             STRH     R1,[R0, #+4]
    815            TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
   \   00000008   0x80C1             STRH     R1,[R0, #+6]
    816            TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
   \   0000000A   0x8101             STRH     R1,[R0, #+8]
    817            TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
   \   0000000C   0x8141             STRH     R1,[R0, #+10]
    818            TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
   \   0000000E   0x8181             STRH     R1,[R0, #+12]
    819          }
   \   00000010   0x4770             BX       LR               ;; return
    820          
    821          /*******************************************************************************
    822          * Function Name  : TIM_Cmd
    823          * Description    : Enables or disables the specified TIM peripheral.
    824          * Input          : - TIMx: where x can be 1 to 8 to select the TIMx peripheral.
    825          *                  - NewState: new state of the TIMx peripheral.
    826          *                    This parameter can be: ENABLE or DISABLE.
    827          * Output         : None
    828          * Return         : None
    829          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    830          void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
    831          {
    832            /* Check the parameters */
    833            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    834            assert_param(IS_FUNCTIONAL_STATE(NewState));
    835            
    836            if (NewState != DISABLE)
   \                     TIM_Cmd:
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x8801             LDRH     R1,[R0, #+0]
   \   00000004   0xBF12             ITEE     NE 
   \   00000006   0xF041 0x0101      ORRNE    R1,R1,#0x1
   \   0000000A   0xF240 0x32FE      MOVWEQ   R2,#+1022
   \   0000000E   0x4011             ANDEQ    R1,R2,R1
    837            {
    838              /* Enable the TIM Counter */
    839              TIMx->CR1 |= CR1_CEN_Set;
    840            }
    841            else
    842            {
    843              /* Disable the TIM Counter */
    844              TIMx->CR1 &= CR1_CEN_Reset;
   \   00000010   0x8001             STRH     R1,[R0, #+0]
    845            }
    846          }
   \   00000012   0x4770             BX       LR               ;; return
    847          
    848          /*******************************************************************************
    849          * Function Name  : TIM_CtrlPWMOutputs
    850          * Description    : Enables or disables the TIM peripheral Main Outputs.
    851          * Input          :- TIMx: where x can be 1 or 8 to select the TIMx peripheral.
    852          *                 - NewState: new state of the TIM peripheral Main Outputs.
    853          *                    This parameter can be: ENABLE or DISABLE.
    854          * Output         : None
    855          * Return         : None
    856          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    857          void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
    858          {
    859            /* Check the parameters */
    860            assert_param(IS_TIM_18_PERIPH(TIMx));
    861            assert_param(IS_FUNCTIONAL_STATE(NewState));
    862          
    863            if (NewState != DISABLE)
   \                     TIM_CtrlPWMOutputs:
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0xF8B0 0x1044      LDRH     R1,[R0, #+68]
   \   00000006   0xBF12             ITEE     NE 
   \   00000008   0xF441 0x4100      ORRNE    R1,R1,#0x8000
   \   0000000C   0x0449             LSLEQ    R1,R1,#+17
   \   0000000E   0x0C49             LSREQ    R1,R1,#+17
    864            {
    865              /* Enable the TIM Main Output */
    866              TIMx->BDTR |= BDTR_MOE_Set;
    867            }
    868            else
    869            {
    870              /* Disable the TIM Main Output */
    871              TIMx->BDTR &= BDTR_MOE_Reset;
   \   00000010                      REQUIRE ?Subroutine12
   \   00000010                      ;; // Fall through to label ?Subroutine12
    872            }  
    873          }
    874          
    875          /*******************************************************************************
    876          * Function Name  : TIM_ITConfig
    877          * Description    : Enables or disables the specified TIM interrupts.
    878          * Input          : - TIMx: where x can be 1 to 8 to select the TIMx peripheral.
    879          *                  - TIM_IT: specifies the TIM interrupts sources to be enabled
    880          *                    or disabled.
    881          *                    This parameter can be any combination of the following values:
    882          *                       - TIM_IT_Update: TIM update Interrupt source
    883          *                       - TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
    884          *                       - TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
    885          *                       - TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
    886          *                       - TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
    887          *                       - TIM_IT_COM: TIM Commutation Interrupt source
    888          *                       - TIM_IT_Trigger: TIM Trigger Interrupt source
    889          *                       - TIM_IT_Break: TIM Break Interrupt source
    890          *                  - NewState: new state of the TIM interrupts.
    891          *                    This parameter can be: ENABLE or DISABLE.
    892          * Output         : None
    893          * Return         : None
    894          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    895          void TIM_ITConfig(TIM_TypeDef* TIMx, u16 TIM_IT, FunctionalState NewState)
    896          {  
    897            /* Check the parameters */
    898            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    899            assert_param(IS_TIM_IT(TIM_IT));
    900            assert_param(IS_TIM_PERIPH_IT((TIMx), (TIM_IT)));
    901            assert_param(IS_FUNCTIONAL_STATE(NewState));
    902            
    903            if (NewState != DISABLE)
   \                     TIM_ITConfig:
   \   00000000   0x2A00             CMP      R2,#+0
   \   00000002   0x8982             LDRH     R2,[R0, #+12]
   \   00000004   0xBF14             ITE      NE 
   \   00000006   0x4311             ORRNE    R1,R1,R2
   \   00000008   0xEA22 0x0101      BICEQ    R1,R2,R1
    904            {
    905              /* Enable the Interrupt sources */
    906              TIMx->DIER |= TIM_IT;
    907            }
    908            else
    909            {
    910              /* Disable the Interrupt sources */
    911              TIMx->DIER &= (u16)~TIM_IT;
   \   0000000C   0x8181             STRH     R1,[R0, #+12]
    912            }
    913          }
   \   0000000E   0x4770             BX       LR               ;; return
    914          
    915          /*******************************************************************************
    916          * Function Name  : TIM_GenerateEvent
    917          * Description    : Configures the TIMx event to be generate by software.
    918          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
    919          *                  - TIM_EventSource: specifies the event source.
    920          *                    This parameter can be one or more of the following values:	   
    921          *                       - TIM_EventSource_Update: Timer update Event source
    922          *                       - TIM_EventSource_CC1: Timer Capture Compare 1 Event source
    923          *                       - TIM_EventSource_CC2: Timer Capture Compare 2 Event source
    924          *                       - TIM_EventSource_CC3: Timer Capture Compare 3 Event source
    925          *                       - TIM_EventSource_CC4: Timer Capture Compare 4 Event source
    926          *                       - TIM_EventSource_Trigger: Timer Trigger Event source
    927          * Output         : None
    928          * Return         : None
    929          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    930          void TIM_GenerateEvent(TIM_TypeDef* TIMx, u16 TIM_EventSource)
    931          { 
    932            /* Check the parameters */
    933            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    934            assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
    935            assert_param(IS_TIM_PERIPH_EVENT((TIMx), (TIM_EventSource)));
    936          
    937            /* Set the event sources */
    938            TIMx->EGR = TIM_EventSource;
   \                     TIM_GenerateEvent:
   \   00000000   0x8281             STRH     R1,[R0, #+20]
    939          }
   \   00000002   0x4770             BX       LR               ;; return
    940          
    941          /*******************************************************************************
    942          * Function Name  : TIM_DMAConfig
    943          * Description    : Configures the TIMxs DMA interface.
    944          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
    945          *                    peripheral.
    946          *                  - TIM_DMABase: DMA Base address.
    947          *                    This parameter can be one of the following values:
    948          *                       - TIM_DMABase_CR, TIM_DMABase_CR2, TIM_DMABase_SMCR,
    949          *                         TIM_DMABase_DIER, TIM1_DMABase_SR, TIM_DMABase_EGR,
    950          *                         TIM_DMABase_CCMR1, TIM_DMABase_CCMR2, TIM_DMABase_CCER,
    951          *                         TIM_DMABase_CNT, TIM_DMABase_PSC, TIM_DMABase_ARR,
    952          *                         TIM_DMABase_RCR, TIM_DMABase_CCR1, TIM_DMABase_CCR2,
    953          *                         TIM_DMABase_CCR3, TIM_DMABase_CCR4, TIM_DMABase_BDTR,
    954          *                         TIM_DMABase_DCR.
    955          *                   - TIM_DMABurstLength: DMA Burst length.
    956          *                     This parameter can be one value between:
    957          *                     TIM_DMABurstLength_1Byte and TIM_DMABurstLength_18Bytes.
    958          * Output         : None
    959          * Return         : None
    960          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    961          void TIM_DMAConfig(TIM_TypeDef* TIMx, u16 TIM_DMABase, u16 TIM_DMABurstLength)
    962          {
    963            /* Check the parameters */
    964            assert_param(IS_TIM_123458_PERIPH(TIMx));
    965            assert_param(IS_TIM_DMA_BASE(TIM_DMABase));
    966            assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
    967          
    968            /* Set the DMA Base and the DMA Burst Length */
    969            TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
   \                     TIM_DMAConfig:
   \   00000000   0x4311             ORRS     R1,R2,R1
   \   00000002   0xF8A0 0x1048      STRH     R1,[R0, #+72]
    970          }
   \   00000006   0x4770             BX       LR               ;; return
    971          
    972          /*******************************************************************************
    973          * Function Name  : TIM_DMACmd
    974          * Description    : Enables or disables the TIMxs DMA Requests.
    975          * Input          : - TIMx: where x can be  1 to 8 to select the TIM peripheral. 
    976          *                  - TIM_DMASources: specifies the DMA Request sources.
    977          *                    This parameter can be any combination of the following values:
    978          *                       - TIM_DMA_Update: TIM update Interrupt source
    979          *                       - TIM_DMA_CC1: TIM Capture Compare 1 DMA source
    980          *                       - TIM_DMA_CC2: TIM Capture Compare 2 DMA source
    981          *                       - TIM_DMA_CC3: TIM Capture Compare 3 DMA source
    982          *                       - TIM_DMA_CC4: TIM Capture Compare 4 DMA source
    983          *                       - TIM_DMA_COM: TIM Commutation DMA source
    984          *                       - TIM_DMA_Trigger: TIM Trigger DMA source
    985          *                  - NewState: new state of the DMA Request sources.
    986          *                    This parameter can be: ENABLE or DISABLE.
    987          * Output         : None
    988          * Return         : None
    989          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    990          void TIM_DMACmd(TIM_TypeDef* TIMx, u16 TIM_DMASource, FunctionalState NewState)
    991          { 
    992            /* Check the parameters */
    993            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    994            assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
    995            assert_param(IS_TIM_PERIPH_DMA(TIMx, TIM_DMASource));
    996            assert_param(IS_FUNCTIONAL_STATE(NewState));
    997            
    998            if (NewState != DISABLE)
   \                     TIM_DMACmd:
   \   00000000   0x2A00             CMP      R2,#+0
   \   00000002   0x8982             LDRH     R2,[R0, #+12]
   \   00000004   0xBF14             ITE      NE 
   \   00000006   0x4311             ORRNE    R1,R1,R2
   \   00000008   0xEA22 0x0101      BICEQ    R1,R2,R1
    999            {
   1000              /* Enable the DMA sources */
   1001              TIMx->DIER |= TIM_DMASource; 
   1002            }
   1003            else
   1004            {
   1005              /* Disable the DMA sources */
   1006              TIMx->DIER &= (u16)~TIM_DMASource;
   \   0000000C   0x8181             STRH     R1,[R0, #+12]
   1007            }
   1008          }
   \   0000000E   0x4770             BX       LR               ;; return
   1009          
   1010          /*******************************************************************************
   1011          * Function Name  : TIM_InternalClockConfig
   1012          * Description    : Configures the TIMx interrnal Clock
   1013          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1014          *                    peripheral.
   1015          * Output         : None
   1016          * Return         : None
   1017          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1018          void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
   1019          {
   1020            /* Check the parameters */
   1021            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1022          
   1023            /* Disable slave mode to clock the prescaler directly with the internal clock */
   1024            TIMx->SMCR &=  SMCR_SMS_Mask;
   \                     TIM_InternalClockConfig:
   \   00000000   0x8901             LDRH     R1,[R0, #+8]
   \   00000002   0xF64F 0x72F8      MOVW     R2,#+65528
   \   00000006   0x4011             ANDS     R1,R2,R1
   \   00000008   0x8101             STRH     R1,[R0, #+8]
   1025          }
   \   0000000A   0x4770             BX       LR               ;; return
   1026          /*******************************************************************************
   1027          * Function Name  : TIM_ITRxExternalClockConfig
   1028          * Description    : Configures the TIMx Internal Trigger as External Clock
   1029          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1030          *                    peripheral.
   1031          *                  - TIM_ITRSource: Trigger source.
   1032          *                    This parameter can be one of the following values:
   1033          *                       - TIM_TS_ITR0: Internal Trigger 0
   1034          *                       - TIM_TS_ITR1: Internal Trigger 1
   1035          *                       - TIM_TS_ITR2: Internal Trigger 2
   1036          *                       - TIM_TS_ITR3: Internal Trigger 3
   1037          * Output         : None
   1038          * Return         : None
   1039          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1040          void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource)
   1041          {
   1042            /* Check the parameters */
   1043            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1044            assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
   1045          
   1046            /* Select the Internal Trigger */
   1047            TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
   \                     TIM_ITRxExternalClockConfig:
   \   00000000   0x8902             LDRH     R2,[R0, #+8]
   \   00000002   0xF64F 0x738F      MOVW     R3,#+65423
   \   00000006   0x401A             ANDS     R2,R3,R2
   \   00000008   0x4311             ORRS     R1,R1,R2
   \   0000000A   0x8101             STRH     R1,[R0, #+8]
   1048          
   1049            /* Select the External clock mode1 */
   1050            TIMx->SMCR |= TIM_SlaveMode_External1;
   \   0000000C   0x8901             LDRH     R1,[R0, #+8]
   \   0000000E   0xF041 0x0107      ORR      R1,R1,#0x7
   \   00000012   0x8101             STRH     R1,[R0, #+8]
   1051          }
   \   00000014   0x4770             BX       LR               ;; return
   1052          /*******************************************************************************
   1053          * Function Name  : TIM_TIxExternalClockConfig
   1054          * Description    : Configures the TIMx Trigger as External Clock
   1055          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1056          *                    peripheral.
   1057          *                  - TIM_TIxExternalCLKSource: Trigger source.
   1058          *                    This parameter can be one of the following values:
   1059          *                       - TIM_TIxExternalCLK1Source_TI1ED: TI1 Edge Detector
   1060          *                       - TIM_TIxExternalCLK1Source_TI1: Filtered Timer Input 1
   1061          *                       - TIM_TIxExternalCLK1Source_TI2: Filtered Timer Input 2
   1062          *                  - TIM_ICPolarity: specifies the TIx Polarity.
   1063          *                    This parameter can be:
   1064          *                       - TIM_ICPolarity_Rising
   1065          *                       - TIM_ICPolarity_Falling
   1066          *                   - ICFilter : specifies the filter value.
   1067          *                     This parameter must be a value between 0x0 and 0xF.
   1068          * Output         : None
   1069          * Return         : None
   1070          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1071          void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_TIxExternalCLKSource,
   1072                                          u16 TIM_ICPolarity, u16 ICFilter)
   1073          {
   \                     TIM_TIxExternalClockConfig:
   \   00000000   0xB470             PUSH     {R4-R6}
   1074            /* Check the parameters */
   1075            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1076            assert_param(IS_TIM_TIXCLK_SOURCE(TIM_TIxExternalCLKSource));
   1077            assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
   1078            assert_param(IS_TIM_IC_FILTER(ICFilter));
   1079          
   1080            /* Configure the Timer Input Clock Source */
   1081            if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
   \   00000002   0x2960             CMP      R1,#+96
   \   00000004   0x8C04             LDRH     R4,[R0, #+32]
   \   00000006   0xD115             BNE.N    ??TIM_TIxExternalClockConfig_0
   1082            {
   1083              TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
   \   00000008   0xF64F 0x75EF      MOVW     R5,#+65519
   \   0000000C   0x402C             ANDS     R4,R5,R4
   \   0000000E   0x8404             STRH     R4,[R0, #+32]
   \   00000010   0x8B04             LDRH     R4,[R0, #+24]
   \   00000012   0x8C05             LDRH     R5,[R0, #+32]
   \   00000014   0xF640 0x46FF      MOVW     R6,#+3327
   \   00000018   0x4034             ANDS     R4,R6,R4
   \   0000001A   0xEA44 0x3303      ORR      R3,R4,R3, LSL #+12
   \   0000001E   0xF443 0x7380      ORR      R3,R3,#0x100
   \   00000022   0x8303             STRH     R3,[R0, #+24]
   \   00000024   0xF64F 0x73DF      MOVW     R3,#+65503
   \   00000028   0x402B             ANDS     R3,R3,R5
   \   0000002A   0xEA43 0x1202      ORR      R2,R3,R2, LSL #+4
   \   0000002E   0xF042 0x0210      ORR      R2,R2,#0x10
   \   00000032   0xE013             B.N      ??TIM_TIxExternalClockConfig_1
   1084            }
   1085            else
   1086            {
   1087              TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
   \                     ??TIM_TIxExternalClockConfig_0:
   \   00000034   0xF64F 0x75FE      MOVW     R5,#+65534
   \   00000038   0x402C             ANDS     R4,R5,R4
   \   0000003A   0x8404             STRH     R4,[R0, #+32]
   \   0000003C   0x8B04             LDRH     R4,[R0, #+24]
   \   0000003E   0x8C05             LDRH     R5,[R0, #+32]
   \   00000040   0xF64F 0x760C      MOVW     R6,#+65292
   \   00000044   0x4034             ANDS     R4,R6,R4
   \   00000046   0xEA44 0x1303      ORR      R3,R4,R3, LSL #+4
   \   0000004A   0xF043 0x0301      ORR      R3,R3,#0x1
   \   0000004E   0x8303             STRH     R3,[R0, #+24]
   \   00000050   0xF64F 0x73FD      MOVW     R3,#+65533
   \   00000054   0x402B             ANDS     R3,R3,R5
   \   00000056   0x431A             ORRS     R2,R2,R3
   \   00000058   0xF042 0x0201      ORR      R2,R2,#0x1
   \                     ??TIM_TIxExternalClockConfig_1:
   \   0000005C   0x8402             STRH     R2,[R0, #+32]
   1088            }
   1089          
   1090            /* Select the Trigger source */
   1091            TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
   \   0000005E   0x8902             LDRH     R2,[R0, #+8]
   \   00000060   0xF64F 0x738F      MOVW     R3,#+65423
   \   00000064   0x401A             ANDS     R2,R3,R2
   \   00000066   0x4311             ORRS     R1,R1,R2
   \   00000068   0x8101             STRH     R1,[R0, #+8]
   1092          
   1093            /* Select the External clock mode1 */
   1094            TIMx->SMCR |= TIM_SlaveMode_External1;
   \   0000006A   0x8901             LDRH     R1,[R0, #+8]
   \   0000006C   0xF041 0x0107      ORR      R1,R1,#0x7
   \   00000070   0x8101             STRH     R1,[R0, #+8]
   1095          }
   \   00000072   0xBC70             POP      {R4-R6}
   \   00000074   0x4770             BX       LR               ;; return
   1096          
   1097          /*******************************************************************************
   1098          * Function Name  : TIM_ETRClockMode1Config
   1099          * Description    : Configures the External clock Mode1
   1100          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1101          *                    peripheral.
   1102          *                  - TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   1103          *                    It can be one of the following values:
   1104          *                       - TIM_ExtTRGPSC_OFF
   1105          *                       - TIM_ExtTRGPSC_DIV2
   1106          *                       - TIM_ExtTRGPSC_DIV4
   1107          *                       - TIM_ExtTRGPSC_DIV8.
   1108          *                  - TIM_ExtTRGPolarity: The external Trigger Polarity.
   1109          *                    It can be one of the following values:
   1110          *                       - TIM_ExtTRGPolarity_Inverted
   1111          *                       - TIM_ExtTRGPolarity_NonInverted
   1112          *                  - ExtTRGFilter: External Trigger Filter.
   1113          *                    This parameter must be a value between 0x00 and 0x0F
   1114          * Output         : None
   1115          * Return         : None
   1116          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1117          void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
   1118                                       u16 ExtTRGFilter)
   1119          {
   1120            u16 tmpsmcr = 0;
   1121          
   1122            /* Check the parameters */
   1123            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1124            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   1125            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   1126            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   1127          
   1128            /* Configure the ETR Clock source */
   1129            TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
   \                     TIM_ETRClockMode1Config:
   \   00000000   0xF8B0 0xC008      LDRH     R12,[R0, #+8]
   \   00000004   0xFA5F 0xFC8C      UXTB     R12,R12
   \   00000008   0xEA41 0x010C      ORR      R1,R1,R12
   \   0000000C   0x4311             ORRS     R1,R2,R1
   \   0000000E   0xEA41 0x2103      ORR      R1,R1,R3, LSL #+8
   \   00000012   0x8101             STRH     R1,[R0, #+8]
   1130            
   1131            /* Get the TIMx SMCR register value */
   1132            tmpsmcr = TIMx->SMCR;
   1133          
   1134            /* Reset the SMS Bits */
   1135            tmpsmcr &= SMCR_SMS_Mask;
   1136            /* Select the External clock mode1 */
   1137            tmpsmcr |= TIM_SlaveMode_External1;
   1138          
   1139            /* Select the Trigger selection : ETRF */
   1140            tmpsmcr &= SMCR_TS_Mask;
   1141            tmpsmcr |= TIM_TS_ETRF;
   1142          
   1143            /* Write to TIMx SMCR */
   1144            TIMx->SMCR = tmpsmcr;
   \   00000014   0x8901             LDRH     R1,[R0, #+8]
   \   00000016   0xF041 0x0177      ORR      R1,R1,#0x77
   \   0000001A   0x8101             STRH     R1,[R0, #+8]
   1145          }
   \   0000001C   0x4770             BX       LR               ;; return
   1146          
   1147          /*******************************************************************************
   1148          * Function Name  : TIM_ETRClockMode2Config
   1149          * Description    : Configures the External clock Mode2
   1150          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1151          *                    peripheral.
   1152          *                  - TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   1153          *                    It can be one of the following values:
   1154          *                       - TIM_ExtTRGPSC_OFF
   1155          *                       - TIM_ExtTRGPSC_DIV2
   1156          *                       - TIM_ExtTRGPSC_DIV4
   1157          *                       - TIM_ExtTRGPSC_DIV8
   1158          *                  - TIM_ExtTRGPolarity: The external Trigger Polarity.
   1159          *                    It can be one of the following values:
   1160          *                       - TIM_ExtTRGPolarity_Inverted
   1161          *                       - TIM_ExtTRGPolarity_NonInverted
   1162          *                  - ExtTRGFilter: External Trigger Filter.
   1163          *                    This parameter must be a value between 0x00 and 0x0F
   1164          * Output         : None
   1165          * Return         : None
   1166          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1167          void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, 
   1168                                       u16 TIM_ExtTRGPolarity, u16 ExtTRGFilter)
   1169          {
   1170            /* Check the parameters */
   1171            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1172            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   1173            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   1174            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   1175          
   1176            /* Configure the ETR Clock source */
   1177            TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
   \                     TIM_ETRClockMode2Config:
   \   00000000   0xF8B0 0xC008      LDRH     R12,[R0, #+8]
   \   00000004   0xFA5F 0xFC8C      UXTB     R12,R12
   \   00000008   0xEA41 0x010C      ORR      R1,R1,R12
   \   0000000C   0x4311             ORRS     R1,R2,R1
   \   0000000E   0xEA41 0x2103      ORR      R1,R1,R3, LSL #+8
   \   00000012   0x8101             STRH     R1,[R0, #+8]
   1178          
   1179            /* Enable the External clock mode2 */
   1180            TIMx->SMCR |= SMCR_ECE_Set;
   \   00000014   0x8901             LDRH     R1,[R0, #+8]
   \   00000016   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   0000001A   0x8101             STRH     R1,[R0, #+8]
   1181          }
   \   0000001C   0x4770             BX       LR               ;; return
   1182          
   1183          /*******************************************************************************
   1184          * Function Name  : TIM_ETRConfig
   1185          * Description    : Configures the TIMx External Trigger (ETR).
   1186          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1187          *                    peripheral.
   1188          *                  - TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   1189          *                    This parameter can be one of the following values:
   1190          *                       - TIM_ExtTRGPSC_OFF
   1191          *                       - TIM_ExtTRGPSC_DIV2
   1192          *                       - TIM_ExtTRGPSC_DIV4
   1193          *                       - TIM_ExtTRGPSC_DIV8
   1194          *                  - TIM_ExtTRGPolarity: The external Trigger Polarity.
   1195          *                    This parameter can be one of the following values:
   1196          *                       - TIM_ExtTRGPolarity_Inverted
   1197          *                       - TIM_ExtTRGPolarity_NonInverted
   1198          *                  - ExtTRGFilter: External Trigger Filter.
   1199          *                    This parameter must be a value between 0x00 and 0x0F.
   1200          * Output         : None
   1201          * Return         : None
   1202          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1203          void TIM_ETRConfig(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
   1204                             u16 ExtTRGFilter)
   1205          {
   1206            u16 tmpsmcr = 0;
   1207          
   1208            /* Check the parameters */
   1209            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1210            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   1211            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   1212            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   1213          
   1214            tmpsmcr = TIMx->SMCR;
   1215          
   1216            /* Reset the ETR Bits */
   1217            tmpsmcr &= SMCR_ETR_Mask;
   1218          
   1219            /* Set the Prescaler, the Filter value and the Polarity */
   1220            tmpsmcr |= TIM_ExtTRGPrescaler | TIM_ExtTRGPolarity | (u16)(ExtTRGFilter << 8);
   1221          
   1222            /* Write to TIMx SMCR */
   1223            TIMx->SMCR = tmpsmcr;
   \                     TIM_ETRConfig:
   \   00000000   0xF8B0 0xC008      LDRH     R12,[R0, #+8]
   \   00000004   0xFA5F 0xFC8C      UXTB     R12,R12
   \   00000008   0xEA41 0x010C      ORR      R1,R1,R12
   \   0000000C   0x4311             ORRS     R1,R2,R1
   \   0000000E   0xEA41 0x2103      ORR      R1,R1,R3, LSL #+8
   \   00000012   0x8101             STRH     R1,[R0, #+8]
   1224          }
   \   00000014   0x4770             BX       LR               ;; return
   1225          
   1226          /*******************************************************************************
   1227          * Function Name  : TIM_PrescalerConfig
   1228          * Description    : Configures the TIMx Prescaler.
   1229          * Input          : - TIMx: where x can be  1 to 8 to select the TIM peripheral.
   1230          *                  - Prescaler: specifies the Prescaler Register value
   1231          *                  - TIM_PSCReloadMode: specifies the TIM Prescaler Reload mode
   1232          *                    This parameter can be one of the following values:
   1233          *                       - TIM_PSCReloadMode_Update: The Prescaler is loaded at
   1234          *                         the update event.
   1235          *                       - TIM_PSCReloadMode_Immediate: The Prescaler is loaded
   1236          *                         immediatly.
   1237          * Output         : None
   1238          * Return         : None
   1239          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1240          void TIM_PrescalerConfig(TIM_TypeDef* TIMx, u16 Prescaler, u16 TIM_PSCReloadMode)
   1241          {
   1242            /* Check the parameters */
   1243            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1244            assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
   1245          
   1246            /* Set the Prescaler value */
   1247            TIMx->PSC = Prescaler;
   \                     TIM_PrescalerConfig:
   \   00000000   0x8501             STRH     R1,[R0, #+40]
   1248          
   1249            /* Set or reset the UG Bit */
   1250            TIMx->EGR = TIM_PSCReloadMode;
   \   00000002   0x8282             STRH     R2,[R0, #+20]
   1251          }
   \   00000004   0x4770             BX       LR               ;; return
   1252          
   1253          /*******************************************************************************
   1254          * Function Name  : TIM_CounterModeConfig
   1255          * Description    : Specifies the TIMx Counter Mode to be used.
   1256          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1257          *                    peripheral.
   1258          *                  - TIM_CounterMode: specifies the Counter Mode to be used
   1259          *                    This parameter can be one of the following values:
   1260          *                       - TIM_CounterMode_Up: TIM Up Counting Mode
   1261          *                       - TIM_CounterMode_Down: TIM Down Counting Mode
   1262          *                       - TIM_CounterMode_CenterAligned1: TIM Center Aligned Mode1
   1263          *                       - TIM_CounterMode_CenterAligned2: TIM Center Aligned Mode2
   1264          *                       - TIM_CounterMode_CenterAligned3: TIM Center Aligned Mode3
   1265          * Output         : None
   1266          * Return         : None
   1267          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1268          void TIM_CounterModeConfig(TIM_TypeDef* TIMx, u16 TIM_CounterMode)
   1269          {
   1270            u16 tmpcr1 = 0;
   1271          
   1272            /* Check the parameters */
   1273            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1274            assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
   1275          
   1276            tmpcr1 = TIMx->CR1;
   1277          
   1278            /* Reset the CMS and DIR Bits */
   1279            tmpcr1 &= CR1_CounterMode_Mask;
   1280          
   1281            /* Set the Counter Mode */
   1282            tmpcr1 |= TIM_CounterMode;
   1283          
   1284            /* Write to TIMx CR1 register */
   1285            TIMx->CR1 = tmpcr1;
   \                     TIM_CounterModeConfig:
   \   00000000   0x8802             LDRH     R2,[R0, #+0]
   \   00000002   0xF240 0x338F      MOVW     R3,#+911
   \   00000006   0x401A             ANDS     R2,R3,R2
   \   00000008   0x....             B.N      ??Subroutine3_0
   1286          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3:
   \   00000000   0x8002             STRH     R2,[R0, #+0]
   \   00000002   0x8802             LDRH     R2,[R0, #+0]
   \                     ??Subroutine3_0:
   \   00000004   0x4311             ORRS     R1,R1,R2
   \   00000006   0x8001             STRH     R1,[R0, #+0]
   \   00000008   0x4770             BX       LR               ;; return
   1287          
   1288          /*******************************************************************************
   1289          * Function Name  : TIM_SelectInputTrigger
   1290          * Description    : Selects the Input Trigger source
   1291          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1292          *                    peripheral.
   1293          *                  - TIM_InputTriggerSource: The Input Trigger source.
   1294          *                    This parameter can be one of the following values:
   1295          *                       - TIM_TS_ITR0: Internal Trigger 0
   1296          *                       - TIM_TS_ITR1: Internal Trigger 1
   1297          *                       - TIM_TS_ITR2: Internal Trigger 2
   1298          *                       - TIM_TS_ITR3: Internal Trigger 3
   1299          *                       - TIM_TS_TI1F_ED: TI1 Edge Detector
   1300          *                       - TIM_TS_TI1FP1: Filtered Timer Input 1
   1301          *                       - TIM_TS_TI2FP2: Filtered Timer Input 2
   1302          *                       - TIM_TS_ETRF: External Trigger input
   1303          * Output         : None
   1304          * Return         : None
   1305          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1306          void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource)
   1307          {
   1308            u16 tmpsmcr = 0;
   1309          
   1310            /* Check the parameters */
   1311            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1312            assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
   1313          
   1314            /* Get the TIMx SMCR register value */
   1315            tmpsmcr = TIMx->SMCR;
   1316          
   1317            /* Reset the TS Bits */
   1318            tmpsmcr &= SMCR_TS_Mask;
   1319          
   1320            /* Set the Input Trigger source */
   1321            tmpsmcr |= TIM_InputTriggerSource;
   1322          
   1323            /* Write to TIMx SMCR */
   1324            TIMx->SMCR = tmpsmcr;
   \                     TIM_SelectInputTrigger:
   \   00000000   0x8902             LDRH     R2,[R0, #+8]
   \   00000002   0xF64F 0x738F      MOVW     R3,#+65423
   \   00000006   0x401A             ANDS     R2,R3,R2
   \   00000008   0x....             B.N      ??Subroutine1_0
   1325          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0x401A             ANDS     R2,R3,R2
   \   00000002   0x8102             STRH     R2,[R0, #+8]
   \   00000004   0x8902             LDRH     R2,[R0, #+8]
   \                     ??Subroutine1_0:
   \   00000006   0x4311             ORRS     R1,R1,R2
   \   00000008   0x8101             STRH     R1,[R0, #+8]
   \   0000000A   0x4770             BX       LR               ;; return
   1326          
   1327          /*******************************************************************************
   1328          * Function Name  : TIM_EncoderInterfaceConfig
   1329          * Description    : Configures the TIMx Encoder Interface.
   1330          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1331          *                    peripheral.
   1332          *                  - TIM_EncoderMode: specifies the TIMx Encoder Mode.
   1333          *                    This parameter can be one of the following values:
   1334          *                       - TIM_EncoderMode_TI1: Counter counts on TI1FP1 edge
   1335          *                         depending on TI2FP2 level.
   1336          *                       - TIM_EncoderMode_TI2: Counter counts on TI2FP2 edge
   1337          *                         depending on TI1FP1 level.
   1338          *                       - TIM_EncoderMode_TI12: Counter counts on both TI1FP1 and
   1339          *                         TI2FP2 edges depending on the level of the other input.
   1340          *                  - TIM_IC1Polarity: specifies the IC1 Polarity
   1341          *                    This parmeter can be one of the following values:
   1342          *                        - TIM_ICPolarity_Falling: IC Falling edge.
   1343          *                        - TIM_ICPolarity_Rising: IC Rising edge.
   1344          *                  - TIM_IC2Polarity: specifies the IC2 Polarity
   1345          *                    This parmeter can be one of the following values:
   1346          *                        - TIM_ICPolarity_Falling: IC Falling edge.
   1347          *                        - TIM_ICPolarity_Rising: IC Rising edge.
   1348          * Output         : None
   1349          * Return         : None
   1350          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1351          void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, u16 TIM_EncoderMode,
   1352                                          u16 TIM_IC1Polarity, u16 TIM_IC2Polarity)
   1353          {
   \                     TIM_EncoderInterfaceConfig:
   \   00000000   0xB4F0             PUSH     {R4-R7}
   1354            u16 tmpsmcr = 0;
   1355            u16 tmpccmr1 = 0;
   1356            u16 tmpccer = 0;
   1357              
   1358            /* Check the parameters */
   1359            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1360            assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
   1361            assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
   1362            assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
   1363          
   1364            /* Get the TIMx SMCR register value */
   1365            tmpsmcr = TIMx->SMCR;
   \   00000002   0x8905             LDRH     R5,[R0, #+8]
   1366          
   1367            /* Get the TIMx CCMR1 register value */
   1368            tmpccmr1 = TIMx->CCMR1;
   \   00000004   0x8B06             LDRH     R6,[R0, #+24]
   1369          
   1370            /* Get the TIMx CCER register value */
   1371            tmpccer = TIMx->CCER;
   \   00000006   0x8C04             LDRH     R4,[R0, #+32]
   1372          
   1373            /* Set the encoder Mode */
   1374            tmpsmcr &= SMCR_SMS_Mask;
   1375            tmpsmcr |= TIM_EncoderMode;
   1376          
   1377            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   1378            tmpccmr1 &= CCMR_CC13S_Mask & CCMR_CC24S_Mask;
   1379            tmpccmr1 |= CCMR_TI13Direct_Set | CCMR_TI24Direct_Set;
   1380          
   1381            /* Set the TI1 and the TI2 Polarities */
   1382            tmpccer &= CCER_CC1P_Reset & CCER_CC2P_Reset;
   1383            tmpccer |= (TIM_IC1Polarity | (u16)(TIM_IC2Polarity << 4));
   1384          
   1385            /* Write to TIMx SMCR */
   1386            TIMx->SMCR = tmpsmcr;
   \   00000008   0xF64F 0x77F8      MOVW     R7,#+65528
   \   0000000C   0x403D             ANDS     R5,R7,R5
   \   0000000E   0x4329             ORRS     R1,R1,R5
   \   00000010   0x8101             STRH     R1,[R0, #+8]
   1387          
   1388            /* Write to TIMx CCMR1 */
   1389            TIMx->CCMR1 = tmpccmr1;
   \   00000012   0xF64F 0x41FC      MOVW     R1,#+64764
   \   00000016   0x4031             ANDS     R1,R1,R6
   \   00000018   0xF240 0x1501      MOVW     R5,#+257
   \   0000001C   0x4329             ORRS     R1,R5,R1
   \   0000001E   0x8301             STRH     R1,[R0, #+24]
   1390          
   1391            /* Write to TIMx CCER */
   1392            TIMx->CCER = tmpccer;
   \   00000020   0xF64F 0x71DD      MOVW     R1,#+65501
   \   00000024   0x4021             ANDS     R1,R1,R4
   \   00000026   0x4311             ORRS     R1,R2,R1
   \   00000028   0xEA41 0x1103      ORR      R1,R1,R3, LSL #+4
   \   0000002C   0x8401             STRH     R1,[R0, #+32]
   1393          }
   \   0000002E   0xBCF0             POP      {R4-R7}
   \   00000030   0x4770             BX       LR               ;; return
   1394          
   1395          /*******************************************************************************
   1396          * Function Name  : TIM_ForcedOC1Config
   1397          * Description    : Forces the TIMx output 1 waveform to active or inactive level.
   1398          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1399          *                    peripheral.
   1400          *                  - TIM_ForcedAction: specifies the forced Action to be set to
   1401          *                    the output waveform.
   1402          *                    This parameter can be one of the following values:
   1403          *                       - TIM_ForcedAction_Active: Force active level on OC1REF
   1404          *                       - TIM_ForcedAction_InActive: Force inactive level on
   1405          *                         OC1REF.
   1406          * Output         : None
   1407          * Return         : None
   1408          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1409          void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
   1410          {
   1411            u16 tmpccmr1 = 0;
   1412          
   1413            /* Check the parameters */
   1414            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1415            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1416          
   1417            tmpccmr1 = TIMx->CCMR1;
   1418          
   1419            /* Reset the OC1M Bits */
   1420            tmpccmr1 &= CCMR_OC13M_Mask;
   1421          
   1422            /* Configure The Forced output Mode */
   1423            tmpccmr1 |= TIM_ForcedAction;
   1424          
   1425            /* Write to TIMx CCMR1 register */
   1426            TIMx->CCMR1 = tmpccmr1;
   \                     TIM_ForcedOC1Config:
   \   00000000   0x8B02             LDRH     R2,[R0, #+24]
   \   00000002   0xF64F 0x738F      MOVW     R3,#+65423
   \   00000006   0x....             B.N      ?Subroutine8
   1427          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8:
   \   00000000   0x401A             ANDS     R2,R3,R2
   \                     ??Subroutine8_0:
   \   00000002   0x4311             ORRS     R1,R1,R2
   \   00000004   0x8301             STRH     R1,[R0, #+24]
   \   00000006   0x4770             BX       LR               ;; return
   1428          
   1429          /*******************************************************************************
   1430          * Function Name  : TIM_ForcedOC2Config
   1431          * Description    : Forces the TIMx output 2 waveform to active or inactive level.
   1432          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1433          *                    peripheral.
   1434          *                  - TIM_ForcedAction: specifies the forced Action to be set to
   1435          *                    the output waveform.
   1436          *                    This parameter can be one of the following values:
   1437          *                       - TIM_ForcedAction_Active: Force active level on OC2REF
   1438          *                       - TIM_ForcedAction_InActive: Force inactive level on
   1439          *                         OC2REF.
   1440          * Output         : None
   1441          * Return         : None
   1442          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1443          void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
   1444          {
   1445            u16 tmpccmr1 = 0;
   1446          
   1447            /* Check the parameters */
   1448            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1449            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1450          
   1451            tmpccmr1 = TIMx->CCMR1;
   1452          
   1453            /* Reset the OC2M Bits */
   1454            tmpccmr1 &= CCMR_OC24M_Mask;
   1455          
   1456            /* Configure The Forced output Mode */
   1457            tmpccmr1 |= (u16)(TIM_ForcedAction << 8);
   1458          
   1459            /* Write to TIMx CCMR1 register */
   1460            TIMx->CCMR1 = tmpccmr1;
   \                     TIM_ForcedOC2Config:
   \   00000000   0x8B02             LDRH     R2,[R0, #+24]
   \   00000002   0xF648 0x73FF      MOVW     R3,#+36863
   \   00000006   0x....             B.N      ?Subroutine4
   1461          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4:
   \   00000000   0x401A             ANDS     R2,R3,R2
   \                     ??Subroutine4_0:
   \   00000002   0xEA42 0x2101      ORR      R1,R2,R1, LSL #+8
   \   00000006   0x8301             STRH     R1,[R0, #+24]
   \   00000008   0x4770             BX       LR               ;; return
   1462          
   1463          /*******************************************************************************
   1464          * Function Name  : TIM_ForcedOC3Config
   1465          * Description    : Forces the TIMx output 3 waveform to active or inactive level.
   1466          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1467          *                    peripheral.
   1468          *                  - TIM_ForcedAction: specifies the forced Action to be set to
   1469          *                    the output waveform.
   1470          *                    This parameter can be one of the following values:
   1471          *                       - TIM_ForcedAction_Active: Force active level on OC3REF
   1472          *                       - TIM_ForcedAction_InActive: Force inactive level on
   1473          *                         OC3REF.
   1474          * Output         : None
   1475          * Return         : None
   1476          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1477          void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
   1478          {
   1479            u16 tmpccmr2 = 0;
   1480          
   1481            /* Check the parameters */
   1482            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1483            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1484          
   1485            tmpccmr2 = TIMx->CCMR2;
   1486          
   1487            /* Reset the OC1M Bits */
   1488            tmpccmr2 &= CCMR_OC13M_Mask;
   1489          
   1490            /* Configure The Forced output Mode */
   1491            tmpccmr2 |= TIM_ForcedAction;
   1492          
   1493            /* Write to TIMx CCMR2 register */
   1494            TIMx->CCMR2 = tmpccmr2;
   \                     TIM_ForcedOC3Config:
   \   00000000   0x8B82             LDRH     R2,[R0, #+28]
   \   00000002   0xF64F 0x738F      MOVW     R3,#+65423
   \   00000006   0x....             B.N      ?Subroutine9
   1495          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9:
   \   00000000   0x401A             ANDS     R2,R3,R2
   \                     ??Subroutine9_0:
   \   00000002   0x4311             ORRS     R1,R1,R2
   \   00000004   0x8381             STRH     R1,[R0, #+28]
   \   00000006   0x4770             BX       LR               ;; return
   1496          
   1497          /*******************************************************************************
   1498          * Function Name  : TIM_ForcedOC4Config
   1499          * Description    : Forces the TIMx output 4 waveform to active or inactive level.
   1500          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1501          *                    peripheral.
   1502          *                  - TIM_ForcedAction: specifies the forced Action to be set to
   1503          *                    the output waveform.
   1504          *                    This parameter can be one of the following values:
   1505          *                       - TIM_ForcedAction_Active: Force active level on OC4REF
   1506          *                       - TIM_ForcedAction_InActive: Force inactive level on
   1507          *                         OC4REF.
   1508          * Output         : None
   1509          * Return         : None
   1510          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1511          void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
   1512          {
   1513            u16 tmpccmr2 = 0;
   1514          
   1515            /* Check the parameters */
   1516            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1517            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1518            tmpccmr2 = TIMx->CCMR2;
   1519          
   1520            /* Reset the OC2M Bits */
   1521            tmpccmr2 &= CCMR_OC24M_Mask;
   1522          
   1523            /* Configure The Forced output Mode */
   1524            tmpccmr2 |= (u16)(TIM_ForcedAction << 8);
   1525          
   1526            /* Write to TIMx CCMR2 register */
   1527            TIMx->CCMR2 = tmpccmr2;
   \                     TIM_ForcedOC4Config:
   \   00000000   0x8B82             LDRH     R2,[R0, #+28]
   \   00000002   0xF648 0x73FF      MOVW     R3,#+36863
   \   00000006   0x....             B.N      ?Subroutine5
   1528          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5:
   \   00000000   0x401A             ANDS     R2,R3,R2
   \                     ??Subroutine5_0:
   \   00000002   0xEA42 0x2101      ORR      R1,R2,R1, LSL #+8
   \   00000006   0x8381             STRH     R1,[R0, #+28]
   \   00000008   0x4770             BX       LR               ;; return
   1529          
   1530          /*******************************************************************************
   1531          * Function Name  : TIM_ARRPreloadConfig
   1532          * Description    : Enables or disables TIMx peripheral Preload register on ARR.
   1533          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1534          *                    peripheral.
   1535          *                  - NewState: new state of the TIMx peripheral Preload register
   1536          *                    This parameter can be: ENABLE or DISABLE.
   1537          * Output         : None
   1538          * Return         : None
   1539          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1540          void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
   1541          {
   1542            /* Check the parameters */
   1543            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   1544            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1545          
   1546            if (NewState != DISABLE)
   \                     TIM_ARRPreloadConfig:
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x8801             LDRH     R1,[R0, #+0]
   \   00000004   0xBF12             ITEE     NE 
   \   00000006   0xF041 0x0180      ORRNE    R1,R1,#0x80
   \   0000000A   0xF240 0x327F      MOVWEQ   R2,#+895
   \   0000000E   0x4011             ANDEQ    R1,R2,R1
   1547            {
   1548              /* Set the ARR Preload Bit */
   1549              TIMx->CR1 |= CR1_ARPE_Set;
   1550            }
   1551            else
   1552            {
   1553              /* Reset the ARR Preload Bit */
   1554              TIMx->CR1 &= CR1_ARPE_Reset;
   \   00000010   0x8001             STRH     R1,[R0, #+0]
   1555            }
   1556          }
   \   00000012   0x4770             BX       LR               ;; return
   1557          
   1558          /*******************************************************************************
   1559          * Function Name  : TIM_SelectCOM
   1560          * Description    : Selects the TIM peripheral Commutation event.
   1561          * Input          :- TIMx: where x can be  1 or 8 to select the TIMx peripheral
   1562          *                 - NewState: new state of the Commutation event.
   1563          *                    This parameter can be: ENABLE or DISABLE.
   1564          * Output         : None
   1565          * Return         : None
   1566          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1567          void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
   1568          {
   1569            /* Check the parameters */
   1570            assert_param(IS_TIM_18_PERIPH(TIMx));
   1571            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1572          
   1573            if (NewState != DISABLE)
   \                     TIM_SelectCOM:
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x8881             LDRH     R1,[R0, #+4]
   \   00000004   0xBF12             ITEE     NE 
   \   00000006   0xF041 0x0104      ORRNE    R1,R1,#0x4
   \   0000000A   0xF64F 0x72FB      MOVWEQ   R2,#+65531
   \   0000000E   0x4011             ANDEQ    R1,R2,R1
   1574            {
   1575              /* Set the COM Bit */
   1576              TIMx->CR2 |= CR2_CCUS_Set;
   1577            }
   1578            else
   1579            {
   1580              /* Reset the COM Bit */
   1581              TIMx->CR2 &= CR2_CCUS_Reset;
   \   00000010   0x8081             STRH     R1,[R0, #+4]
   1582            }
   1583          }
   \   00000012   0x4770             BX       LR               ;; return
   1584          
   1585          /*******************************************************************************
   1586          * Function Name  : TIM_SelectCCDMA
   1587          * Description    : Selects the TIMx peripheral Capture Compare DMA source.
   1588          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1589          *                    peripheral.
   1590          *                  - NewState: new state of the Capture Compare DMA source
   1591          *                    This parameter can be: ENABLE or DISABLE.
   1592          * Output         : None
   1593          * Return         : None
   1594          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1595          void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
   1596          {
   1597            /* Check the parameters */
   1598            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1599            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1600          
   1601            if (NewState != DISABLE)
   \                     TIM_SelectCCDMA:
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x8881             LDRH     R1,[R0, #+4]
   \   00000004   0xBF12             ITEE     NE 
   \   00000006   0xF041 0x0108      ORRNE    R1,R1,#0x8
   \   0000000A   0xF64F 0x72F7      MOVWEQ   R2,#+65527
   \   0000000E   0x4011             ANDEQ    R1,R2,R1
   1602            {
   1603              /* Set the CCDS Bit */
   1604              TIMx->CR2 |= CR2_CCDS_Set;
   1605            }
   1606            else
   1607            {
   1608              /* Reset the CCDS Bit */
   1609              TIMx->CR2 &= CR2_CCDS_Reset;
   \   00000010   0x8081             STRH     R1,[R0, #+4]
   1610            }
   1611          }
   \   00000012   0x4770             BX       LR               ;; return
   1612          
   1613          /*******************************************************************************
   1614          * Function Name  : TIM_CCPreloadControl
   1615          * Description    : Sets or Resets the TIM peripheral Capture Compare Preload 
   1616          *                  Control bit.
   1617          * Input          :- TIMx: where x can be  1 or 8 to select the TIMx peripheral
   1618          *                 - NewState: new state of the Capture Compare Preload Control bit
   1619          *                    This parameter can be: ENABLE or DISABLE.
   1620          * Output         : None
   1621          * Return         : None
   1622          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1623          void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
   1624          { 
   1625            /* Check the parameters */
   1626            assert_param(IS_TIM_18_PERIPH(TIMx));
   1627            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1628          
   1629            if (NewState != DISABLE)
   \                     TIM_CCPreloadControl:
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x8881             LDRH     R1,[R0, #+4]
   \   00000004   0xBF12             ITEE     NE 
   \   00000006   0xF041 0x0101      ORRNE    R1,R1,#0x1
   \   0000000A   0xF64F 0x72FE      MOVWEQ   R2,#+65534
   \   0000000E   0x4011             ANDEQ    R1,R2,R1
   1630            {
   1631              /* Set the CCPC Bit */
   1632              TIMx->CR2 |= CR2_CCPC_Set;
   1633            }
   1634            else
   1635            {
   1636              /* Reset the CCPC Bit */
   1637              TIMx->CR2 &= CR2_CCPC_Reset;
   \   00000010   0x8081             STRH     R1,[R0, #+4]
   1638            }
   1639          }
   \   00000012   0x4770             BX       LR               ;; return
   1640          
   1641          /*******************************************************************************
   1642          * Function Name  : TIM_OC1PreloadConfig
   1643          * Description    : Enables or disables the TIMx peripheral Preload register on CCR1.
   1644          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1645          *                    peripheral.
   1646          *                  - TIM_OCPreload: new state of the TIMx peripheral Preload
   1647          *                    register
   1648          *                    This parameter can be one of the following values:
   1649          *                       - TIM_OCPreload_Enable
   1650          *                       - TIM_OCPreload_Disable
   1651          * Output         : None
   1652          * Return         : None
   1653          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1654          void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
   1655          {
   1656            u16 tmpccmr1 = 0;
   1657          
   1658            /* Check the parameters */
   1659            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1660            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1661          
   1662            tmpccmr1 = TIMx->CCMR1;
   1663          
   1664            /* Reset the OC1PE Bit */
   1665            tmpccmr1 &= CCMR_OC13PE_Reset;
   1666          
   1667            /* Enable or Disable the Output Compare Preload feature */
   1668            tmpccmr1 |= TIM_OCPreload;
   1669          
   1670            /* Write to TIMx CCMR1 register */
   1671            TIMx->CCMR1 = tmpccmr1;
   \                     TIM_OC1PreloadConfig:
   \   00000000   0x8B02             LDRH     R2,[R0, #+24]
   \   00000002   0xF64F 0x73F7      MOVW     R3,#+65527
   \   00000006                      REQUIRE ?Subroutine8
   \   00000006                      ;; // Fall through to label ?Subroutine8
   1672          }
   1673          
   1674          /*******************************************************************************
   1675          * Function Name  : TIM_OC2PreloadConfig
   1676          * Description    : Enables or disables the TIMx peripheral Preload register on CCR2.
   1677          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1678          *                    peripheral.
   1679          *                  - TIM_OCPreload: new state of the TIMx peripheral Preload
   1680          *                    register
   1681          *                    This parameter can be one of the following values:
   1682          *                       - TIM_OCPreload_Enable
   1683          *                       - TIM_OCPreload_Disable
   1684          * Output         : None
   1685          * Return         : None
   1686          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1687          void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
   1688          {
   1689            u16 tmpccmr1 = 0;
   1690          
   1691            /* Check the parameters */
   1692            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1693            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1694          
   1695            tmpccmr1 = TIMx->CCMR1;
   1696          
   1697            /* Reset the OC2PE Bit */
   1698            tmpccmr1 &= CCMR_OC24PE_Reset;
   1699          
   1700            /* Enable or Disable the Output Compare Preload feature */
   1701            tmpccmr1 |= (u16)(TIM_OCPreload << 8);
   1702          
   1703            /* Write to TIMx CCMR1 register */
   1704            TIMx->CCMR1 = tmpccmr1;
   \                     TIM_OC2PreloadConfig:
   \   00000000   0x8B02             LDRH     R2,[R0, #+24]
   \   00000002   0xF24F 0x73FF      MOVW     R3,#+63487
   \   00000006                      REQUIRE ?Subroutine4
   \   00000006                      ;; // Fall through to label ?Subroutine4
   1705          }
   1706          
   1707          /*******************************************************************************
   1708          * Function Name  : TIM_OC3PreloadConfig
   1709          * Description    : Enables or disables the TIMx peripheral Preload register on CCR3.
   1710          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1711          *                    peripheral.
   1712          *                  - TIM_OCPreload: new state of the TIMx peripheral Preload
   1713          *                    register
   1714          *                    This parameter can be one of the following values:
   1715          *                       - TIM_OCPreload_Enable
   1716          *                       - TIM_OCPreload_Disable
   1717          * Output         : None
   1718          * Return         : None
   1719          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1720          void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
   1721          {
   1722            u16 tmpccmr2 = 0;
   1723          
   1724            /* Check the parameters */
   1725            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1726            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1727          
   1728            tmpccmr2 = TIMx->CCMR2;
   1729          
   1730            /* Reset the OC3PE Bit */
   1731            tmpccmr2 &= CCMR_OC13PE_Reset;
   1732          
   1733            /* Enable or Disable the Output Compare Preload feature */
   1734            tmpccmr2 |= TIM_OCPreload;
   1735          
   1736            /* Write to TIMx CCMR2 register */
   1737            TIMx->CCMR2 = tmpccmr2;
   \                     TIM_OC3PreloadConfig:
   \   00000000   0x8B82             LDRH     R2,[R0, #+28]
   \   00000002   0xF64F 0x73F7      MOVW     R3,#+65527
   \   00000006                      REQUIRE ?Subroutine9
   \   00000006                      ;; // Fall through to label ?Subroutine9
   1738          }
   1739          
   1740          /*******************************************************************************
   1741          * Function Name  : TIM_OC4PreloadConfig
   1742          * Description    : Enables or disables the TIMx peripheral Preload register on CCR4.
   1743          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1744          *                    peripheral.
   1745          *                  - TIM_OCPreload: new state of the TIMx peripheral Preload
   1746          *                    register
   1747          *                    This parameter can be one of the following values:
   1748          *                       - TIM_OCPreload_Enable
   1749          *                       - TIM_OCPreload_Disable
   1750          * Output         : None
   1751          * Return         : None
   1752          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1753          void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
   1754          {
   1755            u16 tmpccmr2 = 0;
   1756          
   1757            /* Check the parameters */
   1758            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1759            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1760          
   1761            tmpccmr2 = TIMx->CCMR2;
   1762          
   1763            /* Reset the OC4PE Bit */
   1764            tmpccmr2 &= CCMR_OC24PE_Reset;
   1765          
   1766            /* Enable or Disable the Output Compare Preload feature */
   1767            tmpccmr2 |= (u16)(TIM_OCPreload << 8);
   1768          
   1769            /* Write to TIMx CCMR2 register */
   1770            TIMx->CCMR2 = tmpccmr2;
   \                     TIM_OC4PreloadConfig:
   \   00000000   0x8B82             LDRH     R2,[R0, #+28]
   \   00000002   0xF24F 0x73FF      MOVW     R3,#+63487
   \   00000006                      REQUIRE ?Subroutine5
   \   00000006                      ;; // Fall through to label ?Subroutine5
   1771          }
   1772          
   1773          /*******************************************************************************
   1774          * Function Name  : TIM_OC1FastConfig
   1775          * Description    : Configures the TIMx Output Compare 1 Fast feature.
   1776          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1777          *                    peripheral.
   1778          *                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1779          *                    This parameter can be one of the following values:
   1780          *                       - TIM_OCFast_Enable: TIM output compare fast enable
   1781          *                       - TIM_OCFast_Disable: TIM output compare fast disable
   1782          * Output         : None
   1783          * Return         : None
   1784          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1785          void TIM_OC1FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
   1786          {
   1787            u16 tmpccmr1 = 0;
   1788          
   1789            /* Check the parameters */
   1790            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1791            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1792          
   1793            /* Get the TIMx CCMR1 register value */
   1794            tmpccmr1 = TIMx->CCMR1;
   1795          
   1796            /* Reset the OC1FE Bit */
   1797            tmpccmr1 &= CCMR_OC13FE_Reset;
   1798          
   1799            /* Enable or Disable the Output Compare Fast Bit */
   1800            tmpccmr1 |= TIM_OCFast;
   1801          
   1802            /* Write to TIMx CCMR1 */
   1803            TIMx->CCMR1 = tmpccmr1;
   \                     TIM_OC1FastConfig:
   \   00000000   0x8B02             LDRH     R2,[R0, #+24]
   \   00000002   0xF64F 0x73FB      MOVW     R3,#+65531
   \   00000006   0x....             B.N      ?Subroutine8
   1804          }
   1805          
   1806          /*******************************************************************************
   1807          * Function Name  : TIM_OC2FastConfig
   1808          * Description    : Configures the TIMx Output Compare 2 Fast feature.
   1809          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1810          *                    peripheral.
   1811          *                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1812          *                    This parameter can be one of the following values:
   1813          *                       - TIM_OCFast_Enable: TIM output compare fast enable
   1814          *                       - TIM_OCFast_Disable: TIM output compare fast disable
   1815          * Output         : None
   1816          * Return         : None
   1817          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1818          void TIM_OC2FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
   1819          {
   1820            u16 tmpccmr1 = 0;
   1821          
   1822            /* Check the parameters */
   1823            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1824            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1825          
   1826            /* Get the TIMx CCMR1 register value */
   1827            tmpccmr1 = TIMx->CCMR1;
   1828          
   1829            /* Reset the OC2FE Bit */
   1830            tmpccmr1 &= CCMR_OC24FE_Reset;
   1831          
   1832            /* Enable or Disable the Output Compare Fast Bit */
   1833            tmpccmr1 |= (u16)(TIM_OCFast << 8);
   1834          
   1835            /* Write to TIMx CCMR1 */
   1836            TIMx->CCMR1 = tmpccmr1;
   \                     TIM_OC2FastConfig:
   \   00000000   0x8B02             LDRH     R2,[R0, #+24]
   \   00000002   0xF64F 0x33FF      MOVW     R3,#+64511
   \   00000006   0x....             B.N      ?Subroutine4
   1837          }
   1838          
   1839          /*******************************************************************************
   1840          * Function Name  : TIM_OC3FastConfig
   1841          * Description    : Configures the TIMx Output Compare 3 Fast feature.
   1842          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1843          *                    peripheral.
   1844          *                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1845          *                    This parameter can be one of the following values:
   1846          *                       - TIM_OCFast_Enable: TIM output compare fast enable
   1847          *                       - TIM_OCFast_Disable: TIM output compare fast disable
   1848          * Output         : None
   1849          * Return         : None
   1850          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1851          void TIM_OC3FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
   1852          {
   1853            u16 tmpccmr2 = 0;
   1854          
   1855            /* Check the parameters */
   1856            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1857            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1858          
   1859            /* Get the TIMx CCMR2 register value */
   1860            tmpccmr2 = TIMx->CCMR2;
   1861          
   1862            /* Reset the OC3FE Bit */
   1863            tmpccmr2 &= CCMR_OC13FE_Reset;
   1864          
   1865            /* Enable or Disable the Output Compare Fast Bit */
   1866            tmpccmr2 |= TIM_OCFast;
   1867          
   1868            /* Write to TIMx CCMR2 */
   1869            TIMx->CCMR2 = tmpccmr2;
   \                     TIM_OC3FastConfig:
   \   00000000   0x8B82             LDRH     R2,[R0, #+28]
   \   00000002   0xF64F 0x73FB      MOVW     R3,#+65531
   \   00000006   0x....             B.N      ?Subroutine9
   1870          }
   1871          
   1872          /*******************************************************************************
   1873          * Function Name  : TIM_OC4FastConfig
   1874          * Description    : Configures the TIMx Output Compare 4 Fast feature.
   1875          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1876          *                    peripheral.
   1877          *                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1878          *                    This parameter can be one of the following values:
   1879          *                       - TIM_OCFast_Enable: TIM output compare fast enable
   1880          *                       - TIM_OCFast_Disable: TIM output compare fast disable
   1881          * Output         : None
   1882          * Return         : None
   1883          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1884          void TIM_OC4FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
   1885          {
   1886            u16 tmpccmr2 = 0;
   1887          
   1888            /* Check the parameters */
   1889            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1890            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1891          
   1892            /* Get the TIMx CCMR2 register value */
   1893            tmpccmr2 = TIMx->CCMR2;
   1894          
   1895            /* Reset the OC4FE Bit */
   1896            tmpccmr2 &= CCMR_OC24FE_Reset;
   1897          
   1898            /* Enable or Disable the Output Compare Fast Bit */
   1899            tmpccmr2 |= (u16)(TIM_OCFast << 8);
   1900          
   1901            /* Write to TIMx CCMR2 */
   1902            TIMx->CCMR2 = tmpccmr2;
   \                     TIM_OC4FastConfig:
   \   00000000   0x8B82             LDRH     R2,[R0, #+28]
   \   00000002   0xF64F 0x33FF      MOVW     R3,#+64511
   \   00000006   0x....             B.N      ?Subroutine5
   1903          }
   1904          
   1905          /*******************************************************************************
   1906          * Function Name  : TIM_ClearOC1Ref
   1907          * Description    : Clears or safeguards the OCREF1 signal on an external event
   1908          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1909          *                    peripheral.
   1910          *                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1911          *                    This parameter can be one of the following values:
   1912          *                       - TIM_OCClear_Enable: TIM Output clear enable
   1913          *                       - TIM_OCClear_Disable: TIM Output clear disable
   1914          * Output         : None
   1915          * Return         : None
   1916          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1917          void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
   1918          {
   1919            u16 tmpccmr1 = 0;
   1920          
   1921            /* Check the parameters */
   1922            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1923            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1924          
   1925            tmpccmr1 = TIMx->CCMR1;
   1926          
   1927            /* Reset the OC1CE Bit */
   1928            tmpccmr1 &= CCMR_OC13CE_Reset;
   1929          
   1930            /* Enable or Disable the Output Compare Clear Bit */
   1931            tmpccmr1 |= TIM_OCClear;
   1932          
   1933            /* Write to TIMx CCMR1 register */
   1934            TIMx->CCMR1 = tmpccmr1;
   \                     TIM_ClearOC1Ref:
   \   00000000   0x8B02             LDRH     R2,[R0, #+24]
   \   00000002   0xF64F 0x737F      MOVW     R3,#+65407
   \   00000006   0x....             B.N      ?Subroutine8
   1935          }
   1936          
   1937          /*******************************************************************************
   1938          * Function Name  : TIM_ClearOC2Ref
   1939          * Description    : Clears or safeguards the OCREF2 signal on an external event
   1940          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1941          *                    peripheral.
   1942          *                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1943          *                    This parameter can be one of the following values:
   1944          *                       - TIM_OCClear_Enable: TIM Output clear enable
   1945          *                       - TIM_OCClear_Disable: TIM Output clear disable
   1946          * Output         : None
   1947          * Return         : None
   1948          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1949          void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
   1950          {
   1951            u16 tmpccmr1 = 0;
   1952          
   1953            /* Check the parameters */
   1954            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1955            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1956          
   1957            tmpccmr1 = TIMx->CCMR1;
   1958          
   1959            /* Reset the OC2CE Bit */
   1960            tmpccmr1 &= CCMR_OC24CE_Reset;
   1961          
   1962            /* Enable or Disable the Output Compare Clear Bit */
   1963            tmpccmr1 |= (u16)(TIM_OCClear << 8);
   1964          
   1965            /* Write to TIMx CCMR1 register */
   1966            TIMx->CCMR1 = tmpccmr1;
   \                     TIM_ClearOC2Ref:
   \   00000000   0x8B02             LDRH     R2,[R0, #+24]
   \   00000002   0x0452             LSLS     R2,R2,#+17
   \   00000004   0x0C52             LSRS     R2,R2,#+17
   \   00000006   0x....             B.N      ??Subroutine4_0
   1967          }
   1968          
   1969          /*******************************************************************************
   1970          * Function Name  : TIM_ClearOC3Ref
   1971          * Description    : Clears or safeguards the OCREF3 signal on an external event
   1972          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   1973          *                    peripheral.
   1974          *                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1975          *                    This parameter can be one of the following values:
   1976          *                       - TIM_OCClear_Enable: TIM Output clear enable
   1977          *                       - TIM_OCClear_Disable: TIM Output clear disable
   1978          * Output         : None
   1979          * Return         : None
   1980          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1981          void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
   1982          {
   1983            u16 tmpccmr2 = 0;
   1984          
   1985            /* Check the parameters */
   1986            assert_param(IS_TIM_123458_PERIPH(TIMx));
   1987            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1988          
   1989            tmpccmr2 = TIMx->CCMR2;
   1990          
   1991            /* Reset the OC3CE Bit */
   1992            tmpccmr2 &= CCMR_OC13CE_Reset;
   1993          
   1994            /* Enable or Disable the Output Compare Clear Bit */
   1995            tmpccmr2 |= TIM_OCClear;
   1996          
   1997            /* Write to TIMx CCMR2 register */
   1998            TIMx->CCMR2 = tmpccmr2;
   \                     TIM_ClearOC3Ref:
   \   00000000   0x8B82             LDRH     R2,[R0, #+28]
   \   00000002   0xF64F 0x737F      MOVW     R3,#+65407
   \   00000006   0x....             B.N      ?Subroutine9
   1999          }
   2000          
   2001          /*******************************************************************************
   2002          * Function Name  : TIM_ClearOC4Ref
   2003          * Description    : Clears or safeguards the OCREF4 signal on an external event
   2004          * Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
   2005          *                    peripheral.
   2006          *                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   2007          *                    This parameter can be one of the following values:
   2008          *                       - TIM_OCClear_Enable: TIM Output clear enable
   2009          *                       - TIM_OCClear_Disable: TIM Output clear disable
   2010          * Output         : None
   2011          * Return         : None
   2012          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2013          void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
   2014          {
   2015            u16 tmpccmr2 = 0;
   2016          
   2017            /* Check the parameters */
   2018            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2019            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   2020          
   2021            tmpccmr2 = TIMx->CCMR2;
   2022          
   2023            /* Reset the OC4CE Bit */
   2024            tmpccmr2 &= CCMR_OC24CE_Reset;
   2025          
   2026            /* Enable or Disable the Output Compare Clear Bit */
   2027            tmpccmr2 |= (u16)(TIM_OCClear << 8);
   2028          
   2029            /* Write to TIMx CCMR2 register */
   2030            TIMx->CCMR2 = tmpccmr2;
   \                     TIM_ClearOC4Ref:
   \   00000000   0x8B82             LDRH     R2,[R0, #+28]
   \   00000002   0x0452             LSLS     R2,R2,#+17
   \   00000004   0x0C52             LSRS     R2,R2,#+17
   \   00000006   0x....             B.N      ??Subroutine5_0
   2031          }
   2032          
   2033          /*******************************************************************************
   2034          * Function Name  : TIM_OC1PolarityConfig
   2035          * Description    : Configures the TIMx channel 1 polarity.
   2036          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2037          *                    peripheral.
   2038          *                  - TIM_OCPolarity: specifies the OC1 Polarity
   2039          *                    This parmeter can be one of the following values:
   2040          *                       - TIM_OCPolarity_High: Output Compare active high
   2041          *                       - TIM_OCPolarity_Low: Output Compare active low
   2042          * Output         : None
   2043          * Return         : None
   2044          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2045          void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
   2046          {
   2047            u16 tmpccer = 0;
   2048          
   2049            /* Check the parameters */
   2050            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2051            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   2052          
   2053            tmpccer = TIMx->CCER;
   2054          
   2055            /* Set or Reset the CC1P Bit */
   2056            tmpccer &= CCER_CC1P_Reset;
   2057            tmpccer |= TIM_OCPolarity;
   2058          
   2059            /* Write to TIMx CCER register */
   2060            TIMx->CCER = tmpccer;
   \                     TIM_OC1PolarityConfig:
   \   00000000   0x8C02             LDRH     R2,[R0, #+32]
   \   00000002   0xF64F 0x73FD      MOVW     R3,#+65533
   \   00000006   0x....             B.N      ?Subroutine10
   2061          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10:
   \   00000000   0x401A             ANDS     R2,R3,R2
   \   00000002   0x4311             ORRS     R1,R1,R2
   \   00000004   0x8401             STRH     R1,[R0, #+32]
   \   00000006   0x4770             BX       LR               ;; return
   2062          
   2063          /*******************************************************************************
   2064          * Function Name  : TIM_OC1NPolarityConfig
   2065          * Description    : Configures the TIMx Channel 1N polarity.
   2066          * Input          : - TIMx: where x can be 1 or 8 to select the TIM peripheral.
   2067          *                  - TIM_OCNPolarity: specifies the OC1N Polarity
   2068          *                    This parmeter can be one of the following values:
   2069          *                       - TIM_OCNPolarity_High: Output Compare active high
   2070          *                       - TIM_OCNPolarity_Low: Output Compare active low
   2071          * Output         : None
   2072          * Return         : None
   2073          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2074          void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity)
   2075          {
   2076            u16 tmpccer = 0;
   2077          
   2078            /* Check the parameters */
   2079            assert_param(IS_TIM_18_PERIPH(TIMx));
   2080            assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   2081             
   2082            tmpccer = TIMx->CCER;
   2083          
   2084            /* Set or Reset the CC1NP Bit */
   2085            tmpccer &= CCER_CC1NP_Reset;
   2086            tmpccer |= TIM_OCNPolarity;
   2087          
   2088            /* Write to TIMx CCER register */
   2089            TIMx->CCER = tmpccer;
   \                     TIM_OC1NPolarityConfig:
   \   00000000   0x8C02             LDRH     R2,[R0, #+32]
   \   00000002   0xF64F 0x73F7      MOVW     R3,#+65527
   \   00000006                      REQUIRE ?Subroutine10
   \   00000006                      ;; // Fall through to label ?Subroutine10
   2090          }
   2091          
   2092          /*******************************************************************************
   2093          * Function Name  : TIM_OC2PolarityConfig
   2094          * Description    : Configures the TIMx channel 2 polarity.
   2095          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2096          *                    peripheral.
   2097          *                  - TIM_OCPolarity: specifies the OC2 Polarity
   2098          *                    This parmeter can be one of the following values:
   2099          *                       - TIM_OCPolarity_High: Output Compare active high
   2100          *                       - TIM_OCPolarity_Low: Output Compare active low
   2101          * Output         : None
   2102          * Return         : None
   2103          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2104          void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
   2105          {
   2106            u16 tmpccer = 0;
   2107          
   2108            /* Check the parameters */
   2109            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2110            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   2111          
   2112            tmpccer = TIMx->CCER;
   2113          
   2114            /* Set or Reset the CC2P Bit */
   2115            tmpccer &= CCER_CC2P_Reset;
   2116            tmpccer |= (u16)(TIM_OCPolarity << 4);
   2117          
   2118            /* Write to TIMx CCER register */
   2119            TIMx->CCER = tmpccer;
   \                     TIM_OC2PolarityConfig:
   \   00000000   0x8C02             LDRH     R2,[R0, #+32]
   \   00000002   0xF64F 0x73DF      MOVW     R3,#+65503
   \   00000006   0x....             B.N      ?Subroutine6
   2120          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6:
   \   00000000   0x401A             ANDS     R2,R3,R2
   \   00000002   0xEA42 0x1101      ORR      R1,R2,R1, LSL #+4
   \   00000006   0x8401             STRH     R1,[R0, #+32]
   \   00000008   0x4770             BX       LR               ;; return
   2121          
   2122          /*******************************************************************************
   2123          * Function Name  : TIM_OC2NPolarityConfig
   2124          * Description    : Configures the TIMx Channel 2N polarity.
   2125          * Input          : - TIMx: where x can be 1 or 8 to select the TIM peripheral.
   2126          *                  - TIM_OCNPolarity: specifies the OC2N Polarity
   2127          *                    This parmeter can be one of the following values:
   2128          *                       - TIM_OCNPolarity_High: Output Compare active high
   2129          *                       - TIM_OCNPolarity_Low: Output Compare active low
   2130          * Output         : None
   2131          * Return         : None
   2132          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2133          void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity)
   2134          {
   2135            u16 tmpccer = 0;
   2136          
   2137            /* Check the parameters */
   2138            assert_param(IS_TIM_18_PERIPH(TIMx));
   2139            assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   2140            
   2141            tmpccer = TIMx->CCER;
   2142          
   2143            /* Set or Reset the CC2NP Bit */
   2144            tmpccer &= CCER_CC2NP_Reset;
   2145            tmpccer |= (u16)(TIM_OCNPolarity << 4);
   2146          
   2147            /* Write to TIMx CCER register */
   2148            TIMx->CCER = tmpccer;
   \                     TIM_OC2NPolarityConfig:
   \   00000000   0x8C02             LDRH     R2,[R0, #+32]
   \   00000002   0xF64F 0x737F      MOVW     R3,#+65407
   \   00000006                      REQUIRE ?Subroutine6
   \   00000006                      ;; // Fall through to label ?Subroutine6
   2149          }
   2150          
   2151          /*******************************************************************************
   2152          * Function Name  : TIM_OC3PolarityConfig
   2153          * Description    : Configures the TIMx channel 3 polarity.
   2154          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2155          *                    peripheral.
   2156          *                  - TIM_OCPolarity: specifies the OC3 Polarity
   2157          *                    This parmeter can be one of the following values:
   2158          *                       - TIM_OCPolarity_High: Output Compare active high
   2159          *                       - TIM_OCPolarity_Low: Output Compare active low
   2160          * Output         : None
   2161          * Return         : None
   2162          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2163          void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
   2164          {
   2165            u16 tmpccer = 0;
   2166          
   2167            /* Check the parameters */
   2168            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2169            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   2170          
   2171            tmpccer = TIMx->CCER;
   2172          
   2173            /* Set or Reset the CC3P Bit */
   2174            tmpccer &= CCER_CC3P_Reset;
   2175            tmpccer |= (u16)(TIM_OCPolarity << 8);
   2176          
   2177            /* Write to TIMx CCER register */
   2178            TIMx->CCER = tmpccer;
   \                     TIM_OC3PolarityConfig:
   \   00000000   0x8C02             LDRH     R2,[R0, #+32]
   \   00000002   0xF64F 0x53FF      MOVW     R3,#+65023
   \   00000006   0x....             B.N      ?Subroutine7
   2179          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7:
   \   00000000   0x401A             ANDS     R2,R3,R2
   \   00000002   0xEA42 0x2101      ORR      R1,R2,R1, LSL #+8
   \   00000006   0x8401             STRH     R1,[R0, #+32]
   \   00000008   0x4770             BX       LR               ;; return
   2180          
   2181          /*******************************************************************************
   2182          * Function Name  : TIM_OC3NPolarityConfig
   2183          * Description    : Configures the TIMx Channel 3N polarity.
   2184          * Input          : - TIMx: where x can be 1 or 8 to select the TIM peripheral.
   2185          *                  - TIM_OCNPolarity: specifies the OC3N Polarity
   2186          *                    This parmeter can be one of the following values:
   2187          *                       - TIM_OCNPolarity_High: Output Compare active high
   2188          *                       - TIM_OCNPolarity_Low: Output Compare active low
   2189          * Output         : None
   2190          * Return         : None
   2191          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2192          void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity)
   2193          {
   2194            u16 tmpccer = 0;
   2195           
   2196            /* Check the parameters */
   2197            assert_param(IS_TIM_18_PERIPH(TIMx));
   2198            assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   2199              
   2200            tmpccer = TIMx->CCER;
   2201          
   2202            /* Set or Reset the CC3NP Bit */
   2203            tmpccer &= CCER_CC3NP_Reset;
   2204            tmpccer |= (u16)(TIM_OCNPolarity << 8);
   2205          
   2206            /* Write to TIMx CCER register */
   2207            TIMx->CCER = tmpccer;
   \                     TIM_OC3NPolarityConfig:
   \   00000000   0x8C02             LDRH     R2,[R0, #+32]
   \   00000002   0xF24F 0x73FF      MOVW     R3,#+63487
   \   00000006                      REQUIRE ?Subroutine7
   \   00000006                      ;; // Fall through to label ?Subroutine7
   2208          }
   2209          
   2210          /*******************************************************************************
   2211          * Function Name  : TIM_OC4PolarityConfig
   2212          * Description    : Configures the TIMx channel 4 polarity.
   2213          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2214          *                    peripheral.
   2215          *                  - TIM_OCPolarity: specifies the OC4 Polarity
   2216          *                    This parmeter can be one of the following values:
   2217          *                       - TIM_OCPolarity_High: Output Compare active high
   2218          *                       - TIM_OCPolarity_Low: Output Compare active low
   2219          * Output         : None
   2220          * Return         : None
   2221          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2222          void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
   2223          {
   2224            u16 tmpccer = 0;
   2225          
   2226            /* Check the parameters */
   2227            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2228            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   2229          
   2230            tmpccer = TIMx->CCER;
   2231          
   2232            /* Set or Reset the CC4P Bit */
   2233            tmpccer &= CCER_CC4P_Reset;
   2234            tmpccer |= (u16)(TIM_OCPolarity << 12);
   2235          
   2236            /* Write to TIMx CCER register */
   2237            TIMx->CCER = tmpccer;
   \                     TIM_OC4PolarityConfig:
   \   00000000   0x8C02             LDRH     R2,[R0, #+32]
   \   00000002   0xF64D 0x73FF      MOVW     R3,#+57343
   \   00000006   0x401A             ANDS     R2,R3,R2
   \   00000008   0xEA42 0x3101      ORR      R1,R2,R1, LSL #+12
   \   0000000C   0x8401             STRH     R1,[R0, #+32]
   2238          }
   \   0000000E   0x4770             BX       LR               ;; return
   2239          
   2240          /*******************************************************************************
   2241          * Function Name  : TIM_CCxCmd
   2242          * Description    : Enables or disables the TIM Capture Compare Channel x.
   2243          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM
   2244          *                    peripheral.
   2245          *                  - TIM_Channel: specifies the TIM Channel
   2246          *                    This parmeter can be one of the following values:
   2247          *                       - TIM_Channel_1: TIM Channel 1
   2248          *                       - TIM_Channel_2: TIM Channel 2
   2249          *                       - TIM_Channel_3: TIM Channel 3
   2250          *                       - TIM_Channel_4: TIM Channel 4
   2251          *                 - TIM_CCx: specifies the TIM Channel CCxE bit new state.
   2252          *                   This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable. 
   2253          * Output         : None
   2254          * Return         : None
   2255          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2256          void TIM_CCxCmd(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_CCx)
   2257          {
   2258            /* Check the parameters */
   2259            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2260            assert_param(IS_TIM_CHANNEL(TIM_Channel));
   2261            assert_param(IS_TIM_CCX(TIM_CCx));
   2262          
   2263            /* Reset the CCxE Bit */
   2264            TIMx->CCER &= (u16)(~((u16)(CCER_CCE_Set << TIM_Channel)));
   \                     TIM_CCxCmd:
   \   00000000   0x8C03             LDRH     R3,[R0, #+32]
   \   00000002   0xF04F 0x0C01      MOV      R12,#+1
   \   00000006   0x....             B.N      ?Subroutine0
   2265          
   2266            /* Set or reset the CCxE Bit */ 
   2267            TIMx->CCER |=  (u16)(TIM_CCx << TIM_Channel);
   2268          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0xFA0C 0xFC01      LSL      R12,R12,R1
   \   00000004   0xEA23 0x030C      BIC      R3,R3,R12
   \   00000008   0x8403             STRH     R3,[R0, #+32]
   \   0000000A   0x8C03             LDRH     R3,[R0, #+32]
   \   0000000C   0xFA02 0xF101      LSL      R1,R2,R1
   \   00000010   0x4319             ORRS     R1,R1,R3
   \   00000012   0x8401             STRH     R1,[R0, #+32]
   \   00000014   0x4770             BX       LR               ;; return
   2269          
   2270          /*******************************************************************************
   2271          * Function Name  : TIM_CCxNCmd
   2272          * Description    : Enables or disables the TIM Capture Compare Channel xN.
   2273          * Input          :- TIMx: where x can be 1 or 8 to select the TIM peripheral.
   2274          *                 - TIM_Channel: specifies the TIM Channel
   2275          *                    This parmeter can be one of the following values:
   2276          *                       - TIM_Channel_1: TIM Channel 1
   2277          *                       - TIM_Channel_2: TIM Channel 2
   2278          *                       - TIM_Channel_3: TIM Channel 3
   2279          *                 - TIM_CCx: specifies the TIM Channel CCxNE bit new state.
   2280          *                   This parameter can be: TIM_CCxN_Enable or TIM_CCxN_Disable. 
   2281          * Output         : None
   2282          * Return         : None
   2283          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2284          void TIM_CCxNCmd(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_CCxN)
   2285          {
   2286            /* Check the parameters */
   2287            assert_param(IS_TIM_18_PERIPH(TIMx));
   2288            assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
   2289            assert_param(IS_TIM_CCXN(TIM_CCxN));
   2290          
   2291            /* Reset the CCxNE Bit */
   2292            TIMx->CCER &= (u16)(~((u16)(CCER_CCNE_Set << TIM_Channel)));
   \                     TIM_CCxNCmd:
   \   00000000   0x8C03             LDRH     R3,[R0, #+32]
   \   00000002   0xF04F 0x0C04      MOV      R12,#+4
   \   00000006                      REQUIRE ?Subroutine0
   \   00000006                      ;; // Fall through to label ?Subroutine0
   2293          
   2294            /* Set or reset the CCxNE Bit */ 
   2295            TIMx->CCER |=  (u16)(TIM_CCxN << TIM_Channel);
   2296          }
   2297          
   2298          /*******************************************************************************
   2299          * Function Name  : TIM_SelectOCxM
   2300          * Description    : Selects the TIM Ouput Compare Mode.
   2301          *                  This function disables the selected channel before changing 
   2302          *                  the Ouput Compare Mode. User has to enable this channel using
   2303          *                  TIM_CCxCmd and TIM_CCxNCmd functions.
   2304          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM
   2305          *                    peripheral.
   2306          *                  - TIM_Channel: specifies the TIM Channel
   2307          *                    This parmeter can be one of the following values:
   2308          *                       - TIM_Channel_1: TIM Channel 1
   2309          *                       - TIM_Channel_2: TIM Channel 2
   2310          *                       - TIM_Channel_3: TIM Channel 3
   2311          *                       - TIM_Channel_4: TIM Channel 4
   2312          *                  - TIM_OCMode: specifies the TIM Output Compare Mode.
   2313          *                    This paramter can be one of the following values:
   2314          *                       - TIM_OCMode_Timing
   2315          *                       - TIM_OCMode_Active
   2316          *                       - TIM_OCMode_Toggle
   2317          *                       - TIM_OCMode_PWM1
   2318          *                       - TIM_OCMode_PWM2
   2319          *                       - TIM_ForcedAction_Active
   2320          *                       - TIM_ForcedAction_InActive
   2321          * Output         : None
   2322          * Return         : None
   2323          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2324          void TIM_SelectOCxM(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_OCMode)
   2325          {
   \                     TIM_SelectOCxM:
   \   00000000   0xB410             PUSH     {R4}
   2326            /* Check the parameters */
   2327            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2328            assert_param(IS_TIM_CHANNEL(TIM_Channel));
   2329            assert_param(IS_TIM_OCM(TIM_OCMode));
   2330            
   2331            /* Disable the Channel: Reset the CCxE Bit */
   2332            TIMx->CCER &= (u16)(~((u16)(CCER_CCE_Set << TIM_Channel)));
   \   00000002   0x8C03             LDRH     R3,[R0, #+32]
   \   00000004   0x2401             MOVS     R4,#+1
   \   00000006   0x408C             LSLS     R4,R4,R1
   \   00000008   0x43A3             BICS     R3,R3,R4
   \   0000000A   0x8403             STRH     R3,[R0, #+32]
   2333          
   2334            if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xBF18             IT       NE 
   \   00000010   0x2908             CMPNE    R1,#+8
   \   00000012   0xD10D             BNE.N    ??TIM_SelectOCxM_0
   2335            {
   2336              /* Reset the OCxM bits in the CCMRx register */
   2337              *((vu32 *)((*(u32*)&TIMx) + CCMR_Offset + (TIM_Channel>>1))) &= CCMR_OC13M_Mask;
   \   00000014   0xEB10 0x0361      ADDS     R3,R0,R1, ASR #+1
   \   00000018   0x699B             LDR      R3,[R3, #+24]
   \   0000001A   0xF64F 0x748F      MOVW     R4,#+65423
   \   0000001E   0x4023             ANDS     R3,R4,R3
   \   00000020   0xEB10 0x0461      ADDS     R4,R0,R1, ASR #+1
   \   00000024   0x61A3             STR      R3,[R4, #+24]
   2338             
   2339              /* Configure the OCxM bits in the CCMRx register */
   2340              *((vu32 *)((*(u32*)&TIMx) + CCMR_Offset + (TIM_Channel>>1))) = TIM_OCMode;
   \   00000026   0xEB10 0x0061      ADDS     R0,R0,R1, ASR #+1
   \   0000002A   0x6182             STR      R2,[R0, #+24]
   \   0000002C   0xBC10             POP      {R4}
   \   0000002E   0x4770             BX       LR
   2341          
   2342            }
   2343            else
   2344            {
   2345              /* Reset the OCxM bits in the CCMRx register */
   2346              *((vu32 *)((*(u32*)&TIMx) + CCMR_Offset + ((u16)(TIM_Channel - 4)>> 1))) &= CCMR_OC24M_Mask;
   \                     ??TIM_SelectOCxM_0:
   \   00000030   0x1F09             SUBS     R1,R1,#+4
   \   00000032   0xB289             UXTH     R1,R1
   \   00000034   0xEB10 0x0361      ADDS     R3,R0,R1, ASR #+1
   \   00000038   0x699B             LDR      R3,[R3, #+24]
   \   0000003A   0xF648 0x74FF      MOVW     R4,#+36863
   \   0000003E   0x4023             ANDS     R3,R4,R3
   \   00000040   0xEB10 0x0461      ADDS     R4,R0,R1, ASR #+1
   \   00000044   0x61A3             STR      R3,[R4, #+24]
   2347              
   2348              /* Configure the OCxM bits in the CCMRx register */
   2349              *((vu32 *)((*(u32*)&TIMx) + CCMR_Offset + ((u16)(TIM_Channel - 4)>> 1))) = (u16)(TIM_OCMode << 8);
   \   00000046   0xEB10 0x0061      ADDS     R0,R0,R1, ASR #+1
   \   0000004A   0x0211             LSLS     R1,R2,#+8
   \   0000004C   0xB289             UXTH     R1,R1
   \   0000004E   0x6181             STR      R1,[R0, #+24]
   2350            }
   2351          }
   \   00000050   0xBC10             POP      {R4}
   \   00000052   0x4770             BX       LR               ;; return
   2352          
   2353          /*******************************************************************************
   2354          * Function Name  : TIM_UpdateDisableConfig
   2355          * Description    : Enables or Disables the TIMx Update event.
   2356          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   2357          *                  - NewState: new state of the TIMx UDIS bit
   2358          *                    This parameter can be: ENABLE or DISABLE.
   2359          * Output         : None
   2360          * Return         : None
   2361          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2362          void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
   2363          {
   2364            /* Check the parameters */
   2365            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2366            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2367          
   2368            if (NewState != DISABLE)
   \                     TIM_UpdateDisableConfig:
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x8801             LDRH     R1,[R0, #+0]
   \   00000004   0xBF12             ITEE     NE 
   \   00000006   0xF041 0x0102      ORRNE    R1,R1,#0x2
   \   0000000A   0xF240 0x32FD      MOVWEQ   R2,#+1021
   \   0000000E   0x4011             ANDEQ    R1,R2,R1
   2369            {
   2370              /* Set the Update Disable Bit */
   2371              TIMx->CR1 |= CR1_UDIS_Set;
   2372            }
   2373            else
   2374            {
   2375              /* Reset the Update Disable Bit */
   2376              TIMx->CR1 &= CR1_UDIS_Reset;
   \   00000010   0x8001             STRH     R1,[R0, #+0]
   2377            }
   2378          }
   \   00000012   0x4770             BX       LR               ;; return
   2379          
   2380          /*******************************************************************************
   2381          * Function Name  : TIM_UpdateRequestConfig
   2382          * Description    : Configures the TIMx Update Request Interrupt source.
   2383          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   2384          *                  - TIM_UpdateSource: specifies the Update source.
   2385          *                    This parameter can be one of the following values:
   2386          *                       - TIM_UpdateSource_Regular
   2387          *                       - TIM_UpdateSource_Global
   2388          * Output         : None
   2389          * Return         : None
   2390          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2391          void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, u16 TIM_UpdateSource)
   2392          {
   2393            /* Check the parameters */
   2394            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2395            assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
   2396          
   2397            if (TIM_UpdateSource != TIM_UpdateSource_Global)
   \                     TIM_UpdateRequestConfig:
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x8801             LDRH     R1,[R0, #+0]
   \   00000004   0xBF12             ITEE     NE 
   \   00000006   0xF041 0x0104      ORRNE    R1,R1,#0x4
   \   0000000A   0xF240 0x32FB      MOVWEQ   R2,#+1019
   \   0000000E   0x4011             ANDEQ    R1,R2,R1
   2398            {
   2399              /* Set the URS Bit */
   2400              TIMx->CR1 |= CR1_URS_Set;
   2401            }
   2402            else
   2403            {
   2404              /* Reset the URS Bit */
   2405              TIMx->CR1 &= CR1_URS_Reset;
   \   00000010   0x8001             STRH     R1,[R0, #+0]
   2406            }
   2407          }
   \   00000012   0x4770             BX       LR               ;; return
   2408          
   2409          /*******************************************************************************
   2410          * Function Name  : TIM_SelectHallSensor
   2411          * Description    : Enables or disables the TIMxs Hall sensor interface.
   2412          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2413          *                  - NewState: new state of the TIMx Hall sensor interface.
   2414          *                    This parameter can be: ENABLE or DISABLE.
   2415          * Output         : None
   2416          * Return         : None
   2417          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2418          void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
   2419          {
   2420            /* Check the parameters */
   2421            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2422            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2423          
   2424            if (NewState != DISABLE)
   \                     TIM_SelectHallSensor:
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x8881             LDRH     R1,[R0, #+4]
   \   00000004   0xBF12             ITEE     NE 
   \   00000006   0xF041 0x0180      ORRNE    R1,R1,#0x80
   \   0000000A   0xF64F 0x727F      MOVWEQ   R2,#+65407
   \   0000000E   0x4011             ANDEQ    R1,R2,R1
   2425            {
   2426              /* Set the TI1S Bit */
   2427              TIMx->CR2 |= CR2_TI1S_Set;
   2428            }
   2429            else
   2430            {
   2431              /* Reset the TI1S Bit */
   2432              TIMx->CR2 &= CR2_TI1S_Reset;
   \   00000010   0x8081             STRH     R1,[R0, #+4]
   2433            }
   2434          }
   \   00000012   0x4770             BX       LR               ;; return
   2435          
   2436          /*******************************************************************************
   2437          * Function Name  : TIM_SelectOnePulseMode
   2438          * Description    : Selects the TIMxs One Pulse Mode.
   2439          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   2440          *                  - TIM_OPMode: specifies the OPM Mode to be used.
   2441          *                    This parameter can be one of the following values:
   2442          *                       - TIM_OPMode_Single
   2443          *                       - TIM_OPMode_Repetitive
   2444          * Output         : None
   2445          * Return         : None
   2446          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2447          void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, u16 TIM_OPMode)
   2448          {
   2449            /* Check the parameters */
   2450            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2451            assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
   2452          
   2453            /* Reset the OPM Bit */
   2454            TIMx->CR1 &= CR1_OPM_Reset;
   \                     TIM_SelectOnePulseMode:
   \   00000000   0x8802             LDRH     R2,[R0, #+0]
   \   00000002   0xF240 0x33F7      MOVW     R3,#+1015
   \   00000006   0x401A             ANDS     R2,R3,R2
   \   00000008   0x....             B.N      ?Subroutine3
   2455          
   2456            /* Configure the OPM Mode */
   2457            TIMx->CR1 |= TIM_OPMode;
   2458          }
   2459          
   2460          /*******************************************************************************
   2461          * Function Name  : TIM_SelectOutputTrigger
   2462          * Description    : Selects the TIMx Trigger Output Mode.
   2463          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   2464          *                  - TIM_TRGOSource: specifies the Trigger Output source.
   2465          *                    This paramter can be as follow:
   2466          *                      1/ For TIM1 to TIM8:
   2467          *                       - TIM_TRGOSource_Reset 
   2468          *                       - TIM_TRGOSource_Enable
   2469          *                       - TIM_TRGOSource_Update
   2470          *                      2/ These parameters are available for all TIMx except 
   2471          *                         TIM6 and TIM7:
   2472          *                       - TIM_TRGOSource_OC1
   2473          *                       - TIM_TRGOSource_OC1Ref
   2474          *                       - TIM_TRGOSource_OC2Ref
   2475          *                       - TIM_TRGOSource_OC3Ref
   2476          *                       - TIM_TRGOSource_OC4Ref
   2477          * Output         : None
   2478          * Return         : None
   2479          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2480          void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, u16 TIM_TRGOSource)
   2481          {
   2482            /* Check the parameters */
   2483            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2484            assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
   2485            assert_param(IS_TIM_PERIPH_TRGO(TIMx, TIM_TRGOSource));
   2486          
   2487            /* Reset the MMS Bits */
   2488            TIMx->CR2 &= CR2_MMS_Mask;
   \                     TIM_SelectOutputTrigger:
   \   00000000   0x8882             LDRH     R2,[R0, #+4]
   \   00000002   0xF64F 0x738F      MOVW     R3,#+65423
   \   00000006   0x401A             ANDS     R2,R3,R2
   \   00000008   0x8082             STRH     R2,[R0, #+4]
   2489          
   2490            /* Select the TRGO source */
   2491            TIMx->CR2 |=  TIM_TRGOSource;
   \   0000000A   0x8882             LDRH     R2,[R0, #+4]
   \   0000000C   0x4311             ORRS     R1,R1,R2
   \   0000000E   0x8081             STRH     R1,[R0, #+4]
   2492          }
   \   00000010   0x4770             BX       LR               ;; return
   2493          
   2494          /*******************************************************************************
   2495          * Function Name  : TIM_SelectSlaveMode
   2496          * Description    : Selects the TIMx Slave Mode.
   2497          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2498          *                    peripheral.
   2499          *                  - TIM_SlaveMode: specifies the Timer Slave Mode.
   2500          *                    This paramter can be one of the following values:
   2501          *                       - TIM_SlaveMode_Reset
   2502          *                       - TIM_SlaveMode_Gated
   2503          *                       - TIM_SlaveMode_Trigger
   2504          *                       - TIM_SlaveMode_External1
   2505          * Output         : None
   2506          * Return         : None
   2507          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2508          void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, u16 TIM_SlaveMode)
   2509          {
   2510            /* Check the parameters */
   2511            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2512            assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
   2513          
   2514            /* Reset the SMS Bits */
   2515            TIMx->SMCR &= SMCR_SMS_Mask;
   \                     TIM_SelectSlaveMode:
   \   00000000   0x8902             LDRH     R2,[R0, #+8]
   \   00000002   0xF64F 0x73F8      MOVW     R3,#+65528
   \   00000006   0x....             B.N      ?Subroutine1
   2516          
   2517            /* Select the Slave Mode */
   2518            TIMx->SMCR |= TIM_SlaveMode;
   2519          }
   2520          
   2521          /*******************************************************************************
   2522          * Function Name  : TIM_SelectMasterSlaveMode
   2523          * Description    : Sets or Resets the TIMx Master/Slave Mode.
   2524          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2525          *                    peripheral.
   2526          *                  - TIM_MasterSlaveMode: specifies the Timer Master Slave Mode.
   2527          *                    This paramter can be one of the following values:
   2528          *                       - TIM_MasterSlaveMode_Enable: synchronization between the
   2529          *                         current timer and its slaves (through TRGO).
   2530          *                       - TIM_MasterSlaveMode_Disable: No action
   2531          * Output         : None
   2532          * Return         : None
   2533          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2534          void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, u16 TIM_MasterSlaveMode)
   2535          {
   2536            /* Check the parameters */
   2537            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2538            assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
   2539          
   2540            /* Reset the MSM Bit */
   2541            TIMx->SMCR &= SMCR_MSM_Reset;
   \                     TIM_SelectMasterSlaveMode:
   \   00000000   0x8902             LDRH     R2,[R0, #+8]
   \   00000002   0xF64F 0x737F      MOVW     R3,#+65407
   \   00000006                      REQUIRE ?Subroutine1
   \   00000006                      ;; // Fall through to label ?Subroutine1
   2542            
   2543            /* Set or Reset the MSM Bit */
   2544            TIMx->SMCR |= TIM_MasterSlaveMode;
   2545          }
   2546          
   2547          /*******************************************************************************
   2548          * Function Name  : TIM_SetCounter
   2549          * Description    : Sets the TIMx Counter Register value
   2550          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   2551          *                  - Counter: specifies the Counter register new value.
   2552          * Output         : None
   2553          * Return         : None
   2554          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2555          void TIM_SetCounter(TIM_TypeDef* TIMx, u16 Counter)
   2556          {
   2557            /* Check the parameters */
   2558            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2559          
   2560            /* Set the Counter Register value */
   2561            TIMx->CNT = Counter;
   \                     TIM_SetCounter:
   \   00000000   0x8481             STRH     R1,[R0, #+36]
   2562          }
   \   00000002   0x4770             BX       LR               ;; return
   2563          
   2564          /*******************************************************************************
   2565          * Function Name  : TIM_SetAutoreload
   2566          * Description    : Sets the TIMx Autoreload Register value
   2567          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   2568          *                  - Autoreload: specifies the Autoreload register new value.
   2569          * Output         : None
   2570          * Return         : None
   2571          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2572          void TIM_SetAutoreload(TIM_TypeDef* TIMx, u16 Autoreload)
   2573          {
   2574            /* Check the parameters */
   2575            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2576          
   2577            /* Set the Autoreload Register value */
   2578            TIMx->ARR = Autoreload;
   \                     TIM_SetAutoreload:
   \   00000000   0x8581             STRH     R1,[R0, #+44]
   2579          }
   \   00000002   0x4770             BX       LR               ;; return
   2580          
   2581          /*******************************************************************************
   2582          * Function Name  : TIM_SetCompare1
   2583          * Description    : Sets the TIMx Capture Compare1 Register value
   2584          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2585          *                    peripheral.
   2586          *                  - Compare1: specifies the Capture Compare1 register new value.
   2587          * Output         : None
   2588          * Return         : None
   2589          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2590          void TIM_SetCompare1(TIM_TypeDef* TIMx, u16 Compare1)
   2591          {
   2592            /* Check the parameters */
   2593            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2594          
   2595            /* Set the Capture Compare1 Register value */
   2596            TIMx->CCR1 = Compare1;
   \                     TIM_SetCompare1:
   \   00000000   0x8681             STRH     R1,[R0, #+52]
   2597          }
   \   00000002   0x4770             BX       LR               ;; return
   2598          
   2599          /*******************************************************************************
   2600          * Function Name  : TIM_SetCompare2
   2601          * Description    : Sets the TIMx Capture Compare2 Register value
   2602          * Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2603          *                   peripheral.
   2604          *                  - Compare2: specifies the Capture Compare2 register new value.
   2605          * Output         : None
   2606          * Return         : None
   2607          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2608          void TIM_SetCompare2(TIM_TypeDef* TIMx, u16 Compare2)
   2609          {
   2610            /* Check the parameters */
   2611            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2612          
   2613            /* Set the Capture Compare2 Register value */
   2614            TIMx->CCR2 = Compare2;
   \                     TIM_SetCompare2:
   \   00000000   0x8701             STRH     R1,[R0, #+56]
   2615          }
   \   00000002   0x4770             BX       LR               ;; return
   2616          
   2617          /*******************************************************************************
   2618          * Function Name  : TIM_SetCompare3
   2619          * Description    : Sets the TIMx Capture Compare3 Register value
   2620          * Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2621          *                   peripheral.
   2622          *                  - Compare3: specifies the Capture Compare3 register new value.
   2623          * Output         : None
   2624          * Return         : None
   2625          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2626          void TIM_SetCompare3(TIM_TypeDef* TIMx, u16 Compare3)
   2627          {
   2628            /* Check the parameters */
   2629            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2630          
   2631            /* Set the Capture Compare3 Register value */
   2632            TIMx->CCR3 = Compare3;
   \                     TIM_SetCompare3:
   \   00000000   0x8781             STRH     R1,[R0, #+60]
   2633          }
   \   00000002   0x4770             BX       LR               ;; return
   2634          
   2635          /*******************************************************************************
   2636          * Function Name  : TIM_SetCompare4
   2637          * Description    : Sets the TIMx Capture Compare4 Register value
   2638          * Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2639          *                   peripheral.
   2640          *                  - Compare4: specifies the Capture Compare4 register new value.
   2641          * Output         : None
   2642          * Return         : None
   2643          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2644          void TIM_SetCompare4(TIM_TypeDef* TIMx, u16 Compare4)
   2645          {
   2646            /* Check the parameters */
   2647            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2648          
   2649            /* Set the Capture Compare4 Register value */
   2650            TIMx->CCR4 = Compare4;
   \                     TIM_SetCompare4:
   \   00000000   0xF8A0 0x1040      STRH     R1,[R0, #+64]
   2651          }
   \   00000004   0x4770             BX       LR               ;; return
   2652          
   2653          /*******************************************************************************
   2654          * Function Name  : TIM_SetIC1Prescaler
   2655          * Description    : Sets the TIMx Input Capture 1 prescaler.
   2656          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2657          *                    peripheral.
   2658          *                  - TIM_ICPSC: specifies the Input Capture1 prescaler
   2659          *                    new value.
   2660          *                    This parameter can be one of the following values:
   2661          *                       - TIM_ICPSC_DIV1: no prescaler
   2662          *                       - TIM_ICPSC_DIV2: capture is done once every 2 events
   2663          *                       - TIM_ICPSC_DIV4: capture is done once every 4 events
   2664          *                       - TIM_ICPSC_DIV8: capture is done once every 8 events
   2665          * Output         : None
   2666          * Return         : None
   2667          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2668          void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
   2669          {
   2670            /* Check the parameters */
   2671            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2672            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2673          
   2674            /* Reset the IC1PSC Bits */
   2675            TIMx->CCMR1 &= CCMR_IC13PSC_Mask;
   \                     TIM_SetIC1Prescaler:
   \   00000000   0x8B02             LDRH     R2,[R0, #+24]
   \   00000002   0xF64F 0x73F3      MOVW     R3,#+65523
   \   00000006   0x401A             ANDS     R2,R3,R2
   \   00000008   0x8302             STRH     R2,[R0, #+24]
   2676          
   2677            /* Set the IC1PSC value */
   2678            TIMx->CCMR1 |= TIM_ICPSC;
   \   0000000A   0x8B02             LDRH     R2,[R0, #+24]
   \   0000000C   0x....             B.N      ??Subroutine8_0
   2679          }
   2680          
   2681          /*******************************************************************************
   2682          * Function Name  : TIM_SetIC2Prescaler
   2683          * Description    : Sets the TIMx Input Capture 2 prescaler.
   2684          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2685          *                    peripheral.
   2686          *                  - TIM_ICPSC: specifies the Input Capture2 prescaler
   2687          *                    new value.
   2688          *                    This parameter can be one of the following values:
   2689          *                       - TIM_ICPSC_DIV1: no prescaler
   2690          *                       - TIM_ICPSC_DIV2: capture is done once every 2 events
   2691          *                       - TIM_ICPSC_DIV4: capture is done once every 4 events
   2692          *                       - TIM_ICPSC_DIV8: capture is done once every 8 events
   2693          * Output         : None
   2694          * Return         : None
   2695          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2696          void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
   2697          {
   2698            /* Check the parameters */
   2699            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2700            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2701          
   2702            /* Reset the IC2PSC Bits */
   2703            TIMx->CCMR1 &= CCMR_IC24PSC_Mask;
   \                     TIM_SetIC2Prescaler:
   \   00000000   0x8B02             LDRH     R2,[R0, #+24]
   \   00000002   0xF24F 0x33FF      MOVW     R3,#+62463
   \   00000006   0x401A             ANDS     R2,R3,R2
   \   00000008   0x8302             STRH     R2,[R0, #+24]
   2704          
   2705            /* Set the IC2PSC value */
   2706            TIMx->CCMR1 |= (u16)(TIM_ICPSC << 8);
   \   0000000A   0x8B02             LDRH     R2,[R0, #+24]
   \   0000000C   0x....             B.N      ??Subroutine4_0
   2707          }
   2708          
   2709          /*******************************************************************************
   2710          * Function Name  : TIM_SetIC3Prescaler
   2711          * Description    : Sets the TIMx Input Capture 3 prescaler.
   2712          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2713          *                    peripheral.
   2714          *                  - TIM_ICPSC: specifies the Input Capture3 prescaler
   2715          *                    new value.
   2716          *                    This parameter can be one of the following values:
   2717          *                       - TIM_ICPSC_DIV1: no prescaler
   2718          *                       - TIM_ICPSC_DIV2: capture is done once every 2 events
   2719          *                       - TIM_ICPSC_DIV4: capture is done once every 4 events
   2720          *                       - TIM_ICPSC_DIV8: capture is done once every 8 events
   2721          * Output         : None
   2722          * Return         : None
   2723          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2724          void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
   2725          {
   2726            /* Check the parameters */
   2727            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2728            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2729          
   2730            /* Reset the IC3PSC Bits */
   2731            TIMx->CCMR2 &= CCMR_IC13PSC_Mask;
   \                     TIM_SetIC3Prescaler:
   \   00000000   0x8B82             LDRH     R2,[R0, #+28]
   \   00000002   0xF64F 0x73F3      MOVW     R3,#+65523
   \   00000006   0x401A             ANDS     R2,R3,R2
   \   00000008   0x8382             STRH     R2,[R0, #+28]
   2732          
   2733            /* Set the IC3PSC value */
   2734            TIMx->CCMR2 |= TIM_ICPSC;
   \   0000000A   0x8B82             LDRH     R2,[R0, #+28]
   \   0000000C   0x....             B.N      ??Subroutine9_0
   2735          }
   2736          
   2737          /*******************************************************************************
   2738          * Function Name  : TIM_SetIC4Prescaler
   2739          * Description    : Sets the TIMx Input Capture 4 prescaler.
   2740          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2741          *                    peripheral.
   2742          *                  - TIM_ICPSC: specifies the Input Capture4 prescaler
   2743          *                    new value.
   2744          *                    This parameter can be one of the following values:
   2745          *                      - TIM_ICPSC_DIV1: no prescaler
   2746          *                      - TIM_ICPSC_DIV2: capture is done once every 2 events
   2747          *                      - TIM_ICPSC_DIV4: capture is done once every 4 events
   2748          *                      - TIM_ICPSC_DIV8: capture is done once every 8 events
   2749          * Output         : None
   2750          * Return         : None
   2751          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2752          void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
   2753          {  
   2754            /* Check the parameters */
   2755            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2756            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2757          
   2758            /* Reset the IC4PSC Bits */
   2759            TIMx->CCMR2 &= CCMR_IC24PSC_Mask;
   \                     TIM_SetIC4Prescaler:
   \   00000000   0x8B82             LDRH     R2,[R0, #+28]
   \   00000002   0xF24F 0x33FF      MOVW     R3,#+62463
   \   00000006   0x401A             ANDS     R2,R3,R2
   \   00000008   0x8382             STRH     R2,[R0, #+28]
   2760          
   2761            /* Set the IC4PSC value */
   2762            TIMx->CCMR2 |= (u16)(TIM_ICPSC << 8);
   \   0000000A   0x8B82             LDRH     R2,[R0, #+28]
   \   0000000C   0x....             B.N      ??Subroutine5_0
   2763          }
   2764          
   2765          /*******************************************************************************
   2766          * Function Name  : TIM_SetClockDivision
   2767          * Description    : Sets the TIMx Clock Division value.
   2768          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2769          *                    peripheral.
   2770          *                  - TIM_CKD: specifies the clock division value.
   2771          *                    This parameter can be one of the following value:
   2772          *                       - TIM_CKD_DIV1: TDTS = Tck_tim
   2773          *                       - TIM_CKD_DIV2: TDTS = 2*Tck_tim
   2774          *                       - TIM_CKD_DIV4: TDTS = 4*Tck_tim
   2775          * Output         : None
   2776          * Return         : None
   2777          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2778          void TIM_SetClockDivision(TIM_TypeDef* TIMx, u16 TIM_CKD)
   2779          {
   2780            /* Check the parameters */
   2781            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2782            assert_param(IS_TIM_CKD_DIV(TIM_CKD));
   2783          
   2784            /* Reset the CKD Bits */
   2785            TIMx->CR1 &= CR1_CKD_Mask;
   \                     TIM_SetClockDivision:
   \   00000000   0x8802             LDRH     R2,[R0, #+0]
   \   00000002   0xB2D2             UXTB     R2,R2
   \   00000004                      REQUIRE ?Subroutine3
   \   00000004                      ;; // Fall through to label ?Subroutine3
   2786          
   2787            /* Set the CKD value */
   2788            TIMx->CR1 |= TIM_CKD;
   2789          }
   2790          /*******************************************************************************
   2791          * Function Name  : TIM_GetCapture1
   2792          * Description    : Gets the TIMx Input Capture 1 value.
   2793          * Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2794          *                   peripheral.
   2795          * Output         : None
   2796          * Return         : Capture Compare 1 Register value.
   2797          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2798          u16 TIM_GetCapture1(TIM_TypeDef* TIMx)
   2799          {
   2800            /* Check the parameters */
   2801            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2802          
   2803            /* Get the Capture 1 Register value */
   2804            return TIMx->CCR1;
   \                     TIM_GetCapture1:
   \   00000000   0x8E80             LDRH     R0,[R0, #+52]
   \   00000002   0x4770             BX       LR               ;; return
   2805          }
   2806          
   2807          /*******************************************************************************
   2808          * Function Name  : TIM_GetCapture2
   2809          * Description    : Gets the TIMx Input Capture 2 value.
   2810          * Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2811          *                   peripheral.
   2812          * Output         : None
   2813          * Return         : Capture Compare 2 Register value.
   2814          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2815          u16 TIM_GetCapture2(TIM_TypeDef* TIMx)
   2816          {
   2817            /* Check the parameters */
   2818            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2819          
   2820            /* Get the Capture 2 Register value */
   2821            return TIMx->CCR2;
   \                     TIM_GetCapture2:
   \   00000000   0x8F00             LDRH     R0,[R0, #+56]
   \   00000002   0x4770             BX       LR               ;; return
   2822          }
   2823          
   2824          /*******************************************************************************
   2825          * Function Name  : TIM_GetCapture3
   2826          * Description    : Gets the TIMx Input Capture 3 value.
   2827          * Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2828          *                   peripheral.
   2829          * Output         : None
   2830          * Return         : Capture Compare 3 Register value.
   2831          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2832          u16 TIM_GetCapture3(TIM_TypeDef* TIMx)
   2833          {
   2834            /* Check the parameters */
   2835            assert_param(IS_TIM_123458_PERIPH(TIMx)); 
   2836          
   2837            /* Get the Capture 3 Register value */
   2838            return TIMx->CCR3;
   \                     TIM_GetCapture3:
   \   00000000   0x8F80             LDRH     R0,[R0, #+60]
   \   00000002   0x4770             BX       LR               ;; return
   2839          }
   2840          
   2841          /*******************************************************************************
   2842          * Function Name  : TIM_GetCapture4
   2843          * Description    : Gets the TIMx Input Capture 4 value.
   2844          * Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   2845          *                   peripheral.
   2846          * Output         : None
   2847          * Return         : Capture Compare 4 Register value.
   2848          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2849          u16 TIM_GetCapture4(TIM_TypeDef* TIMx)
   2850          {
   2851            /* Check the parameters */
   2852            assert_param(IS_TIM_123458_PERIPH(TIMx));
   2853          
   2854            /* Get the Capture 4 Register value */
   2855            return TIMx->CCR4;
   \                     TIM_GetCapture4:
   \   00000000   0xF8B0 0x0040      LDRH     R0,[R0, #+64]
   \   00000004   0x4770             BX       LR               ;; return
   2856          }
   2857          
   2858          /*******************************************************************************
   2859          * Function Name  : TIM_GetCounter
   2860          * Description    : Gets the TIMx Counter value.
   2861          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   2862          * Output         : None
   2863          * Return         : Counter Register value.
   2864          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2865          u16 TIM_GetCounter(TIM_TypeDef* TIMx)
   2866          {
   2867            /* Check the parameters */
   2868            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2869          
   2870            /* Get the Counter Register value */
   2871            return TIMx->CNT;
   \                     TIM_GetCounter:
   \   00000000   0x8C80             LDRH     R0,[R0, #+36]
   \   00000002   0x4770             BX       LR               ;; return
   2872          }
   2873          
   2874          /*******************************************************************************
   2875          * Function Name  : TIM_GetPrescaler
   2876          * Description    : Gets the TIMx Prescaler value.
   2877          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   2878          * Output         : None
   2879          * Return         : Prescaler Register value.
   2880          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2881          u16 TIM_GetPrescaler(TIM_TypeDef* TIMx)
   2882          {
   2883            /* Check the parameters */
   2884            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2885          
   2886            /* Get the Prescaler Register value */
   2887            return TIMx->PSC;
   \                     TIM_GetPrescaler:
   \   00000000   0x8D00             LDRH     R0,[R0, #+40]
   \   00000002   0x4770             BX       LR               ;; return
   2888          }
   2889          
   2890          /*******************************************************************************
   2891          * Function Name  : TIM_GetFlagStatus
   2892          * Description    : Checks whether the specified TIM flag is set or not.
   2893          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   2894          *                  - TIM_FLAG: specifies the flag to check.
   2895          *                    This parameter can be one of the following values:
   2896          *                       - TIM_FLAG_Update: TIM update Flag
   2897          *                       - TIM_FLAG_CC1: TIM Capture Compare 1 Flag
   2898          *                       - TIM_FLAG_CC2: TIM Capture Compare 2 Flag
   2899          *                       - TIM_FLAG_CC3: TIM Capture Compare 3 Flag
   2900          *                       - TIM_FLAG_CC4: TIM Capture Compare 4 Flag
   2901          *                       - TIM_FLAG_COM: TIM Commutation Flag
   2902          *                       - TIM_FLAG_Trigger: TIM Trigger Flag
   2903          *                       - TIM_FLAG_Break: TIM Break Flag
   2904          *                       - TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag
   2905          *                       - TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag
   2906          *                       - TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag
   2907          *                       - TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag
   2908          * Output         : None
   2909          * Return         : The new state of TIM_FLAG (SET or RESET).
   2910          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2911          FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, u16 TIM_FLAG)
   2912          { 
   2913            ITStatus bitstatus = RESET;  
   \                     TIM_GetFlagStatus:
   \   00000000   0x2200             MOVS     R2,#+0
   2914          
   2915            /* Check the parameters */
   2916            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2917            assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
   2918            assert_param(IS_TIM_PERIPH_FLAG(TIMx, TIM_FLAG));
   2919            
   2920            if ((TIMx->SR & TIM_FLAG) != (u16)RESET)
   \   00000002   0x8A00             LDRH     R0,[R0, #+16]
   \   00000004   0x4208             TST      R0,R1
   \   00000006   0xBF18             IT       NE 
   \   00000008   0x2201             MOVNE    R2,#+1
   2921            {
   2922              bitstatus = SET;
   2923            }
   2924            else
   2925            {
   2926              bitstatus = RESET;
   2927            }
   2928            return bitstatus;
   \   0000000A   0x4610             MOV      R0,R2
   \   0000000C   0x4770             BX       LR               ;; return
   2929          }
   2930          
   2931          /*******************************************************************************
   2932          * Function Name  : TIM_ClearFlag
   2933          * Description    : Clears the TIMx's pending flags.
   2934          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   2935          *                  - TIM_FLAG: specifies the flag bit to clear.
   2936          *                    This parameter can be any combination of the following values:
   2937          *                       - TIM_FLAG_Update: TIM update Flag
   2938          *                       - TIM_FLAG_CC1: TIM Capture Compare 1 Flag
   2939          *                       - TIM_FLAG_CC2: TIM Capture Compare 2 Flag
   2940          *                       - TIM_FLAG_CC3: TIM Capture Compare 3 Flag
   2941          *                       - TIM_FLAG_CC4: TIM Capture Compare 4 Flag
   2942          *                       - TIM_FLAG_COM: TIM Commutation Flag
   2943          *                       - TIM_FLAG_Trigger: TIM Trigger Flag
   2944          *                       - TIM_FLAG_Break: TIM Break Flag
   2945          *                       - TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag
   2946          *                       - TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag
   2947          *                       - TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag
   2948          *                       - TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag
   2949          * Output         : None
   2950          * Return         : None
   2951          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2952          void TIM_ClearFlag(TIM_TypeDef* TIMx, u16 TIM_FLAG)
   2953          {  
   2954            /* Check the parameters */
   2955            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2956            assert_param(IS_TIM_CLEAR_FLAG(TIMx, TIM_FLAG));
   2957            assert_param(IS_TIM_PERIPH_FLAG(TIMx, TIM_FLAG));
   2958             
   2959            /* Clear the flags */
   2960            TIMx->SR = (u16)~TIM_FLAG;
   \                     TIM_ClearFlag:
   \   00000000   0x....             B.N      ?Subroutine11
   2961          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11:
   \   00000000   0x43C9             MVNS     R1,R1
   \   00000002   0x8201             STRH     R1,[R0, #+16]
   \   00000004   0x4770             BX       LR               ;; return
   2962          
   2963          /*******************************************************************************
   2964          * Function Name  : TIM_GetITStatus
   2965          * Description    : Checks whether the TIM interrupt has occurred or not.
   2966          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   2967          *                  - TIM_IT: specifies the TIM interrupt source to check.
   2968          *                    This parameter can be one of the following values:
   2969          *                       - TIM_IT_Update: TIM update Interrupt source
   2970          *                       - TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   2971          *                       - TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   2972          *                       - TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   2973          *                       - TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   2974          *                       - TIM_IT_COM: TIM Commutation Interrupt
   2975          *                         source
   2976          *                       - TIM_IT_Trigger: TIM Trigger Interrupt source
   2977          *                       - TIM_IT_Break: TIM Break Interrupt source
   2978          * Output         : None
   2979          * Return         : The new state of the TIM_IT(SET or RESET).
   2980          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2981          ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, u16 TIM_IT)
   2982          {
   2983            ITStatus bitstatus = RESET;  
   \                     TIM_GetITStatus:
   \   00000000   0x2200             MOVS     R2,#+0
   2984            u16 itstatus = 0x0, itenable = 0x0;
   2985          
   2986            /* Check the parameters */
   2987            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2988            assert_param(IS_TIM_GET_IT(TIM_IT));
   2989            assert_param(IS_TIM_PERIPH_IT(TIMx, TIM_IT));
   2990             
   2991            itstatus = TIMx->SR & TIM_IT;
   \   00000002   0x8A03             LDRH     R3,[R0, #+16]
   2992            
   2993            itenable = TIMx->DIER & TIM_IT;
   \   00000004   0x8980             LDRH     R0,[R0, #+12]
   \   00000006   0x4008             ANDS     R0,R1,R0
   2994          
   2995            if ((itstatus != (u16)RESET) && (itenable != (u16)RESET))
   \   00000008   0x420B             TST      R3,R1
   \   0000000A   0xBF1C             ITT      NE 
   \   0000000C   0x2800             CMPNE    R0,#+0
   \   0000000E   0x2201             MOVNE    R2,#+1
   2996            {
   2997              bitstatus = SET;
   2998            }
   2999            else
   3000            {
   3001              bitstatus = RESET;
   3002            }
   3003            return bitstatus;
   \   00000010   0x4610             MOV      R0,R2
   \   00000012   0x4770             BX       LR               ;; return
   3004          }
   3005          
   3006          /*******************************************************************************
   3007          * Function Name  : TIM_ClearITPendingBit
   3008          * Description    : Clears the TIMx's interrupt pending bits.
   3009          * Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
   3010          *                  - TIM_IT: specifies the pending bit to clear.
   3011          *                    This parameter can be any combination of the following values:
   3012          *                       - TIM_IT_Update: TIM1 update Interrupt source
   3013          *                       - TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   3014          *                       - TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   3015          *                       - TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   3016          *                       - TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   3017          *                       - TIM_IT_COM: TIM Commutation Interrupt
   3018          *                         source
   3019          *                       - TIM_IT_Trigger: TIM Trigger Interrupt source
   3020          *                       - TIM_IT_Break: TIM Break Interrupt source
   3021          * Output         : None
   3022          * Return         : None
   3023          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   3024          void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, u16 TIM_IT)
   \                     TIM_ClearITPendingBit:
   \   00000000   0xBF00             Nop      
   3025          {
   3026            /* Check the parameters */
   3027            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   3028            assert_param(IS_TIM_PERIPH_IT(TIMx, TIM_IT));
   3029          
   3030            /* Clear the IT pending Bit */
   3031            TIMx->SR = (u16)~TIM_IT;
   \   00000002                      REQUIRE ?Subroutine11
   \   00000002                      ;; // Fall through to label ?Subroutine11

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x40000400         DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x40000800         DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x40000C00         DC32     0x40000c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x40001000         DC32     0x40001000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x40001400         DC32     0x40001400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x40012C00         DC32     0x40012c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x40013400         DC32     0x40013400
   3032          }
   3033          
   3034          /*******************************************************************************
   3035          * Function Name  : TI1_Config
   3036          * Description    : Configure the TI1 as Input.
   3037          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   3038          *                    peripheral.
   3039          *                  - TIM_ICPolarity : The Input Polarity.
   3040          *                    This parameter can be one of the following values:
   3041          *                       - TIM_ICPolarity_Rising
   3042          *                       - TIM_ICPolarity_Falling
   3043          *                  - TIM_ICSelection: specifies the input to be used.
   3044          *                    This parameter can be one of the following values:
   3045          *                       - TIM_ICSelection_DirectTI: TIM Input 1 is selected to
   3046          *                         be connected to IC1.
   3047          *                       - TIM_ICSelection_IndirectTI: TIM Input 1 is selected to
   3048          *                         be connected to IC2.
   3049          *                       - TIM_ICSelection_TRC: TIM Input 1 is selected to be
   3050          *                         connected to TRC.
   3051          *                  - TIM_ICFilter: Specifies the Input Capture Filter.
   3052          *                    This parameter must be a value between 0x00 and 0x0F.
   3053          * Output         : None
   3054          * Return         : None
   3055          *******************************************************************************/
   3056          static void TI1_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
   3057                                 u16 TIM_ICFilter)
   3058          {
   3059            u16 tmpccmr1 = 0, tmpccer = 0;
   3060          
   3061            /* Disable the Channel 1: Reset the CC1E Bit */
   3062            TIMx->CCER &= CCER_CC1E_Reset;
   3063          
   3064            tmpccmr1 = TIMx->CCMR1;
   3065            tmpccer = TIMx->CCER;
   3066          
   3067            /* Select the Input and set the filter */
   3068            tmpccmr1 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
   3069            tmpccmr1 |= TIM_ICSelection | (u16)(TIM_ICFilter << 4);
   3070          
   3071            /* Select the Polarity and set the CC1E Bit */
   3072            tmpccer &= CCER_CC1P_Reset;
   3073            tmpccer |= TIM_ICPolarity | CCER_CC1E_Set;
   3074          
   3075            /* Write to TIMx CCMR1 and CCER registers */
   3076            TIMx->CCMR1 = tmpccmr1;
   3077            TIMx->CCER = tmpccer;
   3078          }
   3079          
   3080          /*******************************************************************************
   3081          * Function Name  : TI2_Config
   3082          * Description    : Configure the TI2 as Input.
   3083          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   3084          *                    peripheral.
   3085          *                  - TIM_ICPolarity : The Input Polarity.
   3086          *                    This parameter can be one of the following values:
   3087          *                       - TIM_ICPolarity_Rising
   3088          *                       - TIM_ICPolarity_Falling
   3089          *                  - TIM_ICSelection: specifies the input to be used.
   3090          *                    This parameter can be one of the following values:
   3091          *                       - TIM_ICSelection_DirectTI: TIM Input 2 is selected to
   3092          *                         be connected to IC2.
   3093          *                       - TIM_ICSelection_IndirectTI: TIM Input 2 is selected to
   3094          *                         be connected to IC1.
   3095          *                       - TIM_ICSelection_TRC: TIM Input 2 is selected to be
   3096          *                         connected to TRC.
   3097          *                  - TIM_ICFilter: Specifies the Input Capture Filter.
   3098          *                    This parameter must be a value between 0x00 and 0x0F.
   3099          * Output         : None
   3100          * Return         : None
   3101          *******************************************************************************/
   3102          static void TI2_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
   3103                                 u16 TIM_ICFilter)
   3104          {
   3105            u16 tmpccmr1 = 0, tmpccer = 0, tmp = 0;
   3106          
   3107            /* Disable the Channel 2: Reset the CC2E Bit */
   3108            TIMx->CCER &= CCER_CC2E_Reset;
   3109          
   3110            tmpccmr1 = TIMx->CCMR1;
   3111            tmpccer = TIMx->CCER;
   3112            tmp = (u16)(TIM_ICPolarity << 4);
   3113          
   3114            /* Select the Input and set the filter */
   3115            tmpccmr1 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
   3116            tmpccmr1 |= (u16)(TIM_ICFilter << 12);
   3117            tmpccmr1 |= (u16)(TIM_ICSelection << 8);
   3118          
   3119            /* Select the Polarity and set the CC2E Bit */
   3120            tmpccer &= CCER_CC2P_Reset;
   3121            tmpccer |=  tmp | CCER_CC2E_Set;
   3122          
   3123            /* Write to TIMx CCMR1 and CCER registers */
   3124            TIMx->CCMR1 = tmpccmr1 ;
   3125            TIMx->CCER = tmpccer;
   3126          }
   3127          
   3128          /*******************************************************************************
   3129          * Function Name  : TI3_Config
   3130          * Description    : Configure the TI3 as Input.
   3131          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   3132          *                    peripheral.
   3133          *                  - TIM_ICPolarity : The Input Polarity.
   3134          *                    This parameter can be one of the following values:
   3135          *                       - TIM_ICPolarity_Rising
   3136          *                       - TIM_ICPolarity_Falling
   3137          *                  - TIM_ICSelection: specifies the input to be used.
   3138          *                    This parameter can be one of the following values:
   3139          *                       - TIM_ICSelection_DirectTI: TIM Input 3 is selected to
   3140          *                         be connected to IC3.
   3141          *                       - TIM_ICSelection_IndirectTI: TIM Input 3 is selected to
   3142          *                         be connected to IC4.
   3143          *                       - TIM_ICSelection_TRC: TIM Input 3 is selected to be
   3144          *                         connected to TRC.
   3145          *                  - TIM_ICFilter: Specifies the Input Capture Filter.
   3146          *                    This parameter must be a value between 0x00 and 0x0F.
   3147          * Output         : None
   3148          * Return         : None
   3149          *******************************************************************************/
   3150          static void TI3_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
   3151                                 u16 TIM_ICFilter)
   3152          {
   3153            u16 tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   3154          
   3155            /* Disable the Channel 3: Reset the CC3E Bit */
   3156            TIMx->CCER &= CCER_CC3E_Reset;
   3157          
   3158            tmpccmr2 = TIMx->CCMR2;
   3159            tmpccer = TIMx->CCER;
   3160            tmp = (u16)(TIM_ICPolarity << 8);
   3161          
   3162            /* Select the Input and set the filter */
   3163            tmpccmr2 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
   3164            tmpccmr2 |= TIM_ICSelection | (u16)(TIM_ICFilter << 4);
   3165          
   3166            /* Select the Polarity and set the CC3E Bit */
   3167            tmpccer &= CCER_CC3P_Reset;
   3168            tmpccer |= tmp | CCER_CC3E_Set;
   3169          
   3170            /* Write to TIMx CCMR2 and CCER registers */
   3171            TIMx->CCMR2 = tmpccmr2;
   3172            TIMx->CCER = tmpccer;
   3173          }
   3174          
   3175          /*******************************************************************************
   3176          * Function Name  : TI4_Config
   3177          * Description    : Configure the TI1 as Input.
   3178          * Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
   3179          *                    peripheral.
   3180          *                  - TIM_ICPolarity : The Input Polarity.
   3181          *                    This parameter can be one of the following values:
   3182          *                       - TIM_ICPolarity_Rising
   3183          *                       - TIM_ICPolarity_Falling
   3184          *                  - TIM_ICSelection: specifies the input to be used.
   3185          *                    This parameter can be one of the following values:
   3186          *                       - TIM_ICSelection_DirectTI: TIM Input 4 is selected to
   3187          *                         be connected to IC4.
   3188          *                       - TIM_ICSelection_IndirectTI: TIM Input 4 is selected to
   3189          *                         be connected to IC3.
   3190          *                       - TIM_ICSelection_TRC: TIM Input 4 is selected to be
   3191          *                         connected to TRC.
   3192          *                  - TIM_ICFilter: Specifies the Input Capture Filter.
   3193          *                    This parameter must be a value between 0x00 and 0x0F.
   3194          * Output         : None
   3195          * Return         : None
   3196          *******************************************************************************/
   3197          static void TI4_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
   3198                                 u16 TIM_ICFilter)
   3199          {
   3200            u16 tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   3201          
   3202            /* Disable the Channel 4: Reset the CC4E Bit */
   3203            TIMx->CCER &= CCER_CC4E_Reset;
   3204          
   3205            tmpccmr2 = TIMx->CCMR2;
   3206            tmpccer = TIMx->CCER;
   3207            tmp = (u16)(TIM_ICPolarity << 12);
   3208          
   3209            /* Select the Input and set the filter */
   3210            tmpccmr2 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
   3211            tmpccmr2 |= (u16)(TIM_ICSelection << 8) | (u16)(TIM_ICFilter << 12);
   3212          
   3213            /* Select the Polarity and set the CC4E Bit */
   3214            tmpccer &= CCER_CC4P_Reset;
   3215            tmpccer |= tmp | CCER_CC4E_Set;
   3216          
   3217            /* Write to TIMx CCMR2 and CCER registers */
   3218            TIMx->CCMR2 = tmpccmr2;
   3219            TIMx->CCER = tmpccer ;
   3220          }
   3221          
   3222          /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  TIM_ARRPreloadConfig
        0  TIM_BDTRConfig
        0  TIM_BDTRStructInit
        0  TIM_CCPreloadControl
        0  TIM_CCxCmd
        0  TIM_CCxNCmd
        0  TIM_ClearFlag
        0  TIM_ClearITPendingBit
        0  TIM_ClearOC1Ref
        0  TIM_ClearOC2Ref
        0  TIM_ClearOC3Ref
        0  TIM_ClearOC4Ref
        0  TIM_Cmd
        0  TIM_CounterModeConfig
        0  TIM_CtrlPWMOutputs
        0  TIM_DMACmd
        0  TIM_DMAConfig
        8  TIM_DeInit
              0 -> RCC_APB1PeriphResetCmd
              8 -> RCC_APB1PeriphResetCmd
              0 -> RCC_APB2PeriphResetCmd
              8 -> RCC_APB2PeriphResetCmd
        0  TIM_ETRClockMode1Config
        0  TIM_ETRClockMode2Config
        0  TIM_ETRConfig
       16  TIM_EncoderInterfaceConfig
        0  TIM_ForcedOC1Config
        0  TIM_ForcedOC2Config
        0  TIM_ForcedOC3Config
        0  TIM_ForcedOC4Config
        0  TIM_GenerateEvent
        0  TIM_GetCapture1
        0  TIM_GetCapture2
        0  TIM_GetCapture3
        0  TIM_GetCapture4
        0  TIM_GetCounter
        0  TIM_GetFlagStatus
        0  TIM_GetITStatus
        0  TIM_GetPrescaler
       24  TIM_ICInit
              0 -> TIM_SetIC1Prescaler
              0 -> TIM_SetIC2Prescaler
              0 -> TIM_SetIC3Prescaler
              0 -> TIM_SetIC4Prescaler
        0  TIM_ICStructInit
        0  TIM_ITConfig
        0  TIM_ITRxExternalClockConfig
        0  TIM_InternalClockConfig
        0  TIM_OC1FastConfig
        8  TIM_OC1Init
        0  TIM_OC1NPolarityConfig
        0  TIM_OC1PolarityConfig
        0  TIM_OC1PreloadConfig
        0  TIM_OC2FastConfig
       12  TIM_OC2Init
        0  TIM_OC2NPolarityConfig
        0  TIM_OC2PolarityConfig
        0  TIM_OC2PreloadConfig
        0  TIM_OC3FastConfig
       12  TIM_OC3Init
        0  TIM_OC3NPolarityConfig
        0  TIM_OC3PolarityConfig
        0  TIM_OC3PreloadConfig
        0  TIM_OC4FastConfig
       12  TIM_OC4Init
        0  TIM_OC4PolarityConfig
        0  TIM_OC4PreloadConfig
        0  TIM_OCStructInit
       24  TIM_PWMIConfig
              0 -> TIM_SetIC1Prescaler
             24 -> TIM_SetIC1Prescaler
              0 -> TIM_SetIC2Prescaler
             24 -> TIM_SetIC2Prescaler
        0  TIM_PrescalerConfig
        0  TIM_SelectCCDMA
        0  TIM_SelectCOM
        0  TIM_SelectHallSensor
        0  TIM_SelectInputTrigger
        0  TIM_SelectMasterSlaveMode
        4  TIM_SelectOCxM
        0  TIM_SelectOnePulseMode
        0  TIM_SelectOutputTrigger
        0  TIM_SelectSlaveMode
        0  TIM_SetAutoreload
        0  TIM_SetClockDivision
        0  TIM_SetCompare1
        0  TIM_SetCompare2
        0  TIM_SetCompare3
        0  TIM_SetCompare4
        0  TIM_SetCounter
        0  TIM_SetIC1Prescaler
        0  TIM_SetIC2Prescaler
        0  TIM_SetIC3Prescaler
        0  TIM_SetIC4Prescaler
       12  TIM_TIxExternalClockConfig
        0  TIM_TimeBaseInit
        0  TIM_TimeBaseStructInit
        0  TIM_UpdateDisableConfig
        0  TIM_UpdateRequestConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
      22  ?Subroutine0
      12  ?Subroutine1
       8  ?Subroutine10
       6  ?Subroutine11
       6  ?Subroutine12
      10  ?Subroutine2
      10  ?Subroutine3
      10  ?Subroutine4
      10  ?Subroutine5
      10  ?Subroutine6
      10  ?Subroutine7
       8  ?Subroutine8
       8  ?Subroutine9
      20  TIM_ARRPreloadConfig
      28  TIM_BDTRConfig
      18  TIM_BDTRStructInit
      20  TIM_CCPreloadControl
       8  TIM_CCxCmd
       6  TIM_CCxNCmd
       2  TIM_ClearFlag
       2  TIM_ClearITPendingBit
       8  TIM_ClearOC1Ref
       8  TIM_ClearOC2Ref
       8  TIM_ClearOC3Ref
       8  TIM_ClearOC4Ref
      20  TIM_Cmd
      10  TIM_CounterModeConfig
      16  TIM_CtrlPWMOutputs
      16  TIM_DMACmd
       8  TIM_DMAConfig
     184  TIM_DeInit
      30  TIM_ETRClockMode1Config
      30  TIM_ETRClockMode2Config
      22  TIM_ETRConfig
      50  TIM_EncoderInterfaceConfig
       8  TIM_ForcedOC1Config
       8  TIM_ForcedOC2Config
       8  TIM_ForcedOC3Config
       8  TIM_ForcedOC4Config
       4  TIM_GenerateEvent
       4  TIM_GetCapture1
       4  TIM_GetCapture2
       4  TIM_GetCapture3
       6  TIM_GetCapture4
       4  TIM_GetCounter
      14  TIM_GetFlagStatus
      20  TIM_GetITStatus
       4  TIM_GetPrescaler
     220  TIM_ICInit
      18  TIM_ICStructInit
      16  TIM_ITConfig
      22  TIM_ITRxExternalClockConfig
      12  TIM_InternalClockConfig
       8  TIM_OC1FastConfig
     102  TIM_OC1Init
       6  TIM_OC1NPolarityConfig
       8  TIM_OC1PolarityConfig
       6  TIM_OC1PreloadConfig
       8  TIM_OC2FastConfig
     108  TIM_OC2Init
       6  TIM_OC2NPolarityConfig
       8  TIM_OC2PolarityConfig
       6  TIM_OC2PreloadConfig
       8  TIM_OC3FastConfig
     102  TIM_OC3Init
       6  TIM_OC3NPolarityConfig
       8  TIM_OC3PolarityConfig
       6  TIM_OC3PreloadConfig
       8  TIM_OC4FastConfig
      84  TIM_OC4Init
      16  TIM_OC4PolarityConfig
       6  TIM_OC4PreloadConfig
      20  TIM_OCStructInit
     262  TIM_PWMIConfig
       6  TIM_PrescalerConfig
      20  TIM_SelectCCDMA
      20  TIM_SelectCOM
      20  TIM_SelectHallSensor
      10  TIM_SelectInputTrigger
       6  TIM_SelectMasterSlaveMode
      84  TIM_SelectOCxM
      10  TIM_SelectOnePulseMode
      18  TIM_SelectOutputTrigger
       8  TIM_SelectSlaveMode
       4  TIM_SetAutoreload
       4  TIM_SetClockDivision
       4  TIM_SetCompare1
       4  TIM_SetCompare2
       4  TIM_SetCompare3
       6  TIM_SetCompare4
       4  TIM_SetCounter
      14  TIM_SetIC1Prescaler
      14  TIM_SetIC2Prescaler
      14  TIM_SetIC3Prescaler
      14  TIM_SetIC4Prescaler
     118  TIM_TIxExternalClockConfig
      52  TIM_TimeBaseInit
      18  TIM_TimeBaseStructInit
      20  TIM_UpdateDisableConfig
      20  TIM_UpdateRequestConfig

 
 2 372 bytes in section .text
 
 2 372 bytes of CODE memory

Errors: none
Warnings: none
