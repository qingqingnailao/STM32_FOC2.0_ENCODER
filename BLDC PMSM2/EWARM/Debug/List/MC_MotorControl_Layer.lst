###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.1.53790/W32 for ARM     24/Feb/2014  19:26:38 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\stm32\BLDC PMSM2\src\MC_MotorControl_Layer.c          #
#    Command line =  "D:\stm32\BLDC PMSM2\src\MC_MotorControl_Layer.c" -D     #
#                    VECT_TAB_FLASH -lCN "D:\stm32\BLDC                       #
#                    PMSM2\EWARM\Debug\List\" --diag_error Pe068,Pe069 -o     #
#                    "D:\stm32\BLDC PMSM2\EWARM\Debug\Obj\" --debug           #
#                    --endian=little --cpu=Cortex-M3 --fpu=None               #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 6.4\arm\INC\c\DLib_Config_Normal.h" -I         #
#                    "D:\stm32\BLDC PMSM2\EWARM\..\" -I "D:\stm32\BLDC        #
#                    PMSM2\EWARM\..\..\STM32F10XFWLIB\inc\" -I                #
#                    "D:\stm32\BLDC PMSM2\EWARM\..\inc\" -Oh                  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  D:\stm32\BLDC PMSM2\EWARM\Debug\List\MC_MotorControl_Lay #
#                    er.lst                                                   #
#    Object file  =  D:\stm32\BLDC PMSM2\EWARM\Debug\Obj\MC_MotorControl_Laye #
#                    r.o                                                      #
#                                                                             #
#                                                                             #
###############################################################################

D:\stm32\BLDC PMSM2\src\MC_MotorControl_Layer.c
      1          /******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
      2          * File Name          : MC_MotorControl_Layer.c
      3          * Author             : IMS Systems Lab  
      4          * Date First Issued  : 21/11/07
      5          * Description        : This file contains the function implementing the motor 
      6          *                      control layer 
      7          ********************************************************************************
      8          * History:
      9          * 21/11/07 v1.0
     10          * 29/05/08 v2.0
     11          ********************************************************************************
     12          * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     13          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     14          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     15          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     16          * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     17          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     18          *
     19          * THIS SOURCE CODE IS PROTECTED BY A LICENSE.
     20          * FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED
     21          * IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
     22          *******************************************************************************/
     23          
     24          /* Includes ------------------------------------------------------------------*/
     25          #include "stm32f10x_lib.h"
     26          #include "stm32f10x_MClib.h"
     27          #include "stm32f10x_type.h"
     28          #include "MC_Globals.h"
     29          
     30          /* Private typedef -----------------------------------------------------------*/
     31          /* Private define ------------------------------------------------------------*/
     32          #define BRK_GPIO GPIOC
     33          #define BRK_PIN GPIO_Pin_9
     34          
     35          #define FAULT_STATE_MIN_PERMANENCY 600 //0.5msec unit
     36          
     37          #define BUS_AV_ARRAY_SIZE  (u8)64  //number of averaged acquisitions
     38          #define T_AV_ARRAY_SIZE  (u16)2048  //number of averaged acquisitions
     39          
     40          #define BUSV_CONVERSION (u16) (3.32/(BUS_ADC_CONV_RATIO)) 
     41          #define TEMP_CONVERSION (u8)  195
     42          
     43          #define VOLT_ARRAY_INIT (u16)(UNDERVOLTAGE_THRESHOLD+ OVERVOLTAGE_THRESHOLD)/2
     44          #define TEMP_ARRAY_INIT (u16)0
     45          
     46          #define BRAKE_GPIO_PORT       GPIOD
     47          #define BRAKE_GPIO_PIN        GPIO_Pin_13
     48          
     49          #define NTC_THRESHOLD (u16) ((32768*(NTC_THRESHOLD_C - 14))/TEMP_CONVERSION)
     50          #define NTC_HYSTERIS  (u16) ((32768*(NTC_THRESHOLD_C - NTC_HYSTERIS_C - 14))\
     51                                                                         /TEMP_CONVERSION)
     52          
     53          /* Private macro -------------------------------------------------------------*/
     54          /* Private functions ---------------------------------------------------------*/
     55          void MCL_Reset_PID_IntegralTerms(void);
     56          /* Private variables ---------------------------------------------------------*/
     57          

   \                                 In section .bss, align 4
     58          static s16 h_BusV_Average;
   \                     h_BusV_Average:
   \   00000000                      DS8 2
     59          static u32 w_Temp_Average;
     60          
     61          u16 h_ADCBusvolt;
   \                     h_ADCBusvolt:
   \   00000002                      DS8 2
     62          u16 h_ADCTemp;
   \                     h_ADCTemp:
   \   00000004                      DS8 2
   \   00000006                      DS8 2
   \   00000008                      DS8 4
     63            
     64          /*******************************************************************************
     65          * Function Name  : MCL_Init
     66          * Description    : This function implements the motor control initialization to 
     67          *                  be performed at each motor start-up 
     68          * Input          : None
     69          * Output         : None
     70          * Return         : None
     71          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     72          void MCL_Init(void)
     73          {
   \                     MCL_Init:
   \   00000000   0xB580             PUSH     {R7,LR}
     74          // reset PID's integral values
     75              MCL_Reset_PID_IntegralTerms();
   \   00000002   0x.... 0x....      BL       MCL_Reset_PID_IntegralTerms
     76              FOC_Init();
   \   00000006   0x.... 0x....      BL       FOC_Init
     77              
     78          #ifdef ENCODER
     79              ENC_Clear_Speed_Buffer();
     80             #ifdef OBSERVER_GAIN_TUNING
     81                STO_Init();
     82             #endif
     83          #elif defined HALL_SENSORS
     84              HALL_InitHallMeasure();
     85              HALL_Init_Electrical_Angle();
     86             #ifdef OBSERVER_GAIN_TUNING
     87                STO_Init();
     88             #endif
     89          #elif defined NO_SPEED_SENSORS
     90              STO_Init();
   \   0000000A   0x.... 0x....      BL       STO_Init
     91             #ifdef VIEW_ENCODER_FEEDBACK
     92                ENC_Clear_Speed_Buffer();
     93             #elif defined VIEW_HALL_FEEDBACK
     94                HALL_InitHallMeasure();
     95                HALL_Init_Electrical_Angle();
     96             #endif
     97          #endif    
     98                  
     99          #ifdef THREE_SHUNT                    
    100              SVPWM_3ShuntCurrentReadingCalibration();
   \   0000000E   0x.... 0x....      BL       SVPWM_3ShuntCurrentReadingCalibration
    101          #elif defined ICS_SENSORS
    102              SVPWM_IcsCurrentReadingCalibration();
    103          #elif defined SINGLE_SHUNT
    104              SVPWM_1ShuntCurrentReadingCalibration();
    105          #endif  
    106                
    107              Stat_Volt_alfa_beta.qV_Component1 = 0;
   \   00000012   0x....             LDR.N    R0,??DataTable10
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x8001             STRH     R1,[R0, #+0]
    108              Stat_Volt_alfa_beta.qV_Component2 = 0;             
   \   00000018   0x8041             STRH     R1,[R0, #+2]
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x9000             STR      R0,[SP, #+0]
    109              CALC_SVPWM(Stat_Volt_alfa_beta);
   \   0000001E   0x.... 0x....      BL       SVPWM_3ShuntCalcDutyCycles
    110              hTorque_Reference = PID_TORQUE_REFERENCE;   
   \   00000022   0x....             LDR.N    R0,??DataTable10_1
   \   00000024   0xF44F 0x61B4      MOV      R1,#+1440
   \   00000028   0x8001             STRH     R1,[R0, #+0]
    111           
    112              //It generates for 2 msec a 50% duty cycle on the three phases to load Boot 
    113              //capacitance of high side drivers
    114              TB_Set_StartUp_Timeout(4); 
   \   0000002A   0x2004             MOVS     R0,#+4
   \   0000002C   0x.... 0x....      BL       TB_Set_StartUp_Timeout
    115              
    116              /* Main PWM Output Enable */
    117              TIM_CtrlPWMOutputs(TIM1,ENABLE);
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40012c00
   \   00000034   0x.... 0x....      BL       TIM_CtrlPWMOutputs
    118            
    119              while(!TB_StartUp_Timeout_IsElapsed())
   \                     ??MCL_Init_0:
   \   00000038   0x.... 0x....      BL       TB_StartUp_Timeout_IsElapsed
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD0FB             BEQ.N    ??MCL_Init_0
    120              {
    121              }  
    122          #ifdef THREE_SHUNT    
    123              // Enable the Adv Current Reading during Run state
    124              SVPWM_3ShuntAdvCurrentReading(ENABLE);
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x.... 0x....      BL       SVPWM_3ShuntAdvCurrentReading
    125          #endif  
    126          #ifdef SINGLE_SHUNT    
    127              // Enable the Adv Current Reading during Run state
    128              SVPWM_1ShuntAdvCurrentReading(ENABLE);
    129          #endif
    130          }
   \   00000046   0xBD01             POP      {R0,PC}          ;; return
    131          
    132          
    133          /*******************************************************************************
    134          * Function Name  : MCL_Init_Arrays
    135          * Description    : This function initializes array to avoid erroneous Fault 
    136          *                  detection after a reswt
    137          * Input          : None
    138          * Output         : None
    139          * Return         : None
    140          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    141          void MCL_Init_Arrays(void)
    142          {   
    143              w_Temp_Average = TEMP_ARRAY_INIT;
   \                     MCL_Init_Arrays:
   \   00000000   0x....             LDR.N    R0,??DataTable10_3
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x6081             STR      R1,[R0, #+8]
    144              h_BusV_Average = VOLT_ARRAY_INIT;   
   \   00000006   0xF245 0x7145      MOVW     R1,#+22341
   \   0000000A   0x8001             STRH     R1,[R0, #+0]
    145          }
   \   0000000C   0x4770             BX       LR               ;; return
    146          
    147          
    148          /*******************************************************************************
    149          * Function Name  : MCL_ChkPowerStage
    150          * Description    : This function check for power stage working conditions
    151          * Input          : None
    152          * Output         : None
    153          * Return         : None
    154          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    155          void MCL_ChkPowerStage(void) 
    156          {
   \                     MCL_ChkPowerStage:
   \   00000000   0xB580             PUSH     {R7,LR}
    157              //  check over temperature of power stage
    158              if (MCL_Chk_OverTemp() == TRUE) 
   \   00000002   0x.... 0x....      BL       MCL_Chk_OverTemp
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xBF04             ITT      EQ 
   \   0000000A   0xF44F 0x7080      MOVEQ    R0,#+256
   \   0000000E   0x.... 0x....      BLEQ     MCL_SetFault
    159              {
    160                MCL_SetFault(OVERHEAT);
    161              }   
    162              //  check bus under voltage 
    163              if (MCL_Chk_BusVolt() == UNDER_VOLT) 
   \   00000012   0x.... 0x....      BL       MCL_Chk_BusVolt
   \   00000016   0x2802             CMP      R0,#+2
   \   00000018   0xD104             BNE.N    ??MCL_ChkPowerStage_0
    164              {
    165                MCL_SetFault(UNDER_VOLTAGE);
   \   0000001A   0xF44F 0x6000      MOV      R0,#+2048
   \   0000001E   0xE8BD 0x4002      POP      {R1,LR}
   \   00000022   0x....             B.N      MCL_SetFault
    166              }
    167              // bus over voltage is detected by analog watchdog
    168          }
   \                     ??MCL_ChkPowerStage_0:
   \   00000024   0xBD01             POP      {R0,PC}          ;; return
    169          
    170          /*******************************************************************************
    171          * Function Name  : MCL_SetFault() 
    172          * Description    : This function manage faults occurences
    173          * Input          : Fault type
    174          * Output         : None
    175          * Return         : None
    176          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    177          void MCL_SetFault(u16 hFault_type)
    178          {
   \                     MCL_SetFault:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    179            TB_Set_Delay_500us(FAULT_STATE_MIN_PERMANENCY); 
   \   00000004   0xF44F 0x7016      MOV      R0,#+600
   \   00000008   0x.... 0x....      BL       TB_Set_Delay_500us
    180            /* Main PWM Output Enable */
    181            TIM_CtrlPWMOutputs(TIM1, DISABLE);
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x....             LDR.N    R0,??DataTable10_2  ;; 0x40012c00
   \   00000010   0x.... 0x....      BL       TIM_CtrlPWMOutputs
    182            wGlobal_Flags |= hFault_type;
   \   00000014   0x....             LDR.N    R0,??DataTable10_4
   \   00000016   0x6801             LDR      R1,[R0, #+0]
   \   00000018   0x4321             ORRS     R1,R4,R1
   \   0000001A   0x6001             STR      R1,[R0, #+0]
    183            State = FAULT;
   \   0000001C   0x....             LDR.N    R0,??DataTable10_5
   \   0000001E   0x2107             MOVS     R1,#+7
   \   00000020   0x7001             STRB     R1,[R0, #+0]
    184            bMenu_index = FAULT_MENU;  
   \   00000022   0x....             LDR.N    R0,??DataTable10_6
   \   00000024   0x210F             MOVS     R1,#+15
   \   00000026   0x7001             STRB     R1,[R0, #+0]
    185            // It is required to disable AdvCurrentReading in IDLE to sample DC 
    186            // Bus Value
    187          #ifdef THREE_SHUNT
    188            SVPWM_3ShuntAdvCurrentReading(DISABLE);
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000002E   0x.... 0x....      B.W      SVPWM_3ShuntAdvCurrentReading
    189          #endif
    190          #ifdef SINGLE_SHUNT
    191            SVPWM_1ShuntAdvCurrentReading(DISABLE);
    192          #endif
    193          }
    194          
    195          /*******************************************************************************
    196          * Function Name  : MCL_ClearFault() 
    197          * Description    : This function check if the fault source is over. In case it 
    198          *                  is, it clears the related flag and return true. Otherwise it 
    199          *                  returns FALSE
    200          * Input          : Fault type
    201          * Output         : None
    202          * Return         : None
    203          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    204          bool MCL_ClearFault(void)
    205          {     
   \                     MCL_ClearFault:
   \   00000000   0xB510             PUSH     {R4,LR}
    206            if (TB_Delay_IsElapsed())
   \   00000002   0x.... 0x....      BL       TB_Delay_IsElapsed
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD039             BEQ.N    ??MCL_ClearFault_0
    207            {   
    208              if ((wGlobal_Flags & OVERHEAT) == OVERHEAT)   
   \   0000000A   0x....             LDR.N    R4,??DataTable10_4
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x05C0             LSLS     R0,R0,#+23
   \   00000010   0xD506             BPL.N    ??MCL_ClearFault_1
    209              {               
    210                if(MCL_Chk_OverTemp()== FALSE)
   \   00000012   0x.... 0x....      BL       MCL_Chk_OverTemp
   \   00000016   0xB918             CBNZ.N   R0,??MCL_ClearFault_1
    211                {
    212                  wGlobal_Flags &= ~OVERHEAT;
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0xF420 0x7080      BIC      R0,R0,#0x100
   \   0000001E   0x6020             STR      R0,[R4, #+0]
    213                }     
    214              }
    215              
    216              if ((wGlobal_Flags & OVER_VOLTAGE) == OVER_VOLTAGE)   
   \                     ??MCL_ClearFault_1:
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x0540             LSLS     R0,R0,#+21
   \   00000024   0xD506             BPL.N    ??MCL_ClearFault_2
    217              {            
    218                if(MCL_Chk_BusVolt()== NO_FAULT)
   \   00000026   0x.... 0x....      BL       MCL_Chk_BusVolt
   \   0000002A   0xB918             CBNZ.N   R0,??MCL_ClearFault_2
    219                {
    220                  wGlobal_Flags &= ~OVER_VOLTAGE;
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0xF420 0x6080      BIC      R0,R0,#0x400
   \   00000032   0x6020             STR      R0,[R4, #+0]
    221                } 
    222              }
    223              
    224              if ((wGlobal_Flags & UNDER_VOLTAGE) == UNDER_VOLTAGE)   
   \                     ??MCL_ClearFault_2:
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x0500             LSLS     R0,R0,#+20
   \   00000038   0xD506             BPL.N    ??MCL_ClearFault_3
    225              {            
    226                if(MCL_Chk_BusVolt()== NO_FAULT)
   \   0000003A   0x.... 0x....      BL       MCL_Chk_BusVolt
   \   0000003E   0xB918             CBNZ.N   R0,??MCL_ClearFault_3
    227                {
    228                  wGlobal_Flags &= ~UNDER_VOLTAGE;
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0xF420 0x6000      BIC      R0,R0,#0x800
   \   00000046   0x6020             STR      R0,[R4, #+0]
    229                } 
    230              }
    231              
    232              if ((wGlobal_Flags & OVER_CURRENT) == OVER_CURRENT)
   \                     ??MCL_ClearFault_3:
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x0580             LSLS     R0,R0,#+22
   \   0000004C   0xD509             BPL.N    ??MCL_ClearFault_4
    233              {
    234                // high level detected on emergency pin?              
    235                //It checks for a low level on MCES before re-enable PWM 
    236                //peripheral
    237                if (GPIO_ReadInputDataBit(BRK_GPIO, BRK_PIN))
   \   0000004E   0xF44F 0x7100      MOV      R1,#+512
   \   00000052   0x....             LDR.N    R0,??DataTable10_7  ;; 0x40011000
   \   00000054   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   00000058   0xB118             CBZ.N    R0,??MCL_ClearFault_4
    238                {            
    239                  wGlobal_Flags &= ~OVER_CURRENT;
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0xF420 0x7000      BIC      R0,R0,#0x200
   \   00000060   0x6020             STR      R0,[R4, #+0]
    240                }
    241              }
    242            
    243              if ((wGlobal_Flags & START_UP_FAILURE) == START_UP_FAILURE )
   \                     ??MCL_ClearFault_4:
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x0740             LSLS     R0,R0,#+29
   \   00000066   0xD503             BPL.N    ??MCL_ClearFault_5
    244              {
    245                  wGlobal_Flags &= ~START_UP_FAILURE;
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0xF020 0x0004      BIC      R0,R0,#0x4
   \   0000006E   0x6020             STR      R0,[R4, #+0]
    246              } 
    247              
    248              if ((wGlobal_Flags & SPEED_FEEDBACK) == SPEED_FEEDBACK )
   \                     ??MCL_ClearFault_5:
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x0700             LSLS     R0,R0,#+28
   \   00000074   0xD503             BPL.N    ??MCL_ClearFault_0
    249              {
    250                  wGlobal_Flags &= ~SPEED_FEEDBACK;
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0xF020 0x0008      BIC      R0,R0,#0x8
   \   0000007C   0x6020             STR      R0,[R4, #+0]
    251              } 
    252            }
    253            
    254            if (KEYS_ExportbKey() == SEL)
   \                     ??MCL_ClearFault_0:
   \   0000007E   0x.... 0x....      BL       KEYS_ExportbKey
   \   00000082   0x2801             CMP      R0,#+1
   \   00000084   0xD108             BNE.N    ??MCL_ClearFault_6
    255            {
    256              if ( (wGlobal_Flags & (OVER_CURRENT | OVERHEAT | UNDER_VOLTAGE | 
    257                                 SPEED_FEEDBACK | START_UP_FAILURE | OVER_VOLTAGE)) == 0 )       
   \   00000086   0x....             LDR.N    R0,??DataTable10_4
   \   00000088   0x6800             LDR      R0,[R0, #+0]
   \   0000008A   0xF640 0x710C      MOVW     R1,#+3852
   \   0000008E   0x4008             ANDS     R0,R1,R0
   \   00000090   0x1E40             SUBS     R0,R0,#+1
   \   00000092   0x4180             SBCS     R0,R0,R0
   \   00000094   0x0FC0             LSRS     R0,R0,#+31
    258              { 
    259                return(TRUE); 
   \   00000096   0xBD10             POP      {R4,PC}
    260              } 
    261              else
    262              {
    263                return(FALSE);
    264              }
    265            }
    266            else 
    267            {
    268              return(FALSE);
   \                     ??MCL_ClearFault_6:
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0xBD10             POP      {R4,PC}          ;; return
    269            }
    270          }
    271          
    272          /*******************************************************************************
    273          * Function Name  : MCL_Chk_OverTemp
    274          * Description    : Return TRUE if the voltage on the thermal resistor connected 
    275          *                  to channel AIN3 has reached the threshold level or if the           
    276          *                  voltage has not yet reached back the threshold level minus  
    277          *                  the hysteresis value after an overheat detection.
    278          * Input          : None
    279          * Output         : Boolean
    280          * Return         : None
    281          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    282          bool MCL_Chk_OverTemp(void)
    283          {
    284            bool bStatus;
    285             
    286            w_Temp_Average = ((T_AV_ARRAY_SIZE-1)*w_Temp_Average + h_ADCTemp)
    287                                                                        /T_AV_ARRAY_SIZE;
   \                     MCL_Chk_OverTemp:
   \   00000000   0x....             LDR.N    R0,??DataTable10_3
   \   00000002   0x6881             LDR      R1,[R0, #+8]
   \   00000004   0xEBC1 0x21C1      RSB      R1,R1,R1, LSL #+11
   \   00000008   0x8882             LDRH     R2,[R0, #+4]
   \   0000000A   0x1851             ADDS     R1,R2,R1
   \   0000000C   0x0AC9             LSRS     R1,R1,#+11
   \   0000000E   0x6081             STR      R1,[R0, #+8]
    288            
    289            if (w_Temp_Average >= NTC_THRESHOLD)    
   \   00000010   0xF641 0x6031      MOVW     R0,#+7729
   \   00000014   0x4281             CMP      R1,R0
   \   00000016   0xD205             BCS.N    ??MCL_Chk_OverTemp_0
    290            {
    291              bStatus = TRUE;
    292            }
    293            else if (w_Temp_Average >= (NTC_HYSTERIS) ) 
   \   00000018   0xF641 0x20E9      MOVW     R0,#+6889
   \   0000001C   0x4281             CMP      R1,R0
   \   0000001E   0xBF24             ITT      CS 
   \   00000020   0x....             LDRCS.N  R0,??DataTable10_4
   \   00000022   0x6800             LDRCS    R0,[R0, #+0]
    294              {
    295              if ((wGlobal_Flags & OVERHEAT) == OVERHEAT)
    296                {
    297                  bStatus = TRUE;       
    298                }
    299              else
    300                {
    301                  bStatus = FALSE;
    302                }
    303              }
    304            else 
    305              {
    306                bStatus = FALSE;
    307              }
    308          
    309            //return(bStatus);
    310            return(FALSE);
   \                     ??MCL_Chk_OverTemp_0:
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x4770             BX       LR               ;; return
    311            //温度过热，暂时屏掉
    312          }
    313          
    314          /*******************************************************************************
    315          * Function Name  : MCL_Calc_BusVolt
    316          * Description    : It measures the Bus Voltage
    317          * Input          : None
    318          * Output         : Bus voltage
    319          * Return         : None
    320          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    321          void MCL_Calc_BusVolt(void)
    322          {
    323           h_BusV_Average = ((BUS_AV_ARRAY_SIZE-1)*h_BusV_Average + h_ADCBusvolt)
    324                                                                       /BUS_AV_ARRAY_SIZE;
   \                     MCL_Calc_BusVolt:
   \   00000000   0x....             LDR.N    R0,??DataTable10_3
   \   00000002   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   00000006   0xEBC1 0x1181      RSB      R1,R1,R1, LSL #+6
   \   0000000A   0x8842             LDRH     R2,[R0, #+2]
   \   0000000C   0x1851             ADDS     R1,R2,R1
   \   0000000E   0x114A             ASRS     R2,R1,#+5
   \   00000010   0xEB01 0x6192      ADD      R1,R1,R2, LSR #+26
   \   00000014   0x1189             ASRS     R1,R1,#+6
   \   00000016   0x8001             STRH     R1,[R0, #+0]
    325          }
   \   00000018   0x4770             BX       LR               ;; return
    326          
    327          /*******************************************************************************
    328          * Function Name  : MCL_Chk_BusVolt 
    329          * Description    : Check for Bus Over Voltage
    330          * Input          : None
    331          * Output         : Boolean
    332          * Return         : None
    333          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    334          BusV_t MCL_Chk_BusVolt(void)
    335          {
    336            BusV_t baux;
    337            if (h_BusV_Average > OVERVOLTAGE_THRESHOLD)    
   \                     MCL_Chk_BusVolt:
   \   00000000   0x....             LDR.N    R0,??DataTable10_3
   \   00000002   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000006   0xF646 0x71B6      MOVW     R1,#+28598
   \   0000000A   0x4288             CMP      R0,R1
   \   0000000C   0xDB01             BLT.N    ??MCL_Chk_BusVolt_0
    338            {
    339              baux = OVER_VOLT;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x4770             BX       LR
    340            }
    341            else if (h_BusV_Average < UNDERVOLTAGE_THRESHOLD)    
   \                     ??MCL_Chk_BusVolt_0:
   \   00000012   0xF643 0x61D6      MOVW     R1,#+16086
   \   00000016   0x4288             CMP      R0,R1
   \   00000018   0xDA01             BGE.N    ??MCL_Chk_BusVolt_1
    342            {
    343              baux = UNDER_VOLT;
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0x4770             BX       LR
    344            }
    345            else 
    346            {
    347              baux = NO_FAULT; 
   \                     ??MCL_Chk_BusVolt_1:
   \   0000001E   0x2000             MOVS     R0,#+0
    348            }
    349            return ((BusV_t)baux);
   \   00000020   0x4770             BX       LR               ;; return
    350          }
    351          
    352          /*******************************************************************************
    353          * Function Name  : MCL_Get_BusVolt
    354          * Description    : Get bus voltage in s16
    355          * Input          : None
    356          * Output         : None
    357          * Return         : Bus voltage in s16 unit
    358          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    359          s16 MCL_Get_BusVolt(void)
    360          {
    361            return (h_BusV_Average);
   \                     MCL_Get_BusVolt:
   \   00000000   0x....             LDR.N    R0,??DataTable10_3
   \   00000002   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000006   0x4770             BX       LR               ;; return
    362          }
    363          
    364          /*******************************************************************************
    365          * Function Name  : MCL_Compute_BusVolt
    366          * Description    : Compute bus voltage in volt
    367          * Input          : None
    368          * Output         : Bus voltage in Volt unit
    369          * Return         : None
    370          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    371          u16 MCL_Compute_BusVolt(void)
    372          {
    373            return ((u16)((h_BusV_Average * BUSV_CONVERSION)/32768));
   \                     MCL_Compute_BusVolt:
   \   00000000   0x....             LDR.N    R0,??DataTable10_3
   \   00000002   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000006   0xEB00 0x01C0      ADD      R1,R0,R0, LSL #+3
   \   0000000A   0x0088             LSLS     R0,R1,#+2
   \   0000000C   0x1381             ASRS     R1,R0,#+14
   \   0000000E   0xEB00 0x4051      ADD      R0,R0,R1, LSR #+17
   \   00000012   0x0040             LSLS     R0,R0,#+1
   \   00000014   0x0C00             LSRS     R0,R0,#+16
   \   00000016   0x4770             BX       LR               ;; return
    374          }
    375          
    376          /*******************************************************************************
    377          * Function Name  : MCL_Compute_Temp
    378          * Description    : Compute temperature in Celsius degrees
    379          * Input          : None
    380          * Output         : temperature in Celsius degrees
    381          * Return         : None
    382          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    383          u8 MCL_Compute_Temp(void)
    384          {
    385            return ((u8)((w_Temp_Average * TEMP_CONVERSION)/32768+14));
   \                     MCL_Compute_Temp:
   \   00000000   0x....             LDR.N    R0,??DataTable10_3
   \   00000002   0x6880             LDR      R0,[R0, #+8]
   \   00000004   0x21C3             MOVS     R1,#+195
   \   00000006   0x4348             MULS     R0,R1,R0
   \   00000008   0x0BC0             LSRS     R0,R0,#+15
   \   0000000A   0x300E             ADDS     R0,R0,#+14
   \   0000000C   0xB2C0             UXTB     R0,R0
   \   0000000E   0x4770             BX       LR               ;; return
    386          }      
    387          
    388          /*******************************************************************************
    389          * Function Name  : MCL_Reset_PID_IntegralTerms
    390          * Description    : Resets flux, torque and speed PID Integral Terms
    391          * Input          : None
    392          * Output         : None
    393          * Return         : None
    394          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    395          void MCL_Reset_PID_IntegralTerms(void)
    396          {
    397            PID_Speed_InitStructure.wIntegral=0;
   \                     MCL_Reset_PID_IntegralTerms:
   \   00000000   0x....             LDR.N    R0,??DataTable10_8
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x6141             STR      R1,[R0, #+20]
    398            PID_Torque_InitStructure.wIntegral=0;
   \   00000006   0x....             LDR.N    R0,??DataTable10_9
   \   00000008   0x6141             STR      R1,[R0, #+20]
    399            PID_Flux_InitStructure.wIntegral = 0;
   \   0000000A   0x....             LDR.N    R0,??DataTable10_10
   \   0000000C   0x6141             STR      R1,[R0, #+20]
    400          }
   \   0000000E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     Stat_Volt_alfa_beta

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     hTorque_Reference

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x40012C00         DC32     0x40012c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     h_BusV_Average

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     wGlobal_Flags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x........         DC32     State

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x........         DC32     bMenu_index

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x........         DC32     PID_Speed_InitStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x........         DC32     PID_Torque_InitStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   0x........         DC32     PID_Flux_InitStructure
    401          
    402          
    403          #ifdef BRAKE_RESISTOR
    404          /*******************************************************************************
    405          * Function Name  : MCL_Brake_Init
    406          * Description    : Initialize the GPIO driving the switch for resitive brake 
    407          *                  implementation  
    408          * Input          : None
    409          * Output         : None
    410          * Return         : None
    411          *******************************************************************************/
    412          void MCL_Brake_Init(void)
    413          {  
    414            GPIO_InitTypeDef GPIO_InitStructure;
    415          
    416            /* Enable GPIOD clock */
    417            RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE);
    418            GPIO_DeInit(BRAKE_GPIO_PORT);
    419            GPIO_StructInit(&GPIO_InitStructure);
    420                            
    421            /* Configure PD.13 as Output push-pull for break feature */
    422            GPIO_InitStructure.GPIO_Pin = BRAKE_GPIO_PIN;
    423            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
    424            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    425            GPIO_Init(BRAKE_GPIO_PORT, &GPIO_InitStructure);     
    426          }
    427          
    428          /*******************************************************************************
    429          * Function Name  : MCL_Set_Brake_On
    430          * Description    : Switch on brake (set the related GPIO pin)
    431          * Input          : None
    432          * Output         : None
    433          * Return         : None
    434          *******************************************************************************/
    435          void MCL_Set_Brake_On(void)
    436          {  
    437           GPIO_SetBits(BRAKE_GPIO_PORT, BRAKE_GPIO_PIN);
    438          }
    439          
    440          /*******************************************************************************
    441          * Function Name  : MCL_Set_Brake_Off
    442          * Description    : Switch off brake (reset the related GPIO pin)
    443          * Input          : None
    444          * Output         : None
    445          * Return         : None
    446          *******************************************************************************/
    447          void MCL_Set_Brake_Off(void)
    448          {  
    449           GPIO_ResetBits(BRAKE_GPIO_PORT, BRAKE_GPIO_PIN);
    450          }
    451          
    452          #endif
    453          /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  MCL_Calc_BusVolt
        8  MCL_ChkPowerStage
             8 -> MCL_Chk_BusVolt
             8 -> MCL_Chk_OverTemp
             0 -> MCL_SetFault
             8 -> MCL_SetFault
        0  MCL_Chk_BusVolt
        0  MCL_Chk_OverTemp
        8  MCL_ClearFault
             8 -> GPIO_ReadInputDataBit
             8 -> KEYS_ExportbKey
             8 -> MCL_Chk_BusVolt
             8 -> MCL_Chk_OverTemp
             8 -> TB_Delay_IsElapsed
        0  MCL_Compute_BusVolt
        0  MCL_Compute_Temp
        0  MCL_Get_BusVolt
        8  MCL_Init
             8 -> FOC_Init
             8 -> MCL_Reset_PID_IntegralTerms
             8 -> STO_Init
             8 -> SVPWM_3ShuntAdvCurrentReading
             8 -> SVPWM_3ShuntCalcDutyCycles
             8 -> SVPWM_3ShuntCurrentReadingCalibration
             8 -> TB_Set_StartUp_Timeout
             8 -> TB_StartUp_Timeout_IsElapsed
             8 -> TIM_CtrlPWMOutputs
        0  MCL_Init_Arrays
        0  MCL_Reset_PID_IntegralTerms
        8  MCL_SetFault
             0 -> SVPWM_3ShuntAdvCurrentReading
             8 -> TB_Set_Delay_500us
             8 -> TIM_CtrlPWMOutputs


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
      26  MCL_Calc_BusVolt
      38  MCL_ChkPowerStage
      34  MCL_Chk_BusVolt
      40  MCL_Chk_OverTemp
     156  MCL_ClearFault
      24  MCL_Compute_BusVolt
      16  MCL_Compute_Temp
       8  MCL_Get_BusVolt
      72  MCL_Init
      14  MCL_Init_Arrays
      16  MCL_Reset_PID_IntegralTerms
      50  MCL_SetFault
      12  h_BusV_Average
          h_ADCBusvolt
          h_ADCTemp
          w_Temp_Average

 
  12 bytes in section .bss
 538 bytes in section .text
 
 538 bytes of CODE memory
  12 bytes of DATA memory

Errors: none
Warnings: 4
