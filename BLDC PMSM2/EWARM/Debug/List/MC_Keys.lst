###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.1.53790/W32 for ARM     24/Feb/2014  19:26:38 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\stm32\BLDC PMSM2\src\MC_Keys.c                        #
#    Command line =  "D:\stm32\BLDC PMSM2\src\MC_Keys.c" -D VECT_TAB_FLASH    #
#                    -lCN "D:\stm32\BLDC PMSM2\EWARM\Debug\List\"             #
#                    --diag_error Pe068,Pe069 -o "D:\stm32\BLDC               #
#                    PMSM2\EWARM\Debug\Obj\" --debug --endian=little          #
#                    --cpu=Cortex-M3 --fpu=None --dlib_config "C:\Program     #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    6.4\arm\INC\c\DLib_Config_Normal.h" -I "D:\stm32\BLDC    #
#                    PMSM2\EWARM\..\" -I "D:\stm32\BLDC                       #
#                    PMSM2\EWARM\..\..\STM32F10XFWLIB\inc\" -I                #
#                    "D:\stm32\BLDC PMSM2\EWARM\..\inc\" -Oh                  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  D:\stm32\BLDC PMSM2\EWARM\Debug\List\MC_Keys.lst         #
#    Object file  =  D:\stm32\BLDC PMSM2\EWARM\Debug\Obj\MC_Keys.o            #
#                                                                             #
#                                                                             #
###############################################################################

D:\stm32\BLDC PMSM2\src\MC_Keys.c
      1          /******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
      2          * File Name          : MC_Keys.c
      3          * Author             : IMS Systems Lab 
      4          * Date First Issued  : 21/11/07
      5          * Description        : This file handles Joystick and button management
      6          ********************************************************************************
      7          * History:
      8          * 21/11/07 v1.0
      9          * 29/05/08 v2.0
     10          * 14/07/08 v2.0.1
     11          ********************************************************************************
     12          * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     13          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     14          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT, 
     15          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     16          * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING 
     17          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     18          *
     19          * THIS SOURCE CODE IS PROTECTED BY A LICENSE.
     20          * FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED
     21          * IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
     22          *******************************************************************************/
     23          /* Includes ------------------------------------------------------------------*/
     24          #include "stm32f10x_lib.h"
     25          #include "stm32f10x_MClib.h"
     26          #include "MC_Globals.h"
     27          
     28          
     29          /* Private typedef -----------------------------------------------------------*/
     30          /* Private define ------------------------------------------------------------*/
     31          #define KEY_UP_PORT GPIOB
     32          #define KEY_UP_BIT  GPIO_Pin_1
     33          
     34          #define KEY_DOWN_PORT GPIOB
     35          #define KEY_DOWN_BIT  GPIO_Pin_10
     36          
     37          #define KEY_RIGHT_PORT GPIOB
     38          #define KEY_RIGHT_BIT  GPIO_Pin_0
     39          
     40          #define KEY_LEFT_PORT GPIOC//CRE…œLEFT≤ª”√
     41          #define KEY_LEFT_BIT  GPIO_Pin_5
     42          						 
     43          #define KEY_SEL_PORT GPIOC
     44          #define KEY_SEL_BIT  GPIO_Pin_4
     45          
     46          //#define USER_BUTTON_PORT GPIOA
     47          //#define USER_BUTTON_BIT  GPIO_Pin_9		 
     48          
     49          #define  SEL_FLAG        (u8)0x02
     50          #define  RIGHT_FLAG      (u8)0x04
     51          #define  LEFT_FLAG       (u8)0x08
     52          #define  UP_FLAG         (u8)0x10
     53          #define  DOWN_FLAG       (u8)0x20
     54          
     55          //Variable increment and decrement
     56          
     57          #define SPEED_INC_DEC     (u16)10
     58          #define KP_GAIN_INC_DEC   (u16)250
     59          #define KI_GAIN_INC_DEC   (u16)25
     60          #define KD_GAIN_INC_DEC   (u16)100
     61          
     62          #ifdef FLUX_WEAKENING
     63          #define KP_VOLT_INC_DEC   (u8)50
     64          #define KI_VOLT_INC_DEC   (u8)10
     65          #define VOLT_LIM_INC_DEC  (u8)5 
     66          #endif
     67          
     68          #define TORQUE_INC_DEC    (u16)250
     69          #define FLUX_INC_DEC      (u16)250
     70          
     71          #define K1_INC_DEC        (s16)(250)
     72          #define K2_INC_DEC        (s16)(5000)
     73          
     74          #define PLL_IN_DEC        (u16)(25)
     75          
     76          /* Private macro -------------------------------------------------------------*/
     77          u8 KEYS_Read (void);
     78          /* Private variables ---------------------------------------------------------*/

   \                                 In section .bss, align 1
     79          static u8 bKey;
   \                     bKey:
   \   00000000                      DS8 1
     80          static u8 bPrevious_key;
     81          static u8 bKey_Flag;
     82          
     83          #ifdef FLUX_WEAKENING
     84          extern s16 hFW_P_Gain;
     85          extern s16 hFW_I_Gain;
     86          extern s16 hFW_V_Ref;
     87          #endif
     88          
     89          #ifdef OBSERVER_GAIN_TUNING
     90          extern volatile s32 wK1_LO;
     91          extern volatile s32 wK2_LO;
     92          extern volatile s16 hPLL_P_Gain, hPLL_I_Gain;
     93          #endif
     94          
     95          #ifdef FLUX_TORQUE_PIDs_TUNING
     96          u8 bMenu_index = CONTROL_MODE_MENU_6;
     97          #else
     98          u8 bMenu_index ;
   \                     bMenu_index:
   \   00000001                      DS8 1

   \                                 In section .bss, align 1
   \                     bPrevious_key:
   \   00000000                      DS8 1
   \   00000001                      DS8 1
     99          #endif
    100          
    101          /*******************************************************************************
    102          * Function Name  : KEYS_Init
    103          * Description    : Init GPIOs for joystick/button management
    104          * Input          : None
    105          * Output         : None
    106          * Return         : None
    107          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    108          void KEYS_Init(void)
    109          {
   \                     KEYS_Init:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    110            GPIO_InitTypeDef GPIO_InitStructure;
    111              
    112            /* Enable GPIOA, GPIOB, GPIOC, GPIOE clock */
    113            RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | 
    114                                   RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD |RCC_APB2Periph_GPIOG|
    115                                   RCC_APB2Periph_GPIOE, ENABLE);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0xF44F 0x70BE      MOV      R0,#+380
   \   0000000A   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    116           
    117            GPIO_StructInit(&GPIO_InitStructure);
   \   0000000E   0xA800             ADD      R0,SP,#+0
   \   00000010   0x.... 0x....      BL       GPIO_StructInit
    118            
    119            /* Joystick GPIOs configuration*/
    120            
    121            GPIO_InitStructure.GPIO_Pin = KEY_UP_BIT;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    122            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
   \   0000001A   0x2048             MOVS     R0,#+72
   \   0000001C   0xF88D 0x0003      STRB     R0,[SP, #+3]
    123            GPIO_Init(KEY_UP_PORT, &GPIO_InitStructure);
   \   00000020   0x.... 0x....      LDR.W    R4,??DataTable3  ;; 0x40010c00
   \   00000024   0xA900             ADD      R1,SP,#+0
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       GPIO_Init
    124            
    125            GPIO_InitStructure.GPIO_Pin = KEY_DOWN_BIT;
   \   0000002C   0xF44F 0x6080      MOV      R0,#+1024
   \   00000030   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    126            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
   \   00000034   0x2048             MOVS     R0,#+72
   \   00000036   0xF88D 0x0003      STRB     R0,[SP, #+3]
    127            GPIO_Init(KEY_DOWN_PORT, &GPIO_InitStructure);
   \   0000003A   0xA900             ADD      R1,SP,#+0
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       GPIO_Init
    128            
    129            GPIO_InitStructure.GPIO_Pin = KEY_RIGHT_BIT;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    130            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
   \   00000048   0x2048             MOVS     R0,#+72
   \   0000004A   0xF88D 0x0003      STRB     R0,[SP, #+3]
    131            GPIO_Init(KEY_RIGHT_PORT, &GPIO_InitStructure);
   \   0000004E   0xA900             ADD      R1,SP,#+0
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0x.... 0x....      BL       GPIO_Init
    132            
    133            GPIO_InitStructure.GPIO_Pin = KEY_LEFT_BIT;
   \   00000056   0x2020             MOVS     R0,#+32
   \   00000058   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    134            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
   \   0000005C   0x2028             MOVS     R0,#+40
   \   0000005E   0xF88D 0x0003      STRB     R0,[SP, #+3]
    135            GPIO_Init(KEY_LEFT_PORT, &GPIO_InitStructure);   
   \   00000062   0x.... 0x....      LDR.W    R4,??DataTable3_1  ;; 0x40011000
   \   00000066   0xA900             ADD      R1,SP,#+0
   \   00000068   0x4620             MOV      R0,R4
   \   0000006A   0x.... 0x....      BL       GPIO_Init
    136            
    137            GPIO_InitStructure.GPIO_Pin = KEY_SEL_BIT;
   \   0000006E   0x2010             MOVS     R0,#+16
   \   00000070   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    138            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
   \   00000074   0x2028             MOVS     R0,#+40
   \   00000076   0xF88D 0x0003      STRB     R0,[SP, #+3]
    139            GPIO_Init(KEY_SEL_PORT, &GPIO_InitStructure);
   \   0000007A   0xA900             ADD      R1,SP,#+0
   \   0000007C   0x4620             MOV      R0,R4
   \   0000007E   0x.... 0x....      BL       GPIO_Init
    140            
    141            /*
    142            GPIO_InitStructure.GPIO_Pin = USER_BUTTON_BIT;
    143            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    144            GPIO_Init(USER_BUTTON_PORT, &GPIO_InitStructure);	 */
    145          }
   \   00000082   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    146            
    147          
    148          
    149          /*******************************************************************************
    150          * Function Name  : KEYS_Read
    151          * Description    : Reads key from demoboard.
    152          * Input          : None
    153          * Output         : None
    154          * Return         : Return RIGHT, LEFT, SEL, UP, DOWN, KEY_HOLD or NOKEY
    155          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    156          u8 KEYS_Read ( void )
    157          {
   \                     KEYS_Read:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    158            /* "RIGHT" key is pressed */
    159            if(!GPIO_ReadInputDataBit(KEY_RIGHT_PORT, KEY_RIGHT_BIT))
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable3_2
   \   00000006   0x.... 0x....      LDR.W    R5,??DataTable3  ;; 0x40010c00
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x4628             MOV      R0,R5
   \   0000000E   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   00000012   0xB920             CBNZ.N   R0,??KEYS_Read_0
    160            {
    161              if (bPrevious_key == RIGHT) 
   \   00000014   0x7820             LDRB     R0,[R4, #+0]
   \   00000016   0x2802             CMP      R0,#+2
   \   00000018   0xD049             BEQ.N    ??KEYS_Read_1
    162              {
    163                return KEY_HOLD;
    164              }
    165              else
    166              {
    167                bPrevious_key = RIGHT;
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xE04C             B.N      ??KEYS_Read_2
    168                return RIGHT;
    169              }
    170            }
    171            /* "LEFT" key is pressed */
    172            else if(!GPIO_ReadInputDataBit(KEY_LEFT_PORT, KEY_LEFT_BIT))
   \                     ??KEYS_Read_0:
   \   0000001E   0x.... 0x....      LDR.W    R6,??DataTable3_1  ;; 0x40011000
   \   00000022   0x2120             MOVS     R1,#+32
   \   00000024   0x4630             MOV      R0,R6
   \   00000026   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   0000002A   0xB920             CBNZ.N   R0,??KEYS_Read_3
    173            {
    174              if (bPrevious_key == LEFT)  
   \   0000002C   0x7820             LDRB     R0,[R4, #+0]
   \   0000002E   0x2803             CMP      R0,#+3
   \   00000030   0xD03D             BEQ.N    ??KEYS_Read_1
    175              {
    176                return KEY_HOLD;
    177              }
    178              else
    179              {
    180                bPrevious_key = LEFT;  
   \   00000032   0x2003             MOVS     R0,#+3
   \   00000034   0xE040             B.N      ??KEYS_Read_2
    181                return LEFT;
    182              }
    183            }	
    184            /* "SEL" key is pressed */
    185             if(!GPIO_ReadInputDataBit(KEY_SEL_PORT, KEY_SEL_BIT))
   \                     ??KEYS_Read_3:
   \   00000036   0x2110             MOVS     R1,#+16
   \   00000038   0x4630             MOV      R0,R6
   \   0000003A   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   0000003E   0xBB18             CBNZ.N   R0,??KEYS_Read_4
    186            {
    187              if (bPrevious_key == SEL) 
   \   00000040   0x7820             LDRB     R0,[R4, #+0]
   \   00000042   0x2801             CMP      R0,#+1
   \   00000044   0xD033             BEQ.N    ??KEYS_Read_1
    188              {
    189                return KEY_HOLD;
    190              }
    191              else
    192              {
    193                if ( (TB_DebounceDelay_IsElapsed() == FALSE) && (bKey_Flag & SEL_FLAG == SEL_FLAG) )
   \   00000046   0x.... 0x....      BL       TB_DebounceDelay_IsElapsed
   \   0000004A   0xB910             CBNZ.N   R0,??KEYS_Read_5
   \   0000004C   0x7860             LDRB     R0,[R4, #+1]
   \   0000004E   0x07C0             LSLS     R0,R0,#+31
   \   00000050   0xD40C             BMI.N    ??KEYS_Read_6
    194                {
    195                  return NOKEY;
    196                }
    197                else
    198                {
    199                if ( (TB_DebounceDelay_IsElapsed() == TRUE) && ( (bKey_Flag & SEL_FLAG) == 0) ) 
   \                     ??KEYS_Read_5:
   \   00000052   0x.... 0x....      BL       TB_DebounceDelay_IsElapsed
   \   00000056   0x2801             CMP      R0,#+1
   \   00000058   0xD10A             BNE.N    ??KEYS_Read_7
   \   0000005A   0x7860             LDRB     R0,[R4, #+1]
   \   0000005C   0x0781             LSLS     R1,R0,#+30
   \   0000005E   0xD407             BMI.N    ??KEYS_Read_7
    200                {
    201                  bKey_Flag |= SEL_FLAG;
   \   00000060   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000064   0x7060             STRB     R0,[R4, #+1]
    202                  TB_Set_DebounceDelay_500us(100); // 50 ms debounce
   \   00000066   0x2064             MOVS     R0,#+100
   \   00000068   0x.... 0x....      BL       TB_Set_DebounceDelay_500us
    203                }
    204                else if ( (TB_DebounceDelay_IsElapsed() == TRUE) && ((bKey_Flag & SEL_FLAG) == SEL_FLAG) )
    205                {
    206                  bKey_Flag &= (u8)(~SEL_FLAG);
    207                  bPrevious_key = SEL;
    208                  return SEL;
    209                }
    210                return NOKEY;
   \                     ??KEYS_Read_6:
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xBD70             POP      {R4-R6,PC}
   \                     ??KEYS_Read_7:
   \   00000070   0x.... 0x....      BL       TB_DebounceDelay_IsElapsed
   \   00000074   0x2801             CMP      R0,#+1
   \   00000076   0xD1F9             BNE.N    ??KEYS_Read_6
   \   00000078   0x7860             LDRB     R0,[R4, #+1]
   \   0000007A   0x0781             LSLS     R1,R0,#+30
   \   0000007C   0xD5F6             BPL.N    ??KEYS_Read_6
   \   0000007E   0xF000 0x00FD      AND      R0,R0,#0xFD
   \   00000082   0x7060             STRB     R0,[R4, #+1]
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0xE017             B.N      ??KEYS_Read_2
    211                }
    212              }
    213            }
    214            /* "SEL" key is pressed */
    215           /* else if(!GPIO_ReadInputDataBit(USER_BUTTON_PORT, USER_BUTTON_BIT))
    216            {
    217              if (bPrevious_key == SEL) 
    218              {
    219                return KEY_HOLD;
    220              }
    221              else
    222              {
    223                if ( (TB_DebounceDelay_IsElapsed() == FALSE) && (bKey_Flag & SEL_FLAG == SEL_FLAG) )
    224                {
    225                  return NOKEY;
    226                }
    227                else
    228                {
    229                if ( (TB_DebounceDelay_IsElapsed() == TRUE) && ( (bKey_Flag & SEL_FLAG) == 0) ) 
    230                {
    231                  bKey_Flag |= SEL_FLAG;
    232                  TB_Set_DebounceDelay_500us(100); // 50 ms debounce
    233                }
    234                else if ( (TB_DebounceDelay_IsElapsed() == TRUE) && ((bKey_Flag & SEL_FLAG) == SEL_FLAG) )
    235                {
    236                  bKey_Flag &= (u8)(~SEL_FLAG);
    237                  bPrevious_key = SEL;
    238                  return SEL;
    239                }
    240                return NOKEY;
    241                }
    242              }
    243            }	 */
    244             /* "UP" key is pressed */
    245            else if(!GPIO_ReadInputDataBit(KEY_UP_PORT, KEY_UP_BIT))
   \                     ??KEYS_Read_4:
   \   00000088   0x2102             MOVS     R1,#+2
   \   0000008A   0x4628             MOV      R0,R5
   \   0000008C   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   00000090   0xB920             CBNZ.N   R0,??KEYS_Read_8
    246            {
    247              if (bPrevious_key == UP) 
   \   00000092   0x7820             LDRB     R0,[R4, #+0]
   \   00000094   0x2804             CMP      R0,#+4
   \   00000096   0xD00A             BEQ.N    ??KEYS_Read_1
    248              {
    249                return KEY_HOLD;
    250              }
    251              else
    252              {
    253                bPrevious_key = UP;
   \   00000098   0x2004             MOVS     R0,#+4
   \   0000009A   0xE00D             B.N      ??KEYS_Read_2
    254                return UP;
    255              }
    256            }
    257            /* "DOWN" key is pressed */
    258            else if(!GPIO_ReadInputDataBit(KEY_DOWN_PORT, KEY_DOWN_BIT))
   \                     ??KEYS_Read_8:
   \   0000009C   0xF44F 0x6180      MOV      R1,#+1024
   \   000000A0   0x4628             MOV      R0,R5
   \   000000A2   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   000000A6   0xB930             CBNZ.N   R0,??KEYS_Read_9
    259            {
    260              if (bPrevious_key == DOWN) 
   \   000000A8   0x7820             LDRB     R0,[R4, #+0]
   \   000000AA   0x2805             CMP      R0,#+5
   \   000000AC   0xD101             BNE.N    ??KEYS_Read_10
    261              {
    262                return KEY_HOLD;
   \                     ??KEYS_Read_1:
   \   000000AE   0x2006             MOVS     R0,#+6
   \   000000B0   0xBD70             POP      {R4-R6,PC}
    263              }
    264              else
    265              {
    266                bPrevious_key = DOWN;
   \                     ??KEYS_Read_10:
   \   000000B2   0x2005             MOVS     R0,#+5
   \   000000B4   0xE000             B.N      ??KEYS_Read_2
    267                return DOWN;
    268              }
    269            }
    270            
    271            /* No key is pressed */
    272            else
    273            {
    274              bPrevious_key = NOKEY;
   \                     ??KEYS_Read_9:
   \   000000B6   0x2000             MOVS     R0,#+0
   \                     ??KEYS_Read_2:
   \   000000B8   0x7020             STRB     R0,[R4, #+0]
    275              return NOKEY;
   \   000000BA   0xBD70             POP      {R4-R6,PC}       ;; return
    276            }
    277          }
    278          
    279          
    280          
    281          /*******************************************************************************
    282          * Function Name  : KEYS_process
    283          * Description    : Process key 
    284          * Input          : Key code
    285          * Output         : None
    286          * Return         : None
    287          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    288          void KEYS_process(void)
    289          {
   \                     KEYS_process:
   \   00000000   0xB580             PUSH     {R7,LR}
    290          bKey = KEYS_Read();    // read key pushed (if any...)
   \   00000002   0x.... 0x....      BL       KEYS_Read
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable3_3
   \   0000000A   0x7008             STRB     R0,[R1, #+0]
    291          
    292          switch (bMenu_index)
   \   0000000C   0x784A             LDRB     R2,[R1, #+1]
   \   0000000E   0x2A16             CMP      R2,#+22
   \   00000010   0xF200 0x832D      BHI.W    ??KEYS_process_1
   \   00000014   0xE8DF 0xF012      TBH      [PC, R2, LSL #+1]
   \                     ??KEYS_process_0:
   \   00000018   0x0017 0x003E      DC16     0x17,0x3E,0x77,0xA8
   \              0x0077 0x00A8
   \   00000020   0x032B 0x00D2      DC16     0x32B,0xD2,0x107,0x32B
   \              0x0107 0x032B
   \   00000028   0x012F 0x015E      DC16     0x12F,0x15E,0x32B,0x18F
   \              0x032B 0x018F
   \   00000030   0x01A8 0x01CF      DC16     0x1A8,0x1CF,0x205,0x32B
   \              0x0205 0x032B
   \   00000038   0x032B 0x0236      DC16     0x32B,0x236,0x262,0x293
   \              0x0262 0x0293
   \   00000040   0x02B8 0x02E1      DC16     0x2B8,0x2E1,0x2FA
   \              0x02FA       
    293                {        
    294                  case(CONTROL_MODE_MENU_1):
    295                    switch(bKey)
   \                     ??KEYS_process_2:
   \   00000046   0x2801             CMP      R0,#+1
   \   00000048   0xD014             BEQ.N    ??KEYS_process_3
   \   0000004A   0xF0C0 0x8310      BCC.W    ??KEYS_process_1
   \   0000004E   0x2803             CMP      R0,#+3
   \   00000050   0xD00E             BEQ.N    ??KEYS_process_4
   \   00000052   0xD30B             BCC.N    ??KEYS_process_5
   \   00000054   0x2805             CMP      R0,#+5
   \   00000056   0xD001             BEQ.N    ??KEYS_process_6
   \   00000058   0xF080 0x8309      BCS.W    ??KEYS_process_1
    296                    {
    297                      case UP:
    298                      case DOWN:
    299                        wGlobal_Flags ^= SPEED_CONTROL;
   \                     ??KEYS_process_6:
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable3_4
   \   00000060   0x6802             LDR      R2,[R0, #+0]
   \   00000062   0xF082 0x0201      EOR      R2,R2,#0x1
   \   00000066   0x6002             STR      R2,[R0, #+0]
    300                        bMenu_index = CONTROL_MODE_MENU_6;
   \   00000068   0x200C             MOVS     R0,#+12
   \   0000006A   0xE2F4             B.N      ??KEYS_process_7
    301                      break;
    302                      
    303                      case RIGHT:
    304                          bMenu_index = REF_SPEED_MENU;
   \                     ??KEYS_process_5:
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0xE2F2             B.N      ??KEYS_process_7
    305                      break;
    306                      
    307                      case LEFT:
    308          #ifdef DAC_FUNCTIONALITY              
    309                        bMenu_index = DAC_PB1_MENU;
   \                     ??KEYS_process_4:
   \   00000070   0x2016             MOVS     R0,#+22
   \   00000072   0xE2F0             B.N      ??KEYS_process_7
    310          #elif defined OBSERVER_GAIN_TUNING
    311                        bMenu_index = I_PLL_MENU;          
    312          #else              
    313                        bMenu_index = POWER_STAGE_MENU;
    314          #endif              
    315                      break;
    316                      
    317                      case SEL:
    318                        if (State == RUN)
   \                     ??KEYS_process_3:
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable3_5
   \   00000078   0x7802             LDRB     R2,[R0, #+0]
   \   0000007A   0x2A03             CMP      R2,#+3
   \   0000007C   0xBF1C             ITT      NE 
   \   0000007E   0x7802             LDRBNE   R2,[R0, #+0]
   \   00000080   0x2A02             CMPNE    R2,#+2
    319                        {
    320                          State = STOP;               
    321                        }
    322                        else if (State== START)
   \   00000082   0xF000 0x82F0      BEQ.W    ??KEYS_process_8
    323                        {
    324                          State = STOP; 
    325                        }
    326                          else if(State == IDLE)
   \   00000086   0x7802             LDRB     R2,[R0, #+0]
   \   00000088   0x2A00             CMP      R2,#+0
   \   0000008A   0xF040 0x82F0      BNE.W    ??KEYS_process_1
    327                          {
    328                            State = INIT;
   \   0000008E   0x2201             MOVS     R2,#+1
   \   00000090   0x7002             STRB     R2,[R0, #+0]
    329                            bMenu_index = REF_SPEED_MENU;
   \   00000092   0xE2D8             B.N      ??KEYS_process_9
    330                          }  
    331                        
    332                      break;
    333                      default:
    334                      break;
    335                    }
    336                  break;
    337                  
    338                  case(REF_SPEED_MENU):
    339                    switch(bKey)
   \                     ??KEYS_process_10:
   \   00000094   0x2801             CMP      R0,#+1
   \   00000096   0xD028             BEQ.N    ??KEYS_process_11
   \   00000098   0xF0C0 0x82E9      BCC.W    ??KEYS_process_1
   \   0000009C   0x2803             CMP      R0,#+3
   \   0000009E   0xD01C             BEQ.N    ??KEYS_process_12
   \   000000A0   0xD37C             BCC.N    ??KEYS_process_13
   \   000000A2   0x2805             CMP      R0,#+5
   \   000000A4   0xD00D             BEQ.N    ??KEYS_process_14
   \   000000A6   0xF080 0x82E2      BCS.W    ??KEYS_process_1
    340                    {
    341                      case UP:
    342                        if (hSpeed_Reference <= MOTOR_MAX_SPEED_HZ)
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable3_6
   \   000000AE   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   000000B2   0xF240 0x2259      MOVW     R2,#+601
   \   000000B6   0x4291             CMP      R1,R2
   \   000000B8   0xF280 0x82D9      BGE.W    ??KEYS_process_1
    343                        {
    344                          hSpeed_Reference += SPEED_INC_DEC;
   \   000000BC   0x8801             LDRH     R1,[R0, #+0]
   \   000000BE   0x310A             ADDS     R1,R1,#+10
   \   000000C0   0xE27C             B.N      ??KEYS_process_15
    345                        }
    346                      break;
    347                        
    348                      case DOWN:
    349                        if (hSpeed_Reference >= -MOTOR_MAX_SPEED_HZ)
   \                     ??KEYS_process_14:
   \   000000C2   0x.... 0x....      LDR.W    R0,??DataTable3_6
   \   000000C6   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   000000CA   0x.... 0x....      LDR.W    R2,??DataTable3_7  ;; 0xfffffda8
   \   000000CE   0x4291             CMP      R1,R2
   \   000000D0   0xF2C0 0x82CD      BLT.W    ??KEYS_process_1
    350                        {
    351                          hSpeed_Reference -= SPEED_INC_DEC;
   \   000000D4   0x8801             LDRH     R1,[R0, #+0]
   \   000000D6   0x390A             SUBS     R1,R1,#+10
   \   000000D8   0xE270             B.N      ??KEYS_process_15
    352                        }
    353                      break;
    354                     
    355                      case RIGHT:
    356                          bMenu_index = P_SPEED_MENU;
    357                      break;
    358          
    359                      case LEFT:
    360                        if (State == IDLE)
   \                     ??KEYS_process_12:
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable3_5
   \   000000DE   0x7800             LDRB     R0,[R0, #+0]
   \   000000E0   0x2800             CMP      R0,#+0
   \   000000E2   0xF000 0x82B8      BEQ.W    ??KEYS_process_7
    361                        {
    362                          bMenu_index = CONTROL_MODE_MENU_1;
    363                        }
    364                        else
    365                        {
    366          #ifdef DAC_FUNCTIONALITY              
    367                        bMenu_index = DAC_PB1_MENU;
   \   000000E6   0x2016             MOVS     R0,#+22
   \   000000E8   0xE2B5             B.N      ??KEYS_process_7
    368          #elif defined OBSERVER_GAIN_TUNING
    369                        bMenu_index = I_PLL_MENU;          
    370          #else              
    371                        bMenu_index = POWER_STAGE_MENU;
    372          #endif 
    373                        }              
    374                      break;
    375                      
    376                      case SEL:
    377                        if (State == RUN)
   \                     ??KEYS_process_11:
   \   000000EA   0x.... 0x....      LDR.W    R0,??DataTable3_5
   \   000000EE   0x7801             LDRB     R1,[R0, #+0]
   \   000000F0   0x2903             CMP      R1,#+3
   \   000000F2   0xBF1C             ITT      NE 
   \   000000F4   0x7801             LDRBNE   R1,[R0, #+0]
   \   000000F6   0x2902             CMPNE    R1,#+2
    378                        {
    379                          State = STOP;               
    380                        }
    381                        else if(State == START)
   \   000000F8   0xF000 0x82B5      BEQ.W    ??KEYS_process_8
    382                        {
    383                          State = STOP;
    384                        }              
    385                          else if(State == IDLE)
   \   000000FC   0x7801             LDRB     R1,[R0, #+0]
   \   000000FE   0x2900             CMP      R1,#+0
   \   00000100   0xF040 0x82B5      BNE.W    ??KEYS_process_1
    386                          {
    387                            State = INIT;
   \   00000104   0xE2B1             B.N      ??KEYS_process_16
    388                          }   
    389                      break;
    390                      default:
    391                      break;
    392                    }
    393                  break;          
    394                  
    395                  case(P_SPEED_MENU):    
    396                    switch(bKey)
   \                     ??KEYS_process_17:
   \   00000106   0x2801             CMP      R0,#+1
   \   00000108   0xD020             BEQ.N    ??KEYS_process_18
   \   0000010A   0xF0C0 0x82B0      BCC.W    ??KEYS_process_1
   \   0000010E   0x2803             CMP      R0,#+3
   \   00000110   0xD01A             BEQ.N    ??KEYS_process_19
   \   00000112   0xD317             BCC.N    ??KEYS_process_20
   \   00000114   0x2805             CMP      R0,#+5
   \   00000116   0xD00C             BEQ.N    ??KEYS_process_21
   \   00000118   0xF080 0x82A9      BCS.W    ??KEYS_process_1
    397                    {
    398                      case UP:
    399                        if (PID_Speed_InitStructure.hKp_Gain <= S16_MAX-KP_GAIN_INC_DEC)
   \   0000011C   0x.... 0x....      LDR.W    R0,??DataTable3_8
   \   00000120   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   00000124   0xF647 0x7206      MOVW     R2,#+32518
   \   00000128   0x4291             CMP      R1,R2
   \   0000012A   0xF280 0x82A0      BGE.W    ??KEYS_process_1
    400                        {
    401                          PID_Speed_InitStructure.hKp_Gain += KP_GAIN_INC_DEC;
   \   0000012E   0x31FA             ADDS     R1,R1,#+250
   \   00000130   0xE244             B.N      ??KEYS_process_15
    402                        }
    403                      break;
    404                        
    405                      case DOWN:
    406                        if (PID_Speed_InitStructure.hKp_Gain >= KP_GAIN_INC_DEC)
   \                     ??KEYS_process_21:
   \   00000132   0x.... 0x....      LDR.W    R0,??DataTable3_8
   \   00000136   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   0000013A   0x29FA             CMP      R1,#+250
   \   0000013C   0xF2C0 0x8297      BLT.W    ??KEYS_process_1
    407                        {
    408                        PID_Speed_InitStructure.hKp_Gain -= KP_GAIN_INC_DEC;
   \   00000140   0x39FA             SUBS     R1,R1,#+250
   \   00000142   0xE23B             B.N      ??KEYS_process_15
    409                        }
    410                      break;
    411                     
    412                      case RIGHT:
    413                          bMenu_index = I_SPEED_MENU;
   \                     ??KEYS_process_20:
   \   00000144   0x2003             MOVS     R0,#+3
   \   00000146   0xE286             B.N      ??KEYS_process_7
    414                      break;
    415          
    416                      case LEFT:
    417                          bMenu_index = REF_SPEED_MENU;             
   \                     ??KEYS_process_19:
   \   00000148   0x2001             MOVS     R0,#+1
   \   0000014A   0xE284             B.N      ??KEYS_process_7
    418                      break;
    419                      
    420                      case SEL:
    421                        if (State == RUN)
   \                     ??KEYS_process_18:
   \   0000014C   0x.... 0x....      LDR.W    R0,??DataTable3_5
   \   00000150   0x7801             LDRB     R1,[R0, #+0]
   \   00000152   0x2903             CMP      R1,#+3
   \   00000154   0xBF1C             ITT      NE 
   \   00000156   0x7801             LDRBNE   R1,[R0, #+0]
   \   00000158   0x2902             CMPNE    R1,#+2
    422                        {
    423                          State = STOP;               
    424                        }
    425                        else if (State== START)
   \   0000015A   0xF000 0x8284      BEQ.W    ??KEYS_process_8
    426                        {
    427                          State = STOP; 
    428                        }
    429                          else if(State == IDLE)
   \   0000015E   0x7801             LDRB     R1,[R0, #+0]
   \   00000160   0x2900             CMP      R1,#+0
   \   00000162   0xF040 0x8284      BNE.W    ??KEYS_process_1
    430                          {
    431                            State = INIT;
   \   00000166   0xE280             B.N      ??KEYS_process_16
    432                          }   
    433                      break;
    434                    default:
    435                      break;
    436                    }
    437                  break;
    438          
    439                  case(I_SPEED_MENU):    
    440                    switch(bKey)
   \                     ??KEYS_process_22:
   \   00000168   0x2801             CMP      R0,#+1
   \   0000016A   0xD019             BEQ.N    ??KEYS_process_23
   \   0000016C   0xF0C0 0x827F      BCC.W    ??KEYS_process_1
   \   00000170   0x2803             CMP      R0,#+3
   \   00000172   0xD013             BEQ.N    ??KEYS_process_13
   \   00000174   0xF0C0 0x8175      BCC.W    ??KEYS_process_24
   \   00000178   0x2805             CMP      R0,#+5
   \   0000017A   0xD00C             BEQ.N    ??KEYS_process_25
   \   0000017C   0xF080 0x8277      BCS.W    ??KEYS_process_1
    441                    {
    442                      case UP:
    443                        if (PID_Speed_InitStructure.hKi_Gain <= S16_MAX-KI_GAIN_INC_DEC)
   \   00000180   0x.... 0x....      LDR.W    R0,??DataTable3_8
   \   00000184   0xF9B0 0x1004      LDRSH    R1,[R0, #+4]
   \   00000188   0xF647 0x72E7      MOVW     R2,#+32743
   \   0000018C   0x4291             CMP      R1,R2
   \   0000018E   0xF280 0x826E      BGE.W    ??KEYS_process_1
    444                        {
    445                          PID_Speed_InitStructure.hKi_Gain += KI_GAIN_INC_DEC;
   \   00000192   0x3119             ADDS     R1,R1,#+25
   \   00000194   0xE0BD             B.N      ??KEYS_process_26
    446                        }
    447                      break;
    448                        
    449                      case DOWN:
    450                        if (PID_Speed_InitStructure.hKi_Gain >= KI_GAIN_INC_DEC)
   \                     ??KEYS_process_25:
   \   00000196   0x.... 0x....      LDR.W    R0,??DataTable3_8
   \   0000019A   0xE0B4             B.N      ??KEYS_process_27
    451                        {
    452                        PID_Speed_InitStructure.hKi_Gain -= KI_GAIN_INC_DEC;
    453                        }
    454                      break;
    455                     
    456                      case RIGHT:
    457          #ifdef DIFFERENTIAL_TERM_ENABLED                 
    458                          bMenu_index = D_SPEED_MENU;
    459          #else
    460                          bMenu_index = P_TORQUE_MENU;
    461          #endif                
    462                      break;
    463          
    464                      case LEFT:
    465                        bMenu_index = P_SPEED_MENU;
   \                     ??KEYS_process_13:
   \   0000019C   0x2002             MOVS     R0,#+2
   \   0000019E   0xE25A             B.N      ??KEYS_process_7
    466                      break;
    467                      
    468                      case SEL:
    469                        if (State == RUN)
   \                     ??KEYS_process_23:
   \   000001A0   0x.... 0x....      LDR.W    R0,??DataTable3_5
   \   000001A4   0x7801             LDRB     R1,[R0, #+0]
   \   000001A6   0x2903             CMP      R1,#+3
   \   000001A8   0xBF1C             ITT      NE 
   \   000001AA   0x7801             LDRBNE   R1,[R0, #+0]
   \   000001AC   0x2902             CMPNE    R1,#+2
    470                        {
    471                          State = STOP;               
    472                        }
    473                        else if (State== START)
   \   000001AE   0xF000 0x825A      BEQ.W    ??KEYS_process_8
    474                        {
    475                          State = STOP; 
    476                        }
    477                          else if(State == IDLE)
   \   000001B2   0x7801             LDRB     R1,[R0, #+0]
   \   000001B4   0x2900             CMP      R1,#+0
   \   000001B6   0xF040 0x825A      BNE.W    ??KEYS_process_1
    478                          {
    479                            State = INIT;
   \   000001BA   0xE256             B.N      ??KEYS_process_16
    480                          }   
    481                      break;
    482                    default:
    483                      break;
    484                    }
    485                  break;        
    486                  
    487          #ifdef DIFFERENTIAL_TERM_ENABLED       
    488                  case(D_SPEED_MENU):    
    489                    switch(bKey)
    490                    {
    491                      case UP:
    492                        if (PID_Speed_InitStructure.hKd_Gain <= S16_MAX-KD_GAIN_INC_DEC)
    493                        {
    494                          PID_Speed_InitStructure.hKd_Gain += KD_GAIN_INC_DEC;
    495                        }
    496                      break;
    497                        
    498                      case DOWN:
    499                        if (PID_Speed_InitStructure.hKd_Gain >= KD_GAIN_INC_DEC)
    500                        {
    501                        PID_Speed_InitStructure.hKd_Gain -= KD_GAIN_INC_DEC;
    502                        }
    503                      break;
    504                     
    505                      case RIGHT:                
    506                          bMenu_index = P_TORQUE_MENU;               
    507                      break;
    508                      
    509                      case LEFT:
    510                        bMenu_index = I_SPEED_MENU;
    511                      break;
    512                      
    513                      case SEL:
    514                        if (State == RUN || State == START)
    515                        {
    516                          State = STOP;               
    517                        }
    518                        else if(State == IDLE)
    519                        {
    520                          State = INIT;
    521                        }   
    522                      break;
    523                    default:
    524                      break;
    525                    }
    526                  break;   
    527          #endif
    528                  case(P_TORQUE_MENU):    
    529                    switch(bKey)
   \                     ??KEYS_process_28:
   \   000001BC   0x2801             CMP      R0,#+1
   \   000001BE   0xD024             BEQ.N    ??KEYS_process_29
   \   000001C0   0xF0C0 0x8255      BCC.W    ??KEYS_process_1
   \   000001C4   0x2803             CMP      R0,#+3
   \   000001C6   0xD018             BEQ.N    ??KEYS_process_30
   \   000001C8   0xD374             BCC.N    ??KEYS_process_31
   \   000001CA   0x2805             CMP      R0,#+5
   \   000001CC   0xD00C             BEQ.N    ??KEYS_process_32
   \   000001CE   0xF080 0x824E      BCS.W    ??KEYS_process_1
    530                    {
    531                      case UP:
    532                        if (PID_Torque_InitStructure.hKp_Gain <= S16_MAX - KP_GAIN_INC_DEC)
   \   000001D2   0x.... 0x....      LDR.W    R0,??DataTable3_9
   \   000001D6   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   000001DA   0xF647 0x7206      MOVW     R2,#+32518
   \   000001DE   0x4291             CMP      R1,R2
   \   000001E0   0xF280 0x8245      BGE.W    ??KEYS_process_1
    533                        {
    534                          PID_Torque_InitStructure.hKp_Gain += KP_GAIN_INC_DEC;
   \   000001E4   0x31FA             ADDS     R1,R1,#+250
   \   000001E6   0xE1E9             B.N      ??KEYS_process_15
    535                        }
    536                      break;
    537                        
    538                      case DOWN:
    539                        if (PID_Torque_InitStructure.hKp_Gain >= KP_GAIN_INC_DEC)
   \                     ??KEYS_process_32:
   \   000001E8   0x.... 0x....      LDR.W    R0,??DataTable3_9
   \   000001EC   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   000001F0   0x29FA             CMP      R1,#+250
   \   000001F2   0xF2C0 0x823C      BLT.W    ??KEYS_process_1
    540                        {
    541                        PID_Torque_InitStructure.hKp_Gain -= KP_GAIN_INC_DEC;
   \   000001F6   0x39FA             SUBS     R1,R1,#+250
   \   000001F8   0xE1E0             B.N      ??KEYS_process_15
    542                        }
    543                      break;
    544                     
    545                      case RIGHT:
    546                          bMenu_index = I_TORQUE_MENU;
    547                      break;
    548                       
    549                      case LEFT:         
    550                        if ((wGlobal_Flags & SPEED_CONTROL) == SPEED_CONTROL)
   \                     ??KEYS_process_30:
   \   000001FA   0x.... 0x....      LDR.W    R0,??DataTable3_4
   \   000001FE   0x6800             LDR      R0,[R0, #+0]
   \   00000200   0x07C0             LSLS     R0,R0,#+31
   \   00000202   0xBF54             ITE      PL 
   \   00000204   0x200E             MOVPL    R0,#+14
   \   00000206   0x2003             MOVMI    R0,#+3
    551                        {
    552          #ifdef DIFFERENTIAL_TERM_ENABLED              
    553                          bMenu_index = D_SPEED_MENU;
    554          #else
    555                          bMenu_index = I_SPEED_MENU; 
   \   00000208   0xE225             B.N      ??KEYS_process_7
    556          #endif                
    557                        }
    558                        else
    559                        {
    560                          bMenu_index = ID_REF_MENU;
    561                        }              
    562                      break;
    563                      
    564                      case SEL:
    565                        if (State == RUN)
   \                     ??KEYS_process_29:
   \   0000020A   0x.... 0x....      LDR.W    R0,??DataTable3_5
   \   0000020E   0x7801             LDRB     R1,[R0, #+0]
   \   00000210   0x2903             CMP      R1,#+3
   \   00000212   0xBF1C             ITT      NE 
   \   00000214   0x7801             LDRBNE   R1,[R0, #+0]
   \   00000216   0x2902             CMPNE    R1,#+2
    566                        {
    567                          State = STOP;               
    568                        }
    569                        else if (State== START)
   \   00000218   0xF000 0x8225      BEQ.W    ??KEYS_process_8
    570                          {
    571                            State = STOP; 
    572                          }
    573                            else if(State == IDLE)
   \   0000021C   0x7801             LDRB     R1,[R0, #+0]
   \   0000021E   0x2900             CMP      R1,#+0
   \   00000220   0xF040 0x8225      BNE.W    ??KEYS_process_1
    574                            {
    575                              State = INIT;
   \   00000224   0xE221             B.N      ??KEYS_process_16
    576                            }   
    577                      break;
    578                    default:
    579                      break;
    580                    }
    581                  break;
    582                  
    583                  case(I_TORQUE_MENU):    
    584                    switch(bKey)
   \                     ??KEYS_process_33:
   \   00000226   0x2801             CMP      R0,#+1
   \   00000228   0xD017             BEQ.N    ??KEYS_process_34
   \   0000022A   0xF0C0 0x8220      BCC.W    ??KEYS_process_1
   \   0000022E   0x2803             CMP      R0,#+3
   \   00000230   0xF000 0x8117      BEQ.W    ??KEYS_process_24
   \   00000234   0xD36F             BCC.N    ??KEYS_process_35
   \   00000236   0x2805             CMP      R0,#+5
   \   00000238   0xD00C             BEQ.N    ??KEYS_process_36
   \   0000023A   0xF080 0x8218      BCS.W    ??KEYS_process_1
    585                    {
    586                      case UP:
    587                        if (PID_Torque_InitStructure.hKi_Gain <= S16_MAX - KI_GAIN_INC_DEC)
   \   0000023E   0x.... 0x....      LDR.W    R0,??DataTable3_9
   \   00000242   0xF9B0 0x1004      LDRSH    R1,[R0, #+4]
   \   00000246   0xF647 0x72E7      MOVW     R2,#+32743
   \   0000024A   0x4291             CMP      R1,R2
   \   0000024C   0xF280 0x820F      BGE.W    ??KEYS_process_1
    588                        {
    589                          PID_Torque_InitStructure.hKi_Gain += KI_GAIN_INC_DEC;
   \   00000250   0x3119             ADDS     R1,R1,#+25
   \   00000252   0xE05E             B.N      ??KEYS_process_26
    590                        }
    591                      break;
    592                        
    593                      case DOWN:
    594                        if (PID_Torque_InitStructure.hKi_Gain >= KI_GAIN_INC_DEC)
   \                     ??KEYS_process_36:
   \   00000254   0x.... 0x....      LDR.W    R0,??DataTable3_9
   \   00000258   0xE055             B.N      ??KEYS_process_27
    595                        {
    596                        PID_Torque_InitStructure.hKi_Gain -= KI_GAIN_INC_DEC;
    597                        }
    598                      break;
    599                     
    600                      case RIGHT:
    601          #ifdef DIFFERENTIAL_TERM_ENABLED                 
    602                          bMenu_index = D_TORQUE_MENU;
    603          #else
    604                          bMenu_index = P_FLUX_MENU;
    605          #endif                
    606                      break;
    607          
    608                      case LEFT:
    609                        bMenu_index = P_TORQUE_MENU;
    610                      break;
    611                      
    612                      case SEL:
    613                        if (State == RUN)
   \                     ??KEYS_process_34:
   \   0000025A   0x.... 0x....      LDR.W    R0,??DataTable3_5
   \   0000025E   0x7801             LDRB     R1,[R0, #+0]
   \   00000260   0x2903             CMP      R1,#+3
   \   00000262   0xBF1C             ITT      NE 
   \   00000264   0x7801             LDRBNE   R1,[R0, #+0]
   \   00000266   0x2902             CMPNE    R1,#+2
    614                        {
    615                          State = STOP;               
    616                        }
    617                          else if (State== START)
   \   00000268   0xF000 0x81FD      BEQ.W    ??KEYS_process_8
    618                          {
    619                            State = STOP; 
    620                          }
    621                            else if(State == IDLE)
   \   0000026C   0x7801             LDRB     R1,[R0, #+0]
   \   0000026E   0x2900             CMP      R1,#+0
   \   00000270   0xF040 0x81FD      BNE.W    ??KEYS_process_1
    622                            {
    623                              State = INIT;
   \   00000274   0xE1F9             B.N      ??KEYS_process_16
    624                            }   
    625                      break;
    626                    default:
    627                      break;
    628                    }
    629                  break;
    630                  
    631          #ifdef DIFFERENTIAL_TERM_ENABLED       
    632                  case(D_TORQUE_MENU):    
    633                    switch(bKey)
    634                    {
    635                      case UP:
    636                        if (PID_Torque_InitStructure.hKd_Gain <= S16_MAX - KD_GAIN_INC_DEC)
    637                        {
    638                          PID_Torque_InitStructure.hKd_Gain += KD_GAIN_INC_DEC;
    639                        }
    640                      break;
    641                        
    642                      case DOWN:
    643                        if (PID_Torque_InitStructure.hKd_Gain >= KD_GAIN_INC_DEC)
    644                        {
    645                        PID_Torque_InitStructure.hKd_Gain -= KD_GAIN_INC_DEC;
    646                        }
    647                      break;
    648                     
    649                      case RIGHT:                
    650                          bMenu_index = P_FLUX_MENU;               
    651                      break;
    652                      
    653                      case LEFT:
    654                        bMenu_index = I_TORQUE_MENU;
    655                      break;
    656                      
    657                      case SEL:
    658                        if (State == RUN || State == START)
    659                        {
    660                          State = STOP;               
    661                        }
    662                        else if(State == IDLE)
    663                        {
    664                          State = INIT;
    665                        }   
    666                      break;
    667                    default:
    668                      break;
    669                    }
    670                  break;   
    671          #endif 
    672                   case(P_FLUX_MENU):    
    673                    switch(bKey)
   \                     ??KEYS_process_37:
   \   00000276   0x2801             CMP      R0,#+1
   \   00000278   0xD01E             BEQ.N    ??KEYS_process_38
   \   0000027A   0xF0C0 0x81F8      BCC.W    ??KEYS_process_1
   \   0000027E   0x2803             CMP      R0,#+3
   \   00000280   0xD018             BEQ.N    ??KEYS_process_31
   \   00000282   0xD361             BCC.N    ??KEYS_process_39
   \   00000284   0x2805             CMP      R0,#+5
   \   00000286   0xD00C             BEQ.N    ??KEYS_process_40
   \   00000288   0xF080 0x81F1      BCS.W    ??KEYS_process_1
    674                    {
    675                      case UP:
    676                        if (PID_Flux_InitStructure.hKp_Gain <= S16_MAX-KP_GAIN_INC_DEC)
   \   0000028C   0x.... 0x....      LDR.W    R0,??DataTable3_10
   \   00000290   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   00000294   0xF647 0x7206      MOVW     R2,#+32518
   \   00000298   0x4291             CMP      R1,R2
   \   0000029A   0xF280 0x81E8      BGE.W    ??KEYS_process_1
    677                        {
    678                          PID_Flux_InitStructure.hKp_Gain += KP_GAIN_INC_DEC;
   \   0000029E   0x31FA             ADDS     R1,R1,#+250
   \   000002A0   0xE18C             B.N      ??KEYS_process_15
    679                        }
    680                      break;
    681                        
    682                      case DOWN:
    683                        if (PID_Flux_InitStructure.hKp_Gain >= KP_GAIN_INC_DEC)
   \                     ??KEYS_process_40:
   \   000002A2   0x.... 0x....      LDR.W    R0,??DataTable3_10
   \   000002A6   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   000002AA   0x29FA             CMP      R1,#+250
   \   000002AC   0xF2C0 0x81DF      BLT.W    ??KEYS_process_1
    684                        {
    685                          PID_Flux_InitStructure.hKp_Gain -= KP_GAIN_INC_DEC;
   \   000002B0   0x39FA             SUBS     R1,R1,#+250
   \   000002B2   0xE183             B.N      ??KEYS_process_15
    686                        }
    687                      break;
    688                     
    689                      case RIGHT:
    690                          bMenu_index = I_FLUX_MENU;
    691                      break;
    692                       
    693                      case LEFT:         
    694          #ifdef  DIFFERENTIAL_TERM_ENABLED
    695                        bMenu_index = D_TORQUE_MENU;
    696          #else
    697                        bMenu_index = I_TORQUE_MENU;
   \                     ??KEYS_process_31:
   \   000002B4   0x2006             MOVS     R0,#+6
   \   000002B6   0xE1CE             B.N      ??KEYS_process_7
    698          #endif              
    699                      break;
    700                      
    701                      case SEL:
    702                        if (State == RUN)
   \                     ??KEYS_process_38:
   \   000002B8   0x.... 0x....      LDR.W    R0,??DataTable3_5
   \   000002BC   0x7801             LDRB     R1,[R0, #+0]
   \   000002BE   0x2903             CMP      R1,#+3
   \   000002C0   0xBF1C             ITT      NE 
   \   000002C2   0x7801             LDRBNE   R1,[R0, #+0]
   \   000002C4   0x2902             CMPNE    R1,#+2
    703                        {
    704                          State = STOP;               
    705                        }
    706                          else if (State== START)
   \   000002C6   0xF000 0x81CE      BEQ.W    ??KEYS_process_8
    707                          {
    708                            State = STOP; 
    709                          }
    710                            else if(State == IDLE)
   \   000002CA   0x7801             LDRB     R1,[R0, #+0]
   \   000002CC   0x2900             CMP      R1,#+0
   \   000002CE   0xF040 0x81CE      BNE.W    ??KEYS_process_1
    711                            {
    712                              State = INIT;
   \   000002D2   0xE1CA             B.N      ??KEYS_process_16
    713                            }   
    714                      break;
    715                    default:
    716                      break;
    717                    }
    718                  break;
    719                  
    720                  case(I_FLUX_MENU):    
    721                    switch(bKey)
   \                     ??KEYS_process_41:
   \   000002D4   0x2801             CMP      R0,#+1
   \   000002D6   0xD020             BEQ.N    ??KEYS_process_42
   \   000002D8   0xF0C0 0x81C9      BCC.W    ??KEYS_process_1
   \   000002DC   0x2803             CMP      R0,#+3
   \   000002DE   0xD01A             BEQ.N    ??KEYS_process_35
   \   000002E0   0xF0C0 0x80ED      BCC.W    ??KEYS_process_43
   \   000002E4   0x2805             CMP      R0,#+5
   \   000002E6   0xD00C             BEQ.N    ??KEYS_process_44
   \   000002E8   0xF080 0x81C1      BCS.W    ??KEYS_process_1
    722                    {
    723                      case UP:
    724                        if (PID_Flux_InitStructure.hKi_Gain <= S16_MAX-KI_GAIN_INC_DEC)
   \   000002EC   0x.... 0x....      LDR.W    R0,??DataTable3_10
   \   000002F0   0xF9B0 0x1004      LDRSH    R1,[R0, #+4]
   \   000002F4   0xF647 0x72E7      MOVW     R2,#+32743
   \   000002F8   0x4291             CMP      R1,R2
   \   000002FA   0xF280 0x81B8      BGE.W    ??KEYS_process_1
    725                        {
    726                          PID_Flux_InitStructure.hKi_Gain += KI_GAIN_INC_DEC;
   \   000002FE   0x3119             ADDS     R1,R1,#+25
   \   00000300   0xE007             B.N      ??KEYS_process_26
    727                        }
    728                      break;
    729                        
    730                      case DOWN:
    731                        if (PID_Flux_InitStructure.hKi_Gain >= KI_GAIN_INC_DEC)
   \                     ??KEYS_process_44:
   \   00000302   0x.... 0x....      LDR.W    R0,??DataTable3_10
   \                     ??KEYS_process_27:
   \   00000306   0xF9B0 0x1004      LDRSH    R1,[R0, #+4]
   \   0000030A   0x2919             CMP      R1,#+25
   \   0000030C   0xF2C0 0x81AF      BLT.W    ??KEYS_process_1
    732                        {
    733                        PID_Flux_InitStructure.hKi_Gain -= KI_GAIN_INC_DEC;
   \   00000310   0x3919             SUBS     R1,R1,#+25
   \                     ??KEYS_process_26:
   \   00000312   0x8081             STRH     R1,[R0, #+4]
   \   00000314   0xBD01             POP      {R0,PC}
    734                        }
    735                      break;
    736                     
    737                      case RIGHT:
    738          #ifdef DIFFERENTIAL_TERM_ENABLED                 
    739                          bMenu_index = D_FLUX_MENU;
    740          #elif defined FLUX_WEAKENING
    741                          bMenu_index = P_VOLT_MENU;
    742          #else                
    743                          bMenu_index = POWER_STAGE_MENU;
    744          #endif                
    745                      break;
    746          
    747                      case LEFT:
    748                        bMenu_index = P_FLUX_MENU;
   \                     ??KEYS_process_35:
   \   00000316   0x2008             MOVS     R0,#+8
   \   00000318   0xE19D             B.N      ??KEYS_process_7
    749                      break;
    750                      
    751                      case SEL:
    752                        if (State == RUN)
   \                     ??KEYS_process_42:
   \   0000031A   0x.... 0x....      LDR.W    R0,??DataTable3_5
   \   0000031E   0x7801             LDRB     R1,[R0, #+0]
   \   00000320   0x2903             CMP      R1,#+3
   \   00000322   0xBF1C             ITT      NE 
   \   00000324   0x7801             LDRBNE   R1,[R0, #+0]
   \   00000326   0x2902             CMPNE    R1,#+2
    753                        {
    754                          State = STOP;               
    755                        }
    756                          else if (State== START)
   \   00000328   0xF000 0x819D      BEQ.W    ??KEYS_process_8
    757                          {
    758                            State = STOP; 
    759                          }
    760                            else if(State == IDLE)
   \   0000032C   0x7801             LDRB     R1,[R0, #+0]
   \   0000032E   0x2900             CMP      R1,#+0
   \   00000330   0xF040 0x819D      BNE.W    ??KEYS_process_1
    761                            {
    762                              State = INIT;
   \   00000334   0xE199             B.N      ??KEYS_process_16
    763                            }   
    764                      break;
    765                    default:
    766                      break;
    767                    }
    768                  break;
    769                  
    770          #ifdef DIFFERENTIAL_TERM_ENABLED       
    771                  case(D_FLUX_MENU):    
    772                    switch(bKey)
    773                    {
    774                      case UP:
    775                        if (PID_Flux_InitStructure.hKd_Gain <= S16_MAX - KD_GAIN_INC_DEC)
    776                        {
    777                          PID_Flux_InitStructure.hKd_Gain += KD_GAIN_INC_DEC;
    778                        }
    779                      break;
    780                        
    781                      case DOWN:
    782                        if (PID_Flux_InitStructure.hKd_Gain >= KD_GAIN_INC_DEC)
    783                        {
    784                        PID_Flux_InitStructure.hKd_Gain -= KD_GAIN_INC_DEC;
    785                        }
    786                      break;
    787                     
    788                      case RIGHT:
    789          #ifdef FLUX_WEAKENING
    790                          bMenu_index = P_VOLT_MENU;
    791          #else
    792                          bMenu_index = POWER_STAGE_MENU;
    793          #endif                
    794                      break;
    795                      
    796                      case LEFT:              
    797                        bMenu_index = I_FLUX_MENU;
    798                      break;
    799                      
    800                      case SEL:
    801                        if (State == RUN || State == START)
    802                        {
    803                          State = STOP;               
    804                        }
    805                        else if(State == IDLE)
    806                        {
    807                          State = INIT;
    808                        }   
    809                      break;
    810                    default:
    811                      break;
    812                    }
    813                  break;   
    814          #endif
    815          
    816          #ifdef FLUX_WEAKENING        
    817                   case(P_VOLT_MENU):    
    818                    switch(bKey)
    819                    {
    820                      case UP:
    821                        if (hFW_P_Gain <= 32500)
    822                        {
    823                          hFW_P_Gain += KP_VOLT_INC_DEC;
    824                        }
    825                      break;
    826                        
    827                      case DOWN:
    828                        if (hFW_P_Gain >= KP_VOLT_INC_DEC)
    829                        {
    830                          hFW_P_Gain -= KP_VOLT_INC_DEC;
    831                        }
    832                      break;
    833                     
    834                      case RIGHT:
    835                          bMenu_index = I_VOLT_MENU;
    836                      break;
    837                       
    838                      case LEFT:
    839          #ifdef DIFFERENTIAL_TERM_ENABLED            
    840                        bMenu_index = D_FLUX_MENU;
    841          #else              
    842                        bMenu_index = I_FLUX_MENU;
    843          #endif              
    844                      break;
    845                      
    846                      case SEL:
    847                        if (State == RUN)
    848                        {
    849                          State = STOP;               
    850                        }
    851                          else if (State== START)
    852                          {
    853                            State = STOP; 
    854                          }
    855                            else if(State == IDLE)
    856                            {
    857                              State = INIT;
    858                            }   
    859                      break;
    860                    default:
    861                      break;
    862                    }
    863                  break;
    864                  
    865                  case(I_VOLT_MENU):    
    866                    switch(bKey)
    867                    {
    868                      case UP:
    869                        if (hFW_I_Gain <= 32500)
    870                        {
    871                          hFW_I_Gain += KI_VOLT_INC_DEC;
    872                        }
    873                      break;
    874                        
    875                      case DOWN:
    876                        if (hFW_I_Gain >= KI_VOLT_INC_DEC)
    877                        {
    878                          hFW_I_Gain -= KI_VOLT_INC_DEC;
    879                        }
    880                      break;
    881                     
    882                      case RIGHT:
    883                          bMenu_index = TARGET_VOLT_MENU;
    884                      break;
    885          
    886                      case LEFT:
    887                        bMenu_index = P_VOLT_MENU;
    888                      break;
    889                      
    890                      case SEL:
    891                        if (State == RUN)
    892                        {
    893                          State = STOP;               
    894                        }
    895                          else if (State== START)
    896                          {
    897                            State = STOP; 
    898                          }
    899                            else if(State == IDLE)
    900                            {
    901                              State = INIT;
    902                            }   
    903                      break;
    904                    default:
    905                      break;
    906                    }
    907                  break;
    908                  
    909                  case(TARGET_VOLT_MENU):    
    910                    switch(bKey)
    911                    {
    912                      case UP:
    913                        if (hFW_V_Ref <= (1000-VOLT_LIM_INC_DEC))
    914                        {
    915                          hFW_V_Ref += VOLT_LIM_INC_DEC;
    916                        }
    917                      break;
    918                        
    919                      case DOWN:
    920                        if (hFW_V_Ref >= VOLT_LIM_INC_DEC)
    921                        {
    922                          hFW_V_Ref -= VOLT_LIM_INC_DEC;
    923                        }
    924                      break;
    925                     
    926                      case RIGHT:
    927                          bMenu_index = POWER_STAGE_MENU;
    928                      break;
    929          
    930                      case LEFT:
    931                        bMenu_index = I_VOLT_MENU;
    932                      break;
    933                      
    934                      case SEL:
    935                        if (State == RUN)
    936                        {
    937                          State = STOP;               
    938                        }
    939                          else if (State== START)
    940                          {
    941                            State = STOP; 
    942                          }
    943                            else if(State == IDLE)
    944                            {
    945                              State = INIT;
    946                            }   
    947                      break;
    948                    default:
    949                      break;
    950                    }
    951                  break;        
    952                  
    953          #endif        
    954                  
    955                  case(POWER_STAGE_MENU):
    956                    switch(bKey)
   \                     ??KEYS_process_45:
   \   00000336   0x2801             CMP      R0,#+1
   \   00000338   0xD008             BEQ.N    ??KEYS_process_46
   \   0000033A   0xF0C0 0x8198      BCC.W    ??KEYS_process_1
   \   0000033E   0x2803             CMP      R0,#+3
   \   00000340   0xD002             BEQ.N    ??KEYS_process_39
   \   00000342   0xF0C0 0x80ED      BCC.W    ??KEYS_process_47
   \   00000346   0xBD01             POP      {R0,PC}
    957                    {
    958                      case RIGHT:  
    959          #ifdef OBSERVER_GAIN_TUNING
    960                        bMenu_index = K1_MENU;
    961          #elif defined DAC_FUNCTIONALITY
    962                        bMenu_index = DAC_PB0_MENU;
    963          #else              
    964                        if ((wGlobal_Flags & SPEED_CONTROL == SPEED_CONTROL))
    965                        {
    966                          if (State == IDLE)
    967                          {
    968                            bMenu_index = CONTROL_MODE_MENU_1;
    969                          }
    970                          else
    971                          {
    972                            bMenu_index = REF_SPEED_MENU;
    973                          }
    974                        }
    975                        else //Torque control
    976                        {
    977                          if (State == IDLE)
    978                          {
    979                            bMenu_index = CONTROL_MODE_MENU_6;
    980                          }
    981                          else
    982                          {
    983                            bMenu_index = IQ_REF_MENU;
    984                          }
    985                        }
    986          #endif              
    987                      break;
    988                      
    989                      case LEFT:
    990          #ifdef FLUX_WEAKENING
    991                        bMenu_index = TARGET_VOLT_MENU;              
    992          #elif defined DIFFERENTIAL_TERM_ENABLED            
    993                        bMenu_index = D_FLUX_MENU;
    994          #else
    995                        bMenu_index = I_FLUX_MENU;                          
   \                     ??KEYS_process_39:
   \   00000348   0x2009             MOVS     R0,#+9
   \   0000034A   0xE184             B.N      ??KEYS_process_7
    996          #endif              
    997                      break;
    998                      
    999                      case SEL:
   1000                        if (State == RUN)
   \                     ??KEYS_process_46:
   \   0000034C   0x.... 0x....      LDR.W    R0,??DataTable3_5
   \   00000350   0x7801             LDRB     R1,[R0, #+0]
   \   00000352   0x2903             CMP      R1,#+3
   \   00000354   0xBF1C             ITT      NE 
   \   00000356   0x7801             LDRBNE   R1,[R0, #+0]
   \   00000358   0x2902             CMPNE    R1,#+2
   1001                        {
   1002                          State = STOP;               
   1003                        }
   1004                          else if (State== START)
   \   0000035A   0xF000 0x8184      BEQ.W    ??KEYS_process_8
   1005                          {
   1006                            State = STOP; 
   1007                          }
   1008                            else if(State == IDLE)
   \   0000035E   0x7801             LDRB     R1,[R0, #+0]
   \   00000360   0x2900             CMP      R1,#+0
   \   00000362   0xF040 0x8184      BNE.W    ??KEYS_process_1
   1009                            {
   1010                              State = INIT;
   \   00000366   0xE180             B.N      ??KEYS_process_16
   1011                            }   
   1012                      break;
   1013                    default:
   1014                      break;
   1015                    }
   1016                  break; 
   1017                  
   1018                  case(CONTROL_MODE_MENU_6):
   1019                    switch(bKey)
   \                     ??KEYS_process_48:
   \   00000368   0x2801             CMP      R0,#+1
   \   0000036A   0xD014             BEQ.N    ??KEYS_process_49
   \   0000036C   0xF0C0 0x817F      BCC.W    ??KEYS_process_1
   \   00000370   0x2803             CMP      R0,#+3
   \   00000372   0xD00E             BEQ.N    ??KEYS_process_50
   \   00000374   0xD30B             BCC.N    ??KEYS_process_51
   \   00000376   0x2805             CMP      R0,#+5
   \   00000378   0xD001             BEQ.N    ??KEYS_process_52
   \   0000037A   0xF080 0x8178      BCS.W    ??KEYS_process_1
   1020                    {
   1021                      case UP:
   1022                      case DOWN:
   1023                        wGlobal_Flags ^= SPEED_CONTROL;
   \                     ??KEYS_process_52:
   \   0000037E   0x.... 0x....      LDR.W    R0,??DataTable3_4
   \   00000382   0x6802             LDR      R2,[R0, #+0]
   \   00000384   0xF082 0x0201      EOR      R2,R2,#0x1
   \   00000388   0x6002             STR      R2,[R0, #+0]
   1024                        bMenu_index = CONTROL_MODE_MENU_1;
   \   0000038A   0x2000             MOVS     R0,#+0
   \   0000038C   0xE163             B.N      ??KEYS_process_7
   1025                      break;
   1026                      
   1027                      case RIGHT:
   1028                          bMenu_index = IQ_REF_MENU;
   \                     ??KEYS_process_51:
   \   0000038E   0x200D             MOVS     R0,#+13
   \   00000390   0xE161             B.N      ??KEYS_process_7
   1029                      break;
   1030                      
   1031                      case LEFT:
   1032          #ifdef DAC_FUNCTIONALITY              
   1033                        bMenu_index = DAC_PB1_MENU;
   \                     ??KEYS_process_50:
   \   00000392   0x2016             MOVS     R0,#+22
   \   00000394   0xE15F             B.N      ??KEYS_process_7
   1034          #elif defined OBSERVER_GAIN_TUNING
   1035                        bMenu_index = I_PLL_MENU;          
   1036          #else              
   1037                        bMenu_index = POWER_STAGE_MENU;
   1038          #endif 
   1039                      break;
   1040                      
   1041                      case SEL:
   1042                        if (State == RUN)
   \                     ??KEYS_process_49:
   \   00000396   0x....             LDR.N    R0,??DataTable3_5
   \   00000398   0x7802             LDRB     R2,[R0, #+0]
   \   0000039A   0x2A03             CMP      R2,#+3
   \   0000039C   0xBF1C             ITT      NE 
   \   0000039E   0x7802             LDRBNE   R2,[R0, #+0]
   \   000003A0   0x2A02             CMPNE    R2,#+2
   1043                        {
   1044                          State = STOP;               
   1045                        }
   1046                          else if (State== START)
   \   000003A2   0xF000 0x8160      BEQ.W    ??KEYS_process_8
   1047                          {
   1048                            State = STOP; 
   1049                          }
   1050                            else if(State == IDLE)
   \   000003A6   0x7802             LDRB     R2,[R0, #+0]
   \   000003A8   0x2A00             CMP      R2,#+0
   \   000003AA   0xF040 0x8160      BNE.W    ??KEYS_process_1
   1051                            {
   1052                              State = INIT;
   \   000003AE   0x2201             MOVS     R2,#+1
   \   000003B0   0x7002             STRB     R2,[R0, #+0]
   1053                              bMenu_index = IQ_REF_MENU;
   \   000003B2   0x200D             MOVS     R0,#+13
   \   000003B4   0xE14F             B.N      ??KEYS_process_7
   1054                            }   
   1055                      break;
   1056                      default:
   1057                      break;
   1058                    }
   1059                  break;  
   1060                  
   1061                  case(IQ_REF_MENU):
   1062                    switch(bKey)
   \                     ??KEYS_process_53:
   \   000003B6   0x2801             CMP      R0,#+1
   \   000003B8   0xD026             BEQ.N    ??KEYS_process_54
   \   000003BA   0xF0C0 0x8158      BCC.W    ??KEYS_process_1
   \   000003BE   0x2803             CMP      R0,#+3
   \   000003C0   0xD01B             BEQ.N    ??KEYS_process_55
   \   000003C2   0xD318             BCC.N    ??KEYS_process_56
   \   000003C4   0x2805             CMP      R0,#+5
   \   000003C6   0xD00C             BEQ.N    ??KEYS_process_57
   \   000003C8   0xF080 0x8151      BCS.W    ??KEYS_process_1
   1063                    {
   1064                      case UP:
   1065                        if (hTorque_Reference <= NOMINAL_CURRENT - TORQUE_INC_DEC)
   \   000003CC   0x....             LDR.N    R0,??DataTable3_11
   \   000003CE   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   000003D2   0xF640 0x328B      MOVW     R2,#+2955
   \   000003D6   0x4291             CMP      R1,R2
   \   000003D8   0xF280 0x8149      BGE.W    ??KEYS_process_1
   1066                        {
   1067                          hTorque_Reference += TORQUE_INC_DEC;
   \   000003DC   0x8801             LDRH     R1,[R0, #+0]
   \   000003DE   0x31FA             ADDS     R1,R1,#+250
   \   000003E0   0xE0EC             B.N      ??KEYS_process_15
   1068                        }
   1069                      break;
   1070                      
   1071                      case DOWN:
   1072                      if (hTorque_Reference >= -NOMINAL_CURRENT + TORQUE_INC_DEC)
   \                     ??KEYS_process_57:
   \   000003E2   0x....             LDR.N    R0,??DataTable3_11
   \   000003E4   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   000003E8   0x....             LDR.N    R2,??DataTable3_12  ;; 0xfffff476
   \   000003EA   0x4291             CMP      R1,R2
   \   000003EC   0xF2C0 0x813F      BLT.W    ??KEYS_process_1
   1073                      {
   1074                        hTorque_Reference -= TORQUE_INC_DEC;
   \   000003F0   0x8801             LDRH     R1,[R0, #+0]
   \   000003F2   0x39FA             SUBS     R1,R1,#+250
   \   000003F4   0xE0E2             B.N      ??KEYS_process_15
   1075                      }
   1076                      break;
   1077                      
   1078                      case RIGHT:
   1079                          bMenu_index = ID_REF_MENU;
   \                     ??KEYS_process_56:
   \   000003F6   0x200E             MOVS     R0,#+14
   \   000003F8   0xE12D             B.N      ??KEYS_process_7
   1080                      break;
   1081                      
   1082                      case LEFT:
   1083                        if(State == IDLE)
   \                     ??KEYS_process_55:
   \   000003FA   0x....             LDR.N    R0,??DataTable3_5
   \   000003FC   0x7800             LDRB     R0,[R0, #+0]
   \   000003FE   0x2800             CMP      R0,#+0
   \   00000400   0xBF14             ITE      NE 
   \   00000402   0x2016             MOVNE    R0,#+22
   \   00000404   0x200C             MOVEQ    R0,#+12
   1084                        {
   1085                          bMenu_index = CONTROL_MODE_MENU_6;
   \   00000406   0xE126             B.N      ??KEYS_process_7
   1086                        }
   1087                        else
   1088                        {
   1089          #ifdef DAC_FUNCTIONALITY              
   1090                        bMenu_index = DAC_PB1_MENU;
   1091          #elif defined OBSERVER_GAIN_TUNING
   1092                        bMenu_index = I_PLL_MENU;          
   1093          #else              
   1094                        bMenu_index = POWER_STAGE_MENU;
   1095          #endif 
   1096                        }
   1097                      break;
   1098                      
   1099                      case SEL:
   1100                        if (State == RUN)
   \                     ??KEYS_process_54:
   \   00000408   0x....             LDR.N    R0,??DataTable3_5
   \   0000040A   0x7801             LDRB     R1,[R0, #+0]
   \   0000040C   0x2903             CMP      R1,#+3
   \   0000040E   0xBF1C             ITT      NE 
   \   00000410   0x7801             LDRBNE   R1,[R0, #+0]
   \   00000412   0x2902             CMPNE    R1,#+2
   1101                        {
   1102                          State = STOP;               
   1103                        }
   1104                          else if (State== START)
   \   00000414   0xF000 0x8127      BEQ.W    ??KEYS_process_8
   1105                          {
   1106                            State = STOP; 
   1107                          }
   1108                            else if(State == IDLE)
   \   00000418   0x7801             LDRB     R1,[R0, #+0]
   \   0000041A   0x2900             CMP      R1,#+0
   \   0000041C   0xF040 0x8127      BNE.W    ??KEYS_process_1
   1109                            {
   1110                              State = INIT;
   \   00000420   0xE123             B.N      ??KEYS_process_16
   1111                            }   
   1112                      break;
   1113                      default:
   1114                      break;
   1115                    }
   1116                  break;    
   1117                  
   1118                  case(ID_REF_MENU):
   1119                    switch(bKey)
   \                     ??KEYS_process_58:
   \   00000422   0x2801             CMP      R0,#+1
   \   00000424   0xD021             BEQ.N    ??KEYS_process_59
   \   00000426   0xF0C0 0x8122      BCC.W    ??KEYS_process_1
   \   0000042A   0x2803             CMP      R0,#+3
   \   0000042C   0xD01B             BEQ.N    ??KEYS_process_60
   \   0000042E   0xD318             BCC.N    ??KEYS_process_24
   \   00000430   0x2805             CMP      R0,#+5
   \   00000432   0xD00C             BEQ.N    ??KEYS_process_61
   \   00000434   0xF080 0x811B      BCS.W    ??KEYS_process_1
   1120                    {
   1121                      case UP:
   1122                        if (hFlux_Reference <= NOMINAL_CURRENT - FLUX_INC_DEC)
   \   00000438   0x....             LDR.N    R0,??DataTable3_13
   \   0000043A   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   0000043E   0xF640 0x328B      MOVW     R2,#+2955
   \   00000442   0x4291             CMP      R1,R2
   \   00000444   0xF280 0x8113      BGE.W    ??KEYS_process_1
   1123                        {
   1124                          hFlux_Reference += FLUX_INC_DEC;
   \   00000448   0x8801             LDRH     R1,[R0, #+0]
   \   0000044A   0x31FA             ADDS     R1,R1,#+250
   \   0000044C   0xE0B6             B.N      ??KEYS_process_15
   1125                        }
   1126                      break;
   1127                      
   1128                      case DOWN:
   1129                        if (hFlux_Reference >= FLUX_INC_DEC - NOMINAL_CURRENT)
   \                     ??KEYS_process_61:
   \   0000044E   0x....             LDR.N    R0,??DataTable3_13
   \   00000450   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   00000454   0x....             LDR.N    R2,??DataTable3_12  ;; 0xfffff476
   \   00000456   0x4291             CMP      R1,R2
   \   00000458   0xF2C0 0x8109      BLT.W    ??KEYS_process_1
   1130                        {
   1131                          hFlux_Reference -= FLUX_INC_DEC;
   \   0000045C   0x8801             LDRH     R1,[R0, #+0]
   \   0000045E   0x39FA             SUBS     R1,R1,#+250
   \   00000460   0xE0AC             B.N      ??KEYS_process_15
   1132                        }
   1133                      break;
   1134                      
   1135                      case RIGHT:
   1136                        bMenu_index = P_TORQUE_MENU;
   \                     ??KEYS_process_24:
   \   00000462   0x2005             MOVS     R0,#+5
   \   00000464   0xE0F7             B.N      ??KEYS_process_7
   1137                      break;
   1138                      
   1139                      case LEFT:
   1140                        bMenu_index = IQ_REF_MENU;
   \                     ??KEYS_process_60:
   \   00000466   0x200D             MOVS     R0,#+13
   \   00000468   0xE0F5             B.N      ??KEYS_process_7
   1141                      break;
   1142                      
   1143                      case SEL:
   1144                        if (State == RUN)
   \                     ??KEYS_process_59:
   \   0000046A   0x....             LDR.N    R0,??DataTable3_5
   \   0000046C   0x7801             LDRB     R1,[R0, #+0]
   \   0000046E   0x2903             CMP      R1,#+3
   \   00000470   0xBF1C             ITT      NE 
   \   00000472   0x7801             LDRBNE   R1,[R0, #+0]
   \   00000474   0x2902             CMPNE    R1,#+2
   1145                        {
   1146                          State = STOP;               
   1147                        }
   1148                          else if (State== START)
   \   00000476   0xF000 0x80F6      BEQ.W    ??KEYS_process_8
   1149                          {
   1150                            State = STOP; 
   1151                          }
   1152                            else if(State == IDLE)
   \   0000047A   0x7801             LDRB     R1,[R0, #+0]
   \   0000047C   0x2900             CMP      R1,#+0
   \   0000047E   0xF040 0x80F6      BNE.W    ??KEYS_process_1
   1153                            {
   1154                              State = INIT;
   \   00000482   0xE0F2             B.N      ??KEYS_process_16
   1155                            }   
   1156                      break;
   1157                      default:
   1158                      break;
   1159                    }
   1160                  break;
   1161          
   1162          #ifdef OBSERVER_GAIN_TUNING
   1163                  case(K1_MENU):    
   1164                    switch(bKey)
   \                     ??KEYS_process_62:
   \   00000484   0x2801             CMP      R0,#+1
   \   00000486   0xD01C             BEQ.N    ??KEYS_process_63
   \   00000488   0xF0C0 0x80F1      BCC.W    ??KEYS_process_1
   \   0000048C   0x2803             CMP      R0,#+3
   \   0000048E   0xD016             BEQ.N    ??KEYS_process_43
   \   00000490   0xD36D             BCC.N    ??KEYS_process_64
   \   00000492   0x2805             CMP      R0,#+5
   \   00000494   0xD00A             BEQ.N    ??KEYS_process_65
   \   00000496   0xF080 0x80EA      BCS.W    ??KEYS_process_1
   1165                    {
   1166                      case UP:
   1167                        if (wK1_LO <= -K1_INC_DEC)
   \   0000049A   0x....             LDR.N    R0,??DataTable3_14
   \   0000049C   0x6801             LDR      R1,[R0, #+0]
   \   0000049E   0xF111 0x0FF9      CMN      R1,#+249
   \   000004A2   0xF280 0x80E4      BGE.W    ??KEYS_process_1
   1168                        {
   1169                          wK1_LO += K1_INC_DEC;
   \   000004A6   0x6801             LDR      R1,[R0, #+0]
   \   000004A8   0x31FA             ADDS     R1,R1,#+250
   \   000004AA   0xE037             B.N      ??KEYS_process_66
   1170                        }
   1171                      break;  
   1172                       
   1173                      case DOWN:
   1174                        if (wK1_LO >= -600000)
   \                     ??KEYS_process_65:
   \   000004AC   0x....             LDR.N    R0,??DataTable3_14
   \   000004AE   0x6801             LDR      R1,[R0, #+0]
   \   000004B0   0x....             LDR.N    R2,??DataTable3_15  ;; 0xfff6d840
   \   000004B2   0x4291             CMP      R1,R2
   \   000004B4   0xF2C0 0x80DB      BLT.W    ??KEYS_process_1
   1175                        {
   1176                          wK1_LO -= K1_INC_DEC;
   \   000004B8   0x6801             LDR      R1,[R0, #+0]
   \   000004BA   0x39FA             SUBS     R1,R1,#+250
   \   000004BC   0xE02E             B.N      ??KEYS_process_66
   1177                        }
   1178                      break;
   1179                     
   1180                      case RIGHT:
   1181                        bMenu_index = K2_MENU;
   1182                      break;
   1183                       
   1184                      case LEFT:         
   1185                       bMenu_index = POWER_STAGE_MENU;
   \                     ??KEYS_process_43:
   \   000004BE   0x200B             MOVS     R0,#+11
   \   000004C0   0xE0C9             B.N      ??KEYS_process_7
   1186                      break;
   1187                      
   1188                      case SEL:
   1189                        if (State == RUN)
   \                     ??KEYS_process_63:
   \   000004C2   0x....             LDR.N    R0,??DataTable3_5
   \   000004C4   0x7801             LDRB     R1,[R0, #+0]
   \   000004C6   0x2903             CMP      R1,#+3
   \   000004C8   0xBF1C             ITT      NE 
   \   000004CA   0x7801             LDRBNE   R1,[R0, #+0]
   \   000004CC   0x2902             CMPNE    R1,#+2
   1190                        {
   1191                          State = STOP;               
   1192                        }
   1193                          else if (State== START)
   \   000004CE   0xF000 0x80CA      BEQ.W    ??KEYS_process_8
   1194                          {
   1195                            State = STOP; 
   1196                          }
   1197                            else if(State == IDLE)
   \   000004D2   0x7801             LDRB     R1,[R0, #+0]
   \   000004D4   0x2900             CMP      R1,#+0
   \   000004D6   0xF040 0x80CA      BNE.W    ??KEYS_process_1
   1198                            {
   1199                              State = INIT;
   \   000004DA   0xE0C6             B.N      ??KEYS_process_16
   1200                            }   
   1201                      break;
   1202                    default:
   1203                      break;
   1204                    }
   1205                    break;
   1206                  
   1207                  case(K2_MENU):    
   1208                    switch(bKey)
   \                     ??KEYS_process_67:
   \   000004DC   0x2801             CMP      R0,#+1
   \   000004DE   0xD021             BEQ.N    ??KEYS_process_68
   \   000004E0   0xF0C0 0x80C5      BCC.W    ??KEYS_process_1
   \   000004E4   0x2803             CMP      R0,#+3
   \   000004E6   0xD01B             BEQ.N    ??KEYS_process_47
   \   000004E8   0xD36A             BCC.N    ??KEYS_process_69
   \   000004EA   0x2805             CMP      R0,#+5
   \   000004EC   0xD00C             BEQ.N    ??KEYS_process_70
   \   000004EE   0xF080 0x80BE      BCS.W    ??KEYS_process_1
   1209                    {
   1210                      case UP:
   1211                        if (wK2_LO <= S16_MAX * 100 - K2_INC_DEC)
   \   000004F2   0x....             LDR.N    R0,??DataTable3_16
   \   000004F4   0x6801             LDR      R1,[R0, #+0]
   \   000004F6   0x....             LDR.N    R2,??DataTable3_17  ;; 0x31ec15
   \   000004F8   0x4291             CMP      R1,R2
   \   000004FA   0xF280 0x80B8      BGE.W    ??KEYS_process_1
   1212                        {
   1213                          wK2_LO += K2_INC_DEC;
   \   000004FE   0x6801             LDR      R1,[R0, #+0]
   \   00000500   0xF501 0x5198      ADD      R1,R1,#+4864
   \   00000504   0x3188             ADDS     R1,R1,#+136
   \   00000506   0xE009             B.N      ??KEYS_process_66
   1214                        }
   1215                      break;  
   1216                       
   1217                      case DOWN:
   1218                       if (wK2_LO >= K2_INC_DEC)
   \                     ??KEYS_process_70:
   \   00000508   0x....             LDR.N    R0,??DataTable3_16
   \   0000050A   0x6801             LDR      R1,[R0, #+0]
   \   0000050C   0xF241 0x3288      MOVW     R2,#+5000
   \   00000510   0x4291             CMP      R1,R2
   \   00000512   0xF2C0 0x80AC      BLT.W    ??KEYS_process_1
   1219                        {
   1220                          wK2_LO -= K2_INC_DEC;
   \   00000516   0x6801             LDR      R1,[R0, #+0]
   \   00000518   0x....             LDR.N    R2,??DataTable3_18  ;; 0xffffec78
   \   0000051A   0x1851             ADDS     R1,R2,R1
   \                     ??KEYS_process_66:
   \   0000051C   0x6001             STR      R1,[R0, #+0]
   \   0000051E   0xBD01             POP      {R0,PC}
   1221                        }
   1222                      break;
   1223                     
   1224                      case RIGHT:
   1225                        bMenu_index = P_PLL_MENU;
   1226                      break;
   1227                       
   1228                      case LEFT:         
   1229                       bMenu_index = K1_MENU;
   \                     ??KEYS_process_47:
   \   00000520   0x2011             MOVS     R0,#+17
   \   00000522   0xE098             B.N      ??KEYS_process_7
   1230                      break;
   1231                      
   1232                      case SEL:
   1233                        if (State == RUN)
   \                     ??KEYS_process_68:
   \   00000524   0x....             LDR.N    R0,??DataTable3_5
   \   00000526   0x7801             LDRB     R1,[R0, #+0]
   \   00000528   0x2903             CMP      R1,#+3
   \   0000052A   0xBF1C             ITT      NE 
   \   0000052C   0x7801             LDRBNE   R1,[R0, #+0]
   \   0000052E   0x2902             CMPNE    R1,#+2
   1234                        {
   1235                          State = STOP;               
   1236                        }
   1237                          else if (State== START)
   \   00000530   0xF000 0x8099      BEQ.W    ??KEYS_process_8
   1238                          {
   1239                            State = STOP; 
   1240                          }
   1241                            else if(State == IDLE)
   \   00000534   0x7801             LDRB     R1,[R0, #+0]
   \   00000536   0x2900             CMP      R1,#+0
   \   00000538   0xF040 0x8099      BNE.W    ??KEYS_process_1
   1242                            {
   1243                              State = INIT;
   \   0000053C   0xE095             B.N      ??KEYS_process_16
   1244                            }   
   1245                      break;
   1246                    default:
   1247                      break;
   1248                    }
   1249                    break;
   1250                    
   1251                   case(P_PLL_MENU):    
   1252                    switch(bKey)
   \                     ??KEYS_process_71:
   \   0000053E   0x2801             CMP      R0,#+1
   \   00000540   0xD017             BEQ.N    ??KEYS_process_72
   \   00000542   0xF0C0 0x8094      BCC.W    ??KEYS_process_1
   \   00000546   0x2803             CMP      R0,#+3
   \   00000548   0xD011             BEQ.N    ??KEYS_process_64
   \   0000054A   0xD356             BCC.N    ??KEYS_process_73
   \   0000054C   0x2805             CMP      R0,#+5
   \   0000054E   0xD00C             BEQ.N    ??KEYS_process_74
   \   00000550   0xF080 0x808D      BCS.W    ??KEYS_process_1
   1253                    {
   1254                      case UP:
   1255                       if (hPLL_P_Gain <= 32000)
   \   00000554   0x....             LDR.N    R0,??DataTable3_19
   \   00000556   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   0000055A   0xF647 0x5201      MOVW     R2,#+32001
   \   0000055E   0x4291             CMP      R1,R2
   \   00000560   0xF280 0x8085      BGE.W    ??KEYS_process_1
   1256                        {
   1257                          hPLL_P_Gain += PLL_IN_DEC;
   \   00000564   0x8801             LDRH     R1,[R0, #+0]
   \   00000566   0x3119             ADDS     R1,R1,#+25
   \   00000568   0xE028             B.N      ??KEYS_process_15
   1258                        } 
   1259                      break;  
   1260                       
   1261                      case DOWN:
   1262                       if (hPLL_P_Gain > 0)
   \                     ??KEYS_process_74:
   \   0000056A   0x....             LDR.N    R0,??DataTable3_19
   \   0000056C   0xE020             B.N      ??KEYS_process_75
   1263                        {
   1264                          hPLL_P_Gain -= PLL_IN_DEC;
   1265                        } 
   1266                      break;
   1267                     
   1268                      case RIGHT:
   1269                        bMenu_index = I_PLL_MENU;
   1270                      break;
   1271                       
   1272                      case LEFT:         
   1273                       bMenu_index = K2_MENU;
   \                     ??KEYS_process_64:
   \   0000056E   0x2012             MOVS     R0,#+18
   \   00000570   0xE071             B.N      ??KEYS_process_7
   1274                      break;
   1275                      
   1276                      case SEL:
   1277                        if (State == RUN)
   \                     ??KEYS_process_72:
   \   00000572   0x....             LDR.N    R0,??DataTable3_5
   \   00000574   0x7801             LDRB     R1,[R0, #+0]
   \   00000576   0x2903             CMP      R1,#+3
   \   00000578   0xBF1C             ITT      NE 
   \   0000057A   0x7801             LDRBNE   R1,[R0, #+0]
   \   0000057C   0x2902             CMPNE    R1,#+2
   1278                        {
   1279                          State = STOP;               
   1280                        }
   1281                          else if (State== START)
   \   0000057E   0xD072             BEQ.N    ??KEYS_process_8
   1282                          {
   1283                            State = STOP; 
   1284                          }
   1285                            else if(State == IDLE)
   \   00000580   0x7801             LDRB     R1,[R0, #+0]
   \   00000582   0x2900             CMP      R1,#+0
   \   00000584   0xD173             BNE.N    ??KEYS_process_1
   1286                            {
   1287                              State = INIT;
   \   00000586   0xE070             B.N      ??KEYS_process_16
   1288                            }   
   1289                      break;
   1290                    default:
   1291                      break;
   1292                    }
   1293                    break;
   1294                    
   1295                  case(I_PLL_MENU):    
   1296                    switch(bKey)
   \                     ??KEYS_process_76:
   \   00000588   0x2801             CMP      R0,#+1
   \   0000058A   0xD01B             BEQ.N    ??KEYS_process_77
   \   0000058C   0xD36F             BCC.N    ??KEYS_process_1
   \   0000058E   0x2803             CMP      R0,#+3
   \   00000590   0xD016             BEQ.N    ??KEYS_process_69
   \   00000592   0xD35F             BCC.N    ??KEYS_process_78
   \   00000594   0x2805             CMP      R0,#+5
   \   00000596   0xD00A             BEQ.N    ??KEYS_process_79
   \   00000598   0xD269             BCS.N    ??KEYS_process_1
   1297                    {
   1298                      case UP:
   1299                       if (hPLL_I_Gain <= 32000)
   \   0000059A   0x....             LDR.N    R0,??DataTable3_20
   \   0000059C   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   000005A0   0xF647 0x5201      MOVW     R2,#+32001
   \   000005A4   0x4291             CMP      R1,R2
   \   000005A6   0xDA62             BGE.N    ??KEYS_process_1
   1300                        {
   1301                          hPLL_I_Gain += PLL_IN_DEC;
   \   000005A8   0x8801             LDRH     R1,[R0, #+0]
   \   000005AA   0x3119             ADDS     R1,R1,#+25
   \   000005AC   0xE006             B.N      ??KEYS_process_15
   1302                        } 
   1303                      break;  
   1304                       
   1305                      case DOWN:
   1306                       if (hPLL_I_Gain > 0)
   \                     ??KEYS_process_79:
   \   000005AE   0x....             LDR.N    R0,??DataTable3_20
   \                     ??KEYS_process_75:
   \   000005B0   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   000005B4   0x2901             CMP      R1,#+1
   \   000005B6   0xDB5A             BLT.N    ??KEYS_process_1
   1307                        {
   1308                          hPLL_I_Gain -= PLL_IN_DEC;
   \   000005B8   0x8801             LDRH     R1,[R0, #+0]
   \   000005BA   0x3919             SUBS     R1,R1,#+25
   \                     ??KEYS_process_15:
   \   000005BC   0x8001             STRH     R1,[R0, #+0]
   \   000005BE   0xBD01             POP      {R0,PC}
   1309                        } 
   1310                      break;
   1311                     
   1312                      case RIGHT:
   1313          #ifdef DAC_FUNCTIONALITY
   1314                        bMenu_index = DAC_PB0_MENU;  
   1315          #else
   1316                        if ((wGlobal_Flags & SPEED_CONTROL == SPEED_CONTROL))
   1317                        {
   1318                          if (State == IDLE)
   1319                          {
   1320                            bMenu_index = CONTROL_MODE_MENU_1;
   1321                          }
   1322                          else
   1323                          {
   1324                            bMenu_index = REF_SPEED_MENU;
   1325                          }
   1326                        }
   1327                        else //Torque control
   1328                        {
   1329                          if (State == IDLE)
   1330                          {
   1331                            bMenu_index = CONTROL_MODE_MENU_6;
   1332                          }
   1333                          else
   1334                          {
   1335                            bMenu_index = IQ_REF_MENU;
   1336                          }
   1337                        }
   1338          #endif              
   1339                      break;
   1340                       
   1341                      case LEFT:         
   1342                        bMenu_index = P_PLL_MENU;
   \                     ??KEYS_process_69:
   \   000005C0   0x2013             MOVS     R0,#+19
   \   000005C2   0xE048             B.N      ??KEYS_process_7
   1343                      break;
   1344                      
   1345                      case SEL:
   1346                        if (State == RUN)
   \                     ??KEYS_process_77:
   \   000005C4   0x....             LDR.N    R0,??DataTable3_5
   \   000005C6   0x7801             LDRB     R1,[R0, #+0]
   \   000005C8   0x2903             CMP      R1,#+3
   \   000005CA   0xBF1C             ITT      NE 
   \   000005CC   0x7801             LDRBNE   R1,[R0, #+0]
   \   000005CE   0x2902             CMPNE    R1,#+2
   1347                        {
   1348                          State = STOP;               
   1349                        }
   1350                          else if (State== START)
   \   000005D0   0xD049             BEQ.N    ??KEYS_process_8
   1351                          {
   1352                            State = STOP; 
   1353                          }
   1354                            else if(State == IDLE)
   \   000005D2   0x7801             LDRB     R1,[R0, #+0]
   \   000005D4   0x2900             CMP      R1,#+0
   \   000005D6   0xD14A             BNE.N    ??KEYS_process_1
   1355                            {
   1356                              State = INIT;
   \   000005D8   0xE047             B.N      ??KEYS_process_16
   1357                            }   
   1358                      break;
   1359                    default:
   1360                      break;
   1361                    }
   1362                    break;          
   1363          #endif
   1364            
   1365          #ifdef DAC_FUNCTIONALITY  
   1366                  case(DAC_PB0_MENU):    
   1367                    switch(bKey)
   \                     ??KEYS_process_80:
   \   000005DA   0x2801             CMP      R0,#+1
   \   000005DC   0xD00F             BEQ.N    ??KEYS_process_81
   \   000005DE   0xD346             BCC.N    ??KEYS_process_1
   \   000005E0   0x2803             CMP      R0,#+3
   \   000005E2   0xD00A             BEQ.N    ??KEYS_process_73
   \   000005E4   0xD307             BCC.N    ??KEYS_process_82
   \   000005E6   0x2805             CMP      R0,#+5
   \   000005E8   0xD003             BEQ.N    ??KEYS_process_83
   \   000005EA   0xD240             BCS.N    ??KEYS_process_1
   1368                    {
   1369                      case UP:
   1370                        MCDAC_Output_Choice(1,DAC_CH1);
   \   000005EC   0x2101             MOVS     R1,#+1
   \   000005EE   0x2001             MOVS     R0,#+1
   \   000005F0   0xE01B             B.N      ??KEYS_process_84
   1371                      break;
   1372                      
   1373                      case DOWN:
   1374                        MCDAC_Output_Choice(-1,DAC_CH1);
   \                     ??KEYS_process_83:
   \   000005F2   0x2101             MOVS     R1,#+1
   \   000005F4   0xE017             B.N      ??KEYS_process_85
   1375                      break;  
   1376                     
   1377                      case RIGHT:                
   1378                          bMenu_index = DAC_PB1_MENU;               
   \                     ??KEYS_process_82:
   \   000005F6   0x2016             MOVS     R0,#+22
   \   000005F8   0xE02D             B.N      ??KEYS_process_7
   1379                      break;
   1380                      
   1381                      case LEFT:
   1382          #ifdef OBSERVER_GAIN_TUNING              
   1383                        bMenu_index = I_PLL_MENU;
   \                     ??KEYS_process_73:
   \   000005FA   0x2014             MOVS     R0,#+20
   \   000005FC   0xE02B             B.N      ??KEYS_process_7
   1384          #else
   1385                        bMenu_index = POWER_STAGE_MENU;
   1386          #endif              
   1387                      break;
   1388                      
   1389                      case SEL:
   1390                        switch(State)
   \                     ??KEYS_process_81:
   \   000005FE   0x....             LDR.N    R0,??DataTable3_5
   \   00000600   0x7801             LDRB     R1,[R0, #+0]
   \   00000602   0xB391             CBZ.N    R1,??KEYS_process_16
   \   00000604   0x1E89             SUBS     R1,R1,#+2
   \   00000606   0x2901             CMP      R1,#+1
   \   00000608   0xD92D             BLS.N    ??KEYS_process_8
   \   0000060A   0xBD01             POP      {R0,PC}
   1391                        {
   1392                        case RUN:
   1393                          State = STOP;
   1394                          break;
   1395                        case START:
   1396                          State = STOP;
   1397                          break;
   1398                        case IDLE:
   1399                          State = INIT;
   1400                          break;
   1401                        default:
   1402                          break;                
   1403                        }   
   1404                      break;
   1405                    default:
   1406                      break;
   1407                    }
   1408                  break;   
   1409          
   1410                  case(DAC_PB1_MENU):    
   1411                    switch(bKey)
   \                     ??KEYS_process_86:
   \   0000060C   0x2801             CMP      R0,#+1
   \   0000060E   0xD024             BEQ.N    ??KEYS_process_87
   \   00000610   0xD32D             BCC.N    ??KEYS_process_1
   \   00000612   0x2803             CMP      R0,#+3
   \   00000614   0xD01E             BEQ.N    ??KEYS_process_78
   \   00000616   0xD30C             BCC.N    ??KEYS_process_88
   \   00000618   0x2805             CMP      R0,#+5
   \   0000061A   0xD003             BEQ.N    ??KEYS_process_89
   \   0000061C   0xD227             BCS.N    ??KEYS_process_1
   1412                    {
   1413                      case UP:
   1414                        MCDAC_Output_Choice(1,DAC_CH2);
   \   0000061E   0x2102             MOVS     R1,#+2
   \   00000620   0x2001             MOVS     R0,#+1
   \   00000622   0xE002             B.N      ??KEYS_process_84
   1415                      break;
   1416                      
   1417                      case DOWN:
   1418                        MCDAC_Output_Choice(-1,DAC_CH2);
   \                     ??KEYS_process_89:
   \   00000624   0x2102             MOVS     R1,#+2
   \                     ??KEYS_process_85:
   \   00000626   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??KEYS_process_84:
   \   0000062A   0xE8BD 0x4004      POP      {R2,LR}
   \   0000062E   0x.... 0x....      B.W      MCDAC_Output_Choice
   1419                      break;  
   1420                     
   1421                      case RIGHT:                
   1422                      if ((wGlobal_Flags & SPEED_CONTROL == SPEED_CONTROL))
   \                     ??KEYS_process_88:
   \   00000632   0x....             LDR.N    R0,??DataTable3_5
   \   00000634   0x....             LDR.N    R2,??DataTable3_4
   \   00000636   0x6812             LDR      R2,[R2, #+0]
   \   00000638   0x07D2             LSLS     R2,R2,#+31
   \   0000063A   0x7800             LDRB     R0,[R0, #+0]
   \   0000063C   0xD505             BPL.N    ??KEYS_process_90
   1423                        {
   1424                          if (State == IDLE)
   \   0000063E   0x1E42             SUBS     R2,R0,#+1
   \   00000640   0x4192             SBCS     R2,R2,R2
   \   00000642   0x43D2             MVNS     R2,R2
   \   00000644   0x0FD2             LSRS     R2,R2,#+31
   \                     ??KEYS_process_9:
   \   00000646   0x704A             STRB     R2,[R1, #+1]
   \   00000648   0xBD01             POP      {R0,PC}
   1425                          {
   1426                            bMenu_index = CONTROL_MODE_MENU_1;
   1427                          }
   1428                          else
   1429                          {
   1430                            bMenu_index = REF_SPEED_MENU;
   1431                          }
   1432                        }
   1433                        else //Torque control
   1434                        {
   1435                          if (State == IDLE)
   \                     ??KEYS_process_90:
   \   0000064A   0x2800             CMP      R0,#+0
   \   0000064C   0xBF14             ITE      NE 
   \   0000064E   0x200D             MOVNE    R0,#+13
   \   00000650   0x200C             MOVEQ    R0,#+12
   1436                          {
   1437                            bMenu_index = CONTROL_MODE_MENU_6;
   \   00000652   0xE000             B.N      ??KEYS_process_7
   1438                          }
   1439                          else
   1440                          {
   1441                            bMenu_index = IQ_REF_MENU;
   1442                          }
   1443                        }               
   1444                      break;
   1445                      
   1446                      case LEFT:             
   1447                        bMenu_index = DAC_PB0_MENU;
   \                     ??KEYS_process_78:
   \   00000654   0x2015             MOVS     R0,#+21
   \                     ??KEYS_process_7:
   \   00000656   0x7048             STRB     R0,[R1, #+1]
   1448                      break;
   \   00000658   0xBD01             POP      {R0,PC}
   1449                      
   1450                      case SEL:
   1451                        switch(State)
   \                     ??KEYS_process_87:
   \   0000065A   0x....             LDR.N    R0,??DataTable3_5
   \   0000065C   0x7801             LDRB     R1,[R0, #+0]
   \   0000065E   0xB121             CBZ.N    R1,??KEYS_process_16
   \   00000660   0x1E89             SUBS     R1,R1,#+2
   \   00000662   0x2901             CMP      R1,#+1
   \   00000664   0xD803             BHI.N    ??KEYS_process_1
   1452                        {
   1453                        case RUN:
   1454                          State = STOP;
   1455                          break;
   1456                        case START:
   1457                          State = STOP;
   \                     ??KEYS_process_8:
   \   00000666   0x2104             MOVS     R1,#+4
   \   00000668   0xE000             B.N      ??KEYS_process_91
   1458                          break;
   1459                        case IDLE:
   1460                          State = INIT;
   \                     ??KEYS_process_16:
   \   0000066A   0x2101             MOVS     R1,#+1
   \                     ??KEYS_process_91:
   \   0000066C   0x7001             STRB     R1,[R0, #+0]
   1461                          break;
   1462                        default:
   1463                          break;                
   1464                        }      
   1465                      break;
   1466                    default:
   1467                      break;
   1468                    }
   1469                  break; 
   1470          #endif 
   1471              
   1472                default:
   1473                  break; 
   1474                }
   1475          }
   \                     ??KEYS_process_1:
   \   0000066E   0xBD01             POP      {R0,PC}          ;; return
   1476          
   1477          /*******************************************************************************
   1478          * Function Name  : KEYS_ExportbKey
   1479          * Description    : Export bKey variable
   1480          * Input          : None
   1481          * Output         : None
   1482          * Return         : None
   1483          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1484          u8 KEYS_ExportbKey(void)
   1485          {
   1486            return(bKey);
   \                     KEYS_ExportbKey:
   \   00000000   0x....             LDR.N    R0,??DataTable3_3
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   1487          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x40010C00         DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     bPrevious_key

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x........         DC32     bKey

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x........         DC32     wGlobal_Flags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x........         DC32     State

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x........         DC32     hSpeed_Reference

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0xFFFFFDA8         DC32     0xfffffda8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \   00000000   0x........         DC32     PID_Speed_InitStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_9:
   \   00000000   0x........         DC32     PID_Torque_InitStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_10:
   \   00000000   0x........         DC32     PID_Flux_InitStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_11:
   \   00000000   0x........         DC32     hTorque_Reference

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_12:
   \   00000000   0xFFFFF476         DC32     0xfffff476

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_13:
   \   00000000   0x........         DC32     hFlux_Reference

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_14:
   \   00000000   0x........         DC32     wK1_LO

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_15:
   \   00000000   0xFFF6D840         DC32     0xfff6d840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_16:
   \   00000000   0x........         DC32     wK2_LO

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_17:
   \   00000000   0x0031EC15         DC32     0x31ec15

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_18:
   \   00000000   0xFFFFEC78         DC32     0xffffec78

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_19:
   \   00000000   0x........         DC32     hPLL_P_Gain

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_20:
   \   00000000   0x........         DC32     hPLL_I_Gain
   1488                             
   1489          /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
   1490          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  KEYS_ExportbKey
       16  KEYS_Init
             16 -> GPIO_Init
             16 -> GPIO_StructInit
             16 -> RCC_APB2PeriphClockCmd
       16  KEYS_Read
             16 -> GPIO_ReadInputDataBit
             16 -> TB_DebounceDelay_IsElapsed
             16 -> TB_Set_DebounceDelay_500us
        8  KEYS_process
              8 -> KEYS_Read
              0 -> MCDAC_Output_Choice


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_10
       4  ??DataTable3_11
       4  ??DataTable3_12
       4  ??DataTable3_13
       4  ??DataTable3_14
       4  ??DataTable3_15
       4  ??DataTable3_16
       4  ??DataTable3_17
       4  ??DataTable3_18
       4  ??DataTable3_19
       4  ??DataTable3_2
       4  ??DataTable3_20
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
       6  KEYS_ExportbKey
     132  KEYS_Init
     188  KEYS_Read
    1648  KEYS_process
       2  bKey
          bMenu_index
       2  bPrevious_key
          bKey_Flag

 
     4 bytes in section .bss
 2 058 bytes in section .text
 
 2 058 bytes of CODE memory
     4 bytes of DATA memory

Errors: none
Warnings: 3
