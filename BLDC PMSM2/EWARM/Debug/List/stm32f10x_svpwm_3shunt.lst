###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.1.53790/W32 for ARM     24/Feb/2014  19:26:49 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\stm32\BLDC PMSM2\src\stm32f10x_svpwm_3shunt.c         #
#    Command line =  "D:\stm32\BLDC PMSM2\src\stm32f10x_svpwm_3shunt.c" -D    #
#                    VECT_TAB_FLASH -lCN "D:\stm32\BLDC                       #
#                    PMSM2\EWARM\Debug\List\" --diag_error Pe068,Pe069 -o     #
#                    "D:\stm32\BLDC PMSM2\EWARM\Debug\Obj\" --debug           #
#                    --endian=little --cpu=Cortex-M3 --fpu=None               #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 6.4\arm\INC\c\DLib_Config_Normal.h" -I         #
#                    "D:\stm32\BLDC PMSM2\EWARM\..\" -I "D:\stm32\BLDC        #
#                    PMSM2\EWARM\..\..\STM32F10XFWLIB\inc\" -I                #
#                    "D:\stm32\BLDC PMSM2\EWARM\..\inc\" -Ohs                 #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  D:\stm32\BLDC PMSM2\EWARM\Debug\List\stm32f10x_svpwm_3sh #
#                    unt.lst                                                  #
#    Object file  =  D:\stm32\BLDC PMSM2\EWARM\Debug\Obj\stm32f10x_svpwm_3shu #
#                    nt.o                                                     #
#                                                                             #
#                                                                             #
###############################################################################

D:\stm32\BLDC PMSM2\src\stm32f10x_svpwm_3shunt.c
      1          /******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
      2          * File Name          : STM32x_svpwm_3shunt.c
      3          * Author             : IMS Systems Lab
      4          * Date First Issued  : 28/11/07
      5          * Description        : 3 shunt resistors current reading module
      6          ********************************************************************************
      7          * History:
      8          * 28/11/07 v1.0
      9          * 29/05/08 v2.0
     10          * 03/07/08 v2.0.1
     11          * 09/07/08 v2.0.2
     12          * 11/07/08 v2.0.3
     13          ********************************************************************************
     14          * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     15          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     16          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     17          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     18          * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     19          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     20          *
     21          * THIS SOURCE CODE IS PROTECTED BY A LICENSE.
     22          * FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED
     23          * IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
     24          *******************************************************************************/
     25          
     26          #include "STM32F10x_MCconf.h"
     27          
     28          #ifdef THREE_SHUNT
     29          
     30          /* Includes-------------------------------------------------------------------*/
     31          #include "stm32f10x_lib.h"
     32          #include "stm32f10x_svpwm_3shunt.h"
     33          #include "MC_Globals.h"
     34          
     35          /* Private typedef -----------------------------------------------------------*/
     36          /* Private define ------------------------------------------------------------*/
     37          
     38          #define NB_CONVERSIONS 16
     39          
     40          #define SQRT_3		1.732051
     41          #define T		    (PWM_PERIOD * 4)
     42          #define T_SQRT3     (u16)(T * SQRT_3)
     43          
     44          #define SECTOR_1	(u32)1
     45          #define SECTOR_2	(u32)2
     46          #define SECTOR_3	(u32)3
     47          #define SECTOR_4	(u32)4
     48          #define SECTOR_5	(u32)5
     49          #define SECTOR_6	(u32)6
     50          
     51          #define PHASE_A_ADC_CHANNEL     ADC_Channel_6
     52          #define PHASE_B_ADC_CHANNEL     ADC_Channel_7
     53          #define PHASE_C_ADC_CHANNEL     ADC_Channel_14
     54          
     55          // Setting for sampling of VBUS and Temp after currents sampling
     56          #define PHASE_A_MSK       (u32)((u32)(PHASE_A_ADC_CHANNEL) << 10)
     57          #define PHASE_B_MSK       (u32)((u32)(PHASE_B_ADC_CHANNEL) << 10)
     58          #define PHASE_C_MSK       (u32)((u32)(PHASE_C_ADC_CHANNEL) << 10)
     59          
     60          // Settings for current sampling only
     61          /*#define PHASE_A_MSK       (u32)((u32)(PHASE_A_ADC_CHANNEL) << 15)
     62          #define PHASE_B_MSK       (u32)((u32)(PHASE_B_ADC_CHANNEL) << 15)
     63          #define PHASE_C_MSK       (u32)((u32)(PHASE_C_ADC_CHANNEL) << 15)*/
     64          
     65          // Setting for sampling of VBUS and Temp after currents sampling
     66          #define TEMP_FDBK_MSK     (u32)((u32)(TEMP_FDBK_CHANNEL) <<15)
     67          #define BUS_VOLT_FDBK_MSK (u32)((u32)(BUS_VOLT_FDBK_CHANNEL) <<15)
     68          
     69          // Settings for current sampling only
     70          //#define TEMP_FDBK_MSK     (u32)(0)
     71          //#define BUS_VOLT_FDBK_MSK (u32)(0)
     72          
     73          // Setting for sampling of VBUS and Temp after currents sampling
     74          #define SEQUENCE_LENGHT    0x00100000
     75          
     76          // Settings for current sampling only
     77          //#define SEQUENCE_LENGHT    0x00000000
     78          
     79          #define ADC_PRE_EMPTION_PRIORITY 1
     80          #define ADC_SUB_PRIORITY 0
     81          
     82          #define BRK_PRE_EMPTION_PRIORITY 0
     83          #define BRK_SUB_PRIORITY 0
     84          
     85          #define TIM1_UP_PRE_EMPTION_PRIORITY 1
     86          #define TIM1_UP_SUB_PRIORITY 0
     87          
     88          #define LOW_SIDE_POLARITY  TIM_OCIdleState_Reset
     89          
     90          #define PWM2_MODE 0
     91          #define PWM1_MODE 1
     92          
     93          /* Private macro -------------------------------------------------------------*/
     94          /* Private variables ---------------------------------------------------------*/
     95          u8  bSector;  
     96          
     97          u16 hPhaseAOffset;
     98          u16 hPhaseBOffset;
     99          u16 hPhaseCOffset;
    100          
    101          u8 PWM4Direction=PWM2_MODE;
    102          
    103          /* Private function prototypes -----------------------------------------------*/
    104          
    105          void SVPWM_InjectedConvConfig(void);
    106          
    107          /*******************************************************************************
    108          * Function Name  : SVPWM_3ShuntInit
    109          * Description    : It initializes PWM and ADC peripherals
    110          * Input          : None
    111          * Output         : None
    112          * Return         : None
    113          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    114          void SVPWM_3ShuntInit(void)
    115          { 
   \                     SVPWM_3ShuntInit:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB092             SUB      SP,SP,#+72
    116            ADC_InitTypeDef ADC_InitStructure;
    117            TIM_TimeBaseInitTypeDef TIM1_TimeBaseStructure;
    118            TIM_OCInitTypeDef TIM1_OCInitStructure;
    119            TIM_BDTRInitTypeDef TIM1_BDTRInitStructure;
    120            NVIC_InitTypeDef NVIC_InitStructure;
    121            GPIO_InitTypeDef GPIO_InitStructure;
    122          
    123            /* ADC1, ADC2, DMA, GPIO, TIM1 clocks enabling -----------------------------*/
    124            
    125            /* ADCCLK = PCLK2/6 */
    126            RCC_ADCCLKConfig(RCC_PCLK2_Div6);
   \   00000006   0xF44F 0x4000      MOV      R0,#+32768
   \   0000000A   0x.... 0x....      BL       RCC_ADCCLKConfig
    127          
    128            /* Enable DMA clock */
    129            RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x.... 0x....      BL       RCC_AHBPeriphClockCmd
    130            
    131            /* Enable GPIOA, GPIOC, GPIOE, AFIO clocks */
    132            RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO | RCC_APB2Periph_GPIOA |
    133                                   RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOB| RCC_APB2Periph_GPIOD, ENABLE);
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x203D             MOVS     R0,#+61
   \   0000001A   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    134            /* Enable ADC1 clock */
    135            RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0xF44F 0x7000      MOV      R0,#+512
   \   00000024   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    136          
    137            /* Enable ADC2 clock */
    138            RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC2, ENABLE); 
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0xF44F 0x6080      MOV      R0,#+1024
   \   0000002E   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    139             
    140            /* Enable TIM1 clock */
    141            RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
   \   00000032   0x2101             MOVS     R1,#+1
   \   00000034   0xF44F 0x6000      MOV      R0,#+2048
   \   00000038   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    142               
    143            /* ADC1, ADC2, PWM pins configurations -------------------------------------*/
    144            GPIO_StructInit(&GPIO_InitStructure);
   \   0000003C   0xA800             ADD      R0,SP,#+0
   \   0000003E   0x.... 0x....      BL       GPIO_StructInit
    145            /****** Configure PC.00,01,2,3,4 (ADC Channels [10..14]) as analog input ****/
    146            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 |GPIO_Pin_6|GPIO_Pin_7;
   \   00000042   0x20CF             MOVS     R0,#+207
   \   00000044   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    147            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xF88D 0x0003      STRB     R0,[SP, #+3]
    148            GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   0000004E   0x.... 0x....      LDR.W    R4,??DataTable6  ;; 0x40010800
   \   00000052   0xA900             ADD      R1,SP,#+0
   \   00000054   0x4620             MOV      R0,R4
   \   00000056   0x.... 0x....      BL       GPIO_Init
    149               
    150            GPIO_StructInit(&GPIO_InitStructure);
   \   0000005A   0xA800             ADD      R0,SP,#+0
   \   0000005C   0x.... 0x....      BL       GPIO_StructInit
    151            /****** Configure PA.03 (ADC Channels [3]) as analog input ******/
    152            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 | GPIO_Pin_4  ;
   \   00000060   0x2018             MOVS     R0,#+24
   \   00000062   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    153            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xF88D 0x0003      STRB     R0,[SP, #+3]
    154            GPIO_Init(GPIOC, &GPIO_InitStructure);
   \   0000006C   0xA900             ADD      R1,SP,#+0
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable6_1  ;; 0x40011000
   \   00000072   0x.... 0x....      BL       GPIO_Init
    155          
    156          	 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 ;
   \   00000076   0xF44F 0x5580      MOV      R5,#+4096
   \   0000007A   0xF8AD 0x5000      STRH     R5,[SP, #+0]
    157            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0xF88D 0x0002      STRB     R0,[SP, #+2]
    158            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   00000084   0x2010             MOVS     R0,#+16
   \   00000086   0xF88D 0x0003      STRB     R0,[SP, #+3]
    159           	GPIO_Init(GPIOB, &GPIO_InitStructure); 
   \   0000008A   0x.... 0x....      LDR.W    R6,??DataTable6_2  ;; 0x40010c00
   \   0000008E   0xA900             ADD      R1,SP,#+0
   \   00000090   0x4630             MOV      R0,R6
   \   00000092   0x.... 0x....      BL       GPIO_Init
    160            /* TIM1 Peripheral Configuration -------------------------------------------*/
    161            /* TIM1 Registers reset */
    162            TIM_DeInit(TIM1);
   \   00000096   0x.... 0x....      LDR.W    R7,??DataTable6_3  ;; 0x40012c00
   \   0000009A   0x4638             MOV      R0,R7
   \   0000009C   0x.... 0x....      BL       TIM_DeInit
    163            TIM_TimeBaseStructInit(&TIM1_TimeBaseStructure);
   \   000000A0   0xA80B             ADD      R0,SP,#+44
   \   000000A2   0x.... 0x....      BL       TIM_TimeBaseStructInit
    164            /* Time Base configuration */
    165            TIM1_TimeBaseStructure.TIM_Prescaler = 0x0;
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0xF8AD 0x002C      STRH     R0,[SP, #+44]
    166            TIM1_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_CenterAligned1;
   \   000000AC   0x2020             MOVS     R0,#+32
   \   000000AE   0xF8AD 0x002E      STRH     R0,[SP, #+46]
    167            TIM1_TimeBaseStructure.TIM_Period = PWM_PERIOD;
   \   000000B2   0xF640 0x10C4      MOVW     R0,#+2500
   \   000000B6   0xF8AD 0x0030      STRH     R0,[SP, #+48]
    168            TIM1_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV2;
   \   000000BA   0xF44F 0x7880      MOV      R8,#+256
   \   000000BE   0xF8AD 0x8032      STRH     R8,[SP, #+50]
    169            
    170            // Initial condition is REP=0 to set the UPDATE only on the underflow
    171            TIM1_TimeBaseStructure.TIM_RepetitionCounter = REP_RATE;
   \   000000C2   0x2001             MOVS     R0,#+1
   \   000000C4   0xF88D 0x0034      STRB     R0,[SP, #+52]
    172            TIM_TimeBaseInit(TIM1, &TIM1_TimeBaseStructure);
   \   000000C8   0xA90B             ADD      R1,SP,#+44
   \   000000CA   0x4638             MOV      R0,R7
   \   000000CC   0x.... 0x....      BL       TIM_TimeBaseInit
    173            
    174            TIM_OCStructInit(&TIM1_OCInitStructure);
   \   000000D0   0xA802             ADD      R0,SP,#+8
   \   000000D2   0x.... 0x....      BL       TIM_OCStructInit
    175            /* Channel 1, 2,3 in PWM mode */
    176            TIM1_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1; 
   \   000000D6   0x2060             MOVS     R0,#+96
   \   000000D8   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    177            TIM1_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; 
   \   000000DC   0x2001             MOVS     R0,#+1
   \   000000DE   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    178            TIM1_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Enable;                  
   \   000000E2   0x2004             MOVS     R0,#+4
   \   000000E4   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    179            TIM1_OCInitStructure.TIM_Pulse = 0x505; //dummy value
   \   000000E8   0xF240 0x5005      MOVW     R0,#+1285
   \   000000EC   0xF8AD 0x000E      STRH     R0,[SP, #+14]
    180            TIM1_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_Low; 
   \   000000F0   0x2002             MOVS     R0,#+2
   \   000000F2   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    181            TIM1_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_Low;         
   \   000000F6   0x2008             MOVS     R0,#+8
   \   000000F8   0xF8AD 0x0012      STRH     R0,[SP, #+18]
    182            TIM1_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Reset;
   \   000000FC   0x2000             MOVS     R0,#+0
   \   000000FE   0x9005             STR      R0,[SP, #+20]
    183            TIM1_OCInitStructure.TIM_OCNIdleState = LOW_SIDE_POLARITY;          
    184            
    185            TIM_OC1Init(TIM1, &TIM1_OCInitStructure); 
   \   00000100   0xA902             ADD      R1,SP,#+8
   \   00000102   0x4638             MOV      R0,R7
   \   00000104   0x.... 0x....      BL       TIM_OC1Init
    186            TIM_OC2Init(TIM1, &TIM1_OCInitStructure);
   \   00000108   0xA902             ADD      R1,SP,#+8
   \   0000010A   0x4638             MOV      R0,R7
   \   0000010C   0x.... 0x....      BL       TIM_OC2Init
    187            TIM_OC3Init(TIM1, &TIM1_OCInitStructure);
   \   00000110   0xA902             ADD      R1,SP,#+8
   \   00000112   0x4638             MOV      R0,R7
   \   00000114   0x.... 0x....      BL       TIM_OC3Init
    188            GPIO_StructInit(&GPIO_InitStructure);
   \   00000118   0xA800             ADD      R0,SP,#+0
   \   0000011A   0x.... 0x....      BL       GPIO_StructInit
    189            /* GPIOE Configuration: Channel 1, 1N, 2, 2N, 3, 3N and 4 Output */
    190            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10  ;
   \   0000011E   0xF44F 0x60E0      MOV      R0,#+1792
   \   00000122   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    191                                          
    192            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
   \   00000126   0x2018             MOVS     R0,#+24
   \   00000128   0xF88D 0x0003      STRB     R0,[SP, #+3]
    193            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000012C   0x2003             MOVS     R0,#+3
   \   0000012E   0xF88D 0x0002      STRB     R0,[SP, #+2]
    194            GPIO_Init(GPIOA, &GPIO_InitStructure); 
   \   00000132   0xA900             ADD      R1,SP,#+0
   \   00000134   0x4620             MOV      R0,R4
   \   00000136   0x.... 0x....      BL       GPIO_Init
    195          
    196            GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
   \   0000013A   0xF44F 0x4060      MOV      R0,#+57344
   \   0000013E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    197            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
   \   00000142   0x2018             MOVS     R0,#+24
   \   00000144   0xF88D 0x0003      STRB     R0,[SP, #+3]
    198            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000148   0x2003             MOVS     R0,#+3
   \   0000014A   0xF88D 0x0002      STRB     R0,[SP, #+2]
    199            GPIO_Init(GPIOB, &GPIO_InitStructure); 
   \   0000014E   0xA900             ADD      R1,SP,#+0
   \   00000150   0x4630             MOV      R0,R6
   \   00000152   0x.... 0x....      BL       GPIO_Init
    200            /*Timer1 alternate function full remapping*/  
    201            //GPIO_PinRemapConfig(GPIO_FullRemap_TIM1,ENABLE);  
    202            
    203          //  GPIO_StructInit(&GPIO_InitStructure);
    204            /* GPIOE Configuration: Channel 1, 1N, 2, 2N, 3, 3N and 4 Output */
    205          //  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | 
    206           //                               GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14;
    207          //  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    208          //  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    209          //  GPIO_Init(GPIOE, &GPIO_InitStructure); 
    210            
    211            /* Lock GPIOE Pin9 and Pin11 Pin 13 (High sides) */
    212          //  GPIO_PinLockConfig(GPIOE, GPIO_Pin_9 | GPIO_Pin_11 | GPIO_Pin_13);
    213          
    214            GPIO_StructInit(&GPIO_InitStructure);
   \   00000156   0xA800             ADD      R0,SP,#+0
   \   00000158   0x.... 0x....      BL       GPIO_StructInit
    215            /* GPIOE Configuration: BKIN pin */   
    216           // GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15;
    217           // GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    218           // GPIO_Init(GPIOE, &GPIO_InitStructure);  
    219            
    220            TIM_OCStructInit(&TIM1_OCInitStructure);
   \   0000015C   0xA802             ADD      R0,SP,#+8
   \   0000015E   0x.... 0x....      BL       TIM_OCStructInit
    221            /* Channel 4 Configuration in OC */
    222            TIM1_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2;  
   \   00000162   0x2070             MOVS     R0,#+112
   \   00000164   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    223            TIM1_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; 
   \   00000168   0x2001             MOVS     R0,#+1
   \   0000016A   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    224            TIM1_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Disable;                  
   \   0000016E   0x2000             MOVS     R0,#+0
   \   00000170   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    225            TIM1_OCInitStructure.TIM_Pulse = PWM_PERIOD - 1; 
   \   00000174   0xF640 0x10C3      MOVW     R0,#+2499
   \   00000178   0xF8AD 0x000E      STRH     R0,[SP, #+14]
    226            
    227            TIM1_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; 
   \   0000017C   0x2000             MOVS     R0,#+0
   \   0000017E   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    228            TIM1_OCInitStructure.TIM_OCNPolarity =TIM_OCNPolarity_Low;         
   \   00000182   0x2008             MOVS     R0,#+8
   \   00000184   0xF8AD 0x0012      STRH     R0,[SP, #+18]
    229            TIM1_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Reset;
   \   00000188   0x2000             MOVS     R0,#+0
   \   0000018A   0x9005             STR      R0,[SP, #+20]
    230            TIM1_OCInitStructure.TIM_OCNIdleState = LOW_SIDE_POLARITY;            
    231            
    232            TIM_OC4Init(TIM1, &TIM1_OCInitStructure);
   \   0000018C   0xA902             ADD      R1,SP,#+8
   \   0000018E   0x4638             MOV      R0,R7
   \   00000190   0x.... 0x....      BL       TIM_OC4Init
    233            
    234            /* Enables the TIM1 Preload on CC1 Register */
    235            TIM_OC1PreloadConfig(TIM1, TIM_OCPreload_Enable);
   \   00000194   0x2108             MOVS     R1,#+8
   \   00000196   0x4638             MOV      R0,R7
   \   00000198   0x.... 0x....      BL       TIM_OC1PreloadConfig
    236            /* Enables the TIM1 Preload on CC2 Register */
    237            TIM_OC2PreloadConfig(TIM1, TIM_OCPreload_Enable);
   \   0000019C   0x2108             MOVS     R1,#+8
   \   0000019E   0x4638             MOV      R0,R7
   \   000001A0   0x.... 0x....      BL       TIM_OC2PreloadConfig
    238            /* Enables the TIM1 Preload on CC3 Register */
    239            TIM_OC3PreloadConfig(TIM1, TIM_OCPreload_Enable);
   \   000001A4   0x2108             MOVS     R1,#+8
   \   000001A6   0x4638             MOV      R0,R7
   \   000001A8   0x.... 0x....      BL       TIM_OC3PreloadConfig
    240            /* Enables the TIM1 Preload on CC4 Register */
    241            TIM_OC4PreloadConfig(TIM1, TIM_OCPreload_Enable);
   \   000001AC   0x2108             MOVS     R1,#+8
   \   000001AE   0x4638             MOV      R0,R7
   \   000001B0   0x.... 0x....      BL       TIM_OC4PreloadConfig
    242          
    243            /* Automatic Output enable, Break, dead time and lock configuration*/
    244            TIM1_BDTRInitStructure.TIM_OSSRState = TIM_OSSRState_Enable;
   \   000001B4   0xF44F 0x6400      MOV      R4,#+2048
   \   000001B8   0xF8AD 0x4038      STRH     R4,[SP, #+56]
    245            TIM1_BDTRInitStructure.TIM_OSSIState = TIM_OSSIState_Enable;
   \   000001BC   0xF44F 0x6080      MOV      R0,#+1024
   \   000001C0   0xF8AD 0x003A      STRH     R0,[SP, #+58]
    246            TIM1_BDTRInitStructure.TIM_LOCKLevel = TIM_LOCKLevel_1; 
   \   000001C4   0xF8AD 0x803C      STRH     R8,[SP, #+60]
    247            TIM1_BDTRInitStructure.TIM_DeadTime = DEADTIME;
   \   000001C8   0x201C             MOVS     R0,#+28
   \   000001CA   0xF8AD 0x003E      STRH     R0,[SP, #+62]
    248            TIM1_BDTRInitStructure.TIM_Break = TIM_Break_Enable;
   \   000001CE   0xF8AD 0x5040      STRH     R5,[SP, #+64]
    249            TIM1_BDTRInitStructure.TIM_BreakPolarity = TIM_BreakPolarity_Low;
   \   000001D2   0x2000             MOVS     R0,#+0
   \   000001D4   0xF8AD 0x0042      STRH     R0,[SP, #+66]
    250            TIM1_BDTRInitStructure.TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
   \   000001D8   0xF8AD 0x0044      STRH     R0,[SP, #+68]
    251          
    252            TIM_BDTRConfig(TIM1, &TIM1_BDTRInitStructure);
   \   000001DC   0xA90E             ADD      R1,SP,#+56
   \   000001DE   0x4638             MOV      R0,R7
   \   000001E0   0x.... 0x....      BL       TIM_BDTRConfig
    253          
    254            TIM_SelectOutputTrigger(TIM1, TIM_TRGOSource_Update);
   \   000001E4   0x2120             MOVS     R1,#+32
   \   000001E6   0x4638             MOV      R0,R7
   \   000001E8   0x.... 0x....      BL       TIM_SelectOutputTrigger
    255            
    256            TIM_ClearITPendingBit(TIM1, TIM_IT_Break);
   \   000001EC   0x2180             MOVS     R1,#+128
   \   000001EE   0x4638             MOV      R0,R7
   \   000001F0   0x.... 0x....      BL       TIM_ClearITPendingBit
    257            TIM_ITConfig(TIM1, TIM_IT_Break,ENABLE);
   \   000001F4   0x2201             MOVS     R2,#+1
   \   000001F6   0x2180             MOVS     R1,#+128
   \   000001F8   0x4638             MOV      R0,R7
   \   000001FA   0x.... 0x....      BL       TIM_ITConfig
    258            
    259            /* TIM1 counter enable */
    260            TIM_Cmd(TIM1, ENABLE);
   \   000001FE   0x2101             MOVS     R1,#+1
   \   00000200   0x4638             MOV      R0,R7
   \   00000202   0x.... 0x....      BL       TIM_Cmd
    261          
    262            
    263            // Resynch to have the Update evend during Undeflow
    264            TIM_GenerateEvent(TIM1, TIM_EventSource_Update);
   \   00000206   0x2101             MOVS     R1,#+1
   \   00000208   0x4638             MOV      R0,R7
   \   0000020A   0x.... 0x....      BL       TIM_GenerateEvent
    265            
    266            // Clear Update Flag
    267            TIM_ClearFlag(TIM1, TIM_FLAG_Update);
   \   0000020E   0x2101             MOVS     R1,#+1
   \   00000210   0x4638             MOV      R0,R7
   \   00000212   0x.... 0x....      BL       TIM_ClearFlag
    268            
    269            TIM_ITConfig(TIM1, TIM_IT_Update, DISABLE);
   \   00000216   0x2200             MOVS     R2,#+0
   \   00000218   0x2101             MOVS     R1,#+1
   \   0000021A   0x4638             MOV      R0,R7
   \   0000021C   0x.... 0x....      BL       TIM_ITConfig
    270            
    271            TIM_ITConfig(TIM1, TIM_IT_CC4,DISABLE);
   \   00000220   0x2200             MOVS     R2,#+0
   \   00000222   0x2110             MOVS     R1,#+16
   \   00000224   0x4638             MOV      R0,R7
   \   00000226   0x.... 0x....      BL       TIM_ITConfig
    272               
    273            /* ADC1 registers reset ----------------------------------------------------*/
    274            ADC_DeInit(ADC1);
   \   0000022A   0x.... 0x....      LDR.W    R5,??DataTable6_4  ;; 0x40012400
   \   0000022E   0x4628             MOV      R0,R5
   \   00000230   0x.... 0x....      BL       ADC_DeInit
    275            /* ADC2 registers reset ----------------------------------------------------*/
    276            ADC_DeInit(ADC2);
   \   00000234   0x.... 0x....      LDR.W    R6,??DataTable6_5  ;; 0x40012800
   \   00000238   0x4630             MOV      R0,R6
   \   0000023A   0x.... 0x....      BL       ADC_DeInit
    277            
    278            /* Enable ADC1 */
    279            ADC_Cmd(ADC1, ENABLE);
   \   0000023E   0x2101             MOVS     R1,#+1
   \   00000240   0x4628             MOV      R0,R5
   \   00000242   0x.... 0x....      BL       ADC_Cmd
    280            /* Enable ADC2 */
    281            ADC_Cmd(ADC2, ENABLE);
   \   00000246   0x2101             MOVS     R1,#+1
   \   00000248   0x4630             MOV      R0,R6
   \   0000024A   0x.... 0x....      BL       ADC_Cmd
    282            
    283            /* ADC1 configuration ------------------------------------------------------*/
    284            ADC_StructInit(&ADC_InitStructure);
   \   0000024E   0xA806             ADD      R0,SP,#+24
   \   00000250   0x.... 0x....      BL       ADC_StructInit
    285            ADC_InitStructure.ADC_Mode = ADC_Mode_InjecSimult;
   \   00000254   0xF44F 0x20A0      MOV      R0,#+327680
   \   00000258   0x9006             STR      R0,[SP, #+24]
    286            ADC_InitStructure.ADC_ScanConvMode = ENABLE;
   \   0000025A   0x2001             MOVS     R0,#+1
   \   0000025C   0xF88D 0x001C      STRB     R0,[SP, #+28]
    287            ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
   \   00000260   0x2000             MOVS     R0,#+0
   \   00000262   0xF88D 0x001D      STRB     R0,[SP, #+29]
    288            ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
   \   00000266   0xF44F 0x2760      MOV      R7,#+917504
   \   0000026A   0x9708             STR      R7,[SP, #+32]
    289            ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Left;
   \   0000026C   0x9409             STR      R4,[SP, #+36]
    290            ADC_InitStructure.ADC_NbrOfChannel = 1;
   \   0000026E   0x2001             MOVS     R0,#+1
   \   00000270   0xF88D 0x0028      STRB     R0,[SP, #+40]
    291            ADC_Init(ADC1, &ADC_InitStructure);
   \   00000274   0xA906             ADD      R1,SP,#+24
   \   00000276   0x4628             MOV      R0,R5
   \   00000278   0x.... 0x....      BL       ADC_Init
    292             
    293            /* ADC2 Configuration ------------------------------------------------------*/
    294            ADC_StructInit(&ADC_InitStructure);  
   \   0000027C   0xA806             ADD      R0,SP,#+24
   \   0000027E   0x.... 0x....      BL       ADC_StructInit
    295            ADC_InitStructure.ADC_ScanConvMode = ENABLE;
   \   00000282   0x2001             MOVS     R0,#+1
   \   00000284   0xF88D 0x001C      STRB     R0,[SP, #+28]
    296            ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
   \   00000288   0x2000             MOVS     R0,#+0
   \   0000028A   0xF88D 0x001D      STRB     R0,[SP, #+29]
    297            ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
   \   0000028E   0x9708             STR      R7,[SP, #+32]
    298            ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Left;
   \   00000290   0x9409             STR      R4,[SP, #+36]
    299            ADC_InitStructure.ADC_NbrOfChannel = 1;
   \   00000292   0x2001             MOVS     R0,#+1
   \   00000294   0xF88D 0x0028      STRB     R0,[SP, #+40]
    300            ADC_Init(ADC2, &ADC_InitStructure);
   \   00000298   0xA906             ADD      R1,SP,#+24
   \   0000029A   0x4630             MOV      R0,R6
   \   0000029C   0x.... 0x....      BL       ADC_Init
    301            
    302            // Start calibration of ADC1
    303            ADC_StartCalibration(ADC1);
   \   000002A0   0x4628             MOV      R0,R5
   \   000002A2   0x.... 0x....      BL       ADC_StartCalibration
    304            // Start calibration of ADC2
    305            ADC_StartCalibration(ADC2);
   \   000002A6   0x4630             MOV      R0,R6
   \   000002A8   0x.... 0x....      BL       ADC_StartCalibration
    306            
    307            // Wait for the end of ADCs calibration 
    308            while (ADC_GetCalibrationStatus(ADC1) & ADC_GetCalibrationStatus(ADC2))
   \                     ??SVPWM_3ShuntInit_0:
   \   000002AC   0x4628             MOV      R0,R5
   \   000002AE   0x.... 0x....      BL       ADC_GetCalibrationStatus
   \   000002B2   0x4604             MOV      R4,R0
   \   000002B4   0x4630             MOV      R0,R6
   \   000002B6   0x.... 0x....      BL       ADC_GetCalibrationStatus
   \   000002BA   0x4204             TST      R4,R0
   \   000002BC   0xD1F6             BNE.N    ??SVPWM_3ShuntInit_0
    309            {
    310            }
    311            
    312            SVPWM_3ShuntCurrentReadingCalibration();
   \   000002BE   0x.... 0x....      BL       SVPWM_3ShuntCurrentReadingCalibration
    313              
    314            /* ADC2 Injected conversions configuration */ 
    315            ADC_InjectedSequencerLengthConfig(ADC2,2);
   \   000002C2   0x2102             MOVS     R1,#+2
   \   000002C4   0x4630             MOV      R0,R6
   \   000002C6   0x.... 0x....      BL       ADC_InjectedSequencerLengthConfig
    316            
    317            ADC_InjectedChannelConfig(ADC2, PHASE_A_ADC_CHANNEL, 1, 
    318                                                                SAMPLING_TIME_CK);//相位A ADC
   \   000002CA   0x2300             MOVS     R3,#+0
   \   000002CC   0x2201             MOVS     R2,#+1
   \   000002CE   0x2106             MOVS     R1,#+6
   \   000002D0   0x4630             MOV      R0,R6
   \   000002D2   0x.... 0x....      BL       ADC_InjectedChannelConfig
    319            ADC_InjectedChannelConfig(ADC2, TEMP_FDBK_CHANNEL, 2,
    320                                                                SAMPLING_TIME_CK);//温度反馈
   \   000002D6   0x2300             MOVS     R3,#+0
   \   000002D8   0x2202             MOVS     R2,#+2
   \   000002DA   0x210D             MOVS     R1,#+13
   \   000002DC   0x4630             MOV      R0,R6
   \   000002DE   0x.... 0x....      BL       ADC_InjectedChannelConfig
    321            
    322            /* Configure one bit for preemption priority */
    323            NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
   \   000002E2   0xF44F 0x60A0      MOV      R0,#+1280
   \   000002E6   0x.... 0x....      BL       NVIC_PriorityGroupConfig
    324            
    325            NVIC_StructInit(&NVIC_InitStructure);
   \   000002EA   0xA801             ADD      R0,SP,#+4
   \   000002EC   0x.... 0x....      BL       NVIC_StructInit
    326            /* Enable the ADC Interrupt */
    327            NVIC_InitStructure.NVIC_IRQChannel = ADC1_2_IRQChannel;//ADC1和ADC2 注入中断
   \   000002F0   0x2012             MOVS     R0,#+18
   \   000002F2   0xF88D 0x0004      STRB     R0,[SP, #+4]
    328            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = ADC_PRE_EMPTION_PRIORITY;
   \   000002F6   0x2001             MOVS     R0,#+1
   \   000002F8   0xF88D 0x0005      STRB     R0,[SP, #+5]
    329            NVIC_InitStructure.NVIC_IRQChannelSubPriority = ADC_SUB_PRIORITY;
   \   000002FC   0x2000             MOVS     R0,#+0
   \   000002FE   0xF88D 0x0006      STRB     R0,[SP, #+6]
    330            NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000302   0x2001             MOVS     R0,#+1
   \   00000304   0xF88D 0x0007      STRB     R0,[SP, #+7]
    331            NVIC_Init(&NVIC_InitStructure);
   \   00000308   0xA801             ADD      R0,SP,#+4
   \   0000030A   0x.... 0x....      BL       NVIC_Init
    332            
    333            /* Enable the Update Interrupt */
    334            NVIC_InitStructure.NVIC_IRQChannel = TIM1_UP_IRQChannel;
   \   0000030E   0x2019             MOVS     R0,#+25
   \   00000310   0xF88D 0x0004      STRB     R0,[SP, #+4]
    335            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = TIM1_UP_PRE_EMPTION_PRIORITY;
   \   00000314   0x2001             MOVS     R0,#+1
   \   00000316   0xF88D 0x0005      STRB     R0,[SP, #+5]
    336            NVIC_InitStructure.NVIC_IRQChannelSubPriority = TIM1_UP_SUB_PRIORITY;
   \   0000031A   0x2000             MOVS     R0,#+0
   \   0000031C   0xF88D 0x0006      STRB     R0,[SP, #+6]
    337            NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000320   0x2001             MOVS     R0,#+1
   \   00000322   0xF88D 0x0007      STRB     R0,[SP, #+7]
    338            NVIC_Init(&NVIC_InitStructure);
   \   00000326   0xA801             ADD      R0,SP,#+4
   \   00000328   0x.... 0x....      BL       NVIC_Init
    339              
    340            /* Enable the TIM1 BRK Interrupt */
    341           // NVIC_InitStructure.NVIC_IRQChannel = TIM1_BRK_IRQChannel;
    342           // NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = BRK_PRE_EMPTION_PRIORITY;
    343           // NVIC_InitStructure.NVIC_IRQChannelSubPriority = BRK_SUB_PRIORITY;
    344           // NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    345          //  NVIC_Init(&NVIC_InitStructure); 
    346          } 
   \   0000032C   0xB012             ADD      SP,SP,#+72
   \   0000032E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    347          
    348          
    349          /*******************************************************************************
    350          * Function Name  : SVPWM_3ShuntCurrentReadingCalibration
    351          * Description    : Store zero current converted values for current reading 
    352                             network offset compensation in case of 3 shunt resistors 
    353          * Input          : None
    354          * Output         : None
    355          * Return         : None
    356          *******************************************************************************/
    357          

   \                                 In section .text, align 2, keep-with-next
    358          void SVPWM_3ShuntCurrentReadingCalibration(void)
    359          {
   \                     SVPWM_3ShuntCurrentReadingCalibration:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    360            static u16 bIndex;
    361            
    362            /* ADC1 Injected group of conversions end interrupt disabling */
    363            ADC_ITConfig(ADC1, ADC_IT_JEOC, DISABLE);
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable6_4  ;; 0x40012400
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0xF44F 0x6190      MOV      R1,#+1152
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       ADC_ITConfig
    364            
    365            hPhaseAOffset=0;
   \   00000014   0x.... 0x....      LDR.W    R5,??DataTable6_6
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x8068             STRH     R0,[R5, #+2]
    366            hPhaseBOffset=0;
   \   0000001C   0x80A8             STRH     R0,[R5, #+4]
    367            hPhaseCOffset=0;
   \   0000001E   0x80E8             STRH     R0,[R5, #+6]
    368            
    369            /* ADC1 Injected conversions trigger is given by software and enabled */ 
    370            ADC_ExternalTrigInjectedConvConfig(ADC1, ADC_ExternalTrigInjecConv_None);  // 通过软件出发转换
   \   00000020   0xF44F 0x41E0      MOV      R1,#+28672
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       ADC_ExternalTrigInjectedConvConfig
    371            ADC_ExternalTrigInjectedConvCmd(ADC1,ENABLE); 
   \   0000002A   0x2101             MOVS     R1,#+1
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       ADC_ExternalTrigInjectedConvCmd
    372            
    373            /* ADC1 Injected conversions configuration */ 
    374            ADC_InjectedSequencerLengthConfig(ADC1,3);
   \   00000032   0x2103             MOVS     R1,#+3
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       ADC_InjectedSequencerLengthConfig
    375            ADC_InjectedChannelConfig(ADC1, PHASE_A_ADC_CHANNEL,1,SAMPLING_TIME_CK);
   \   0000003A   0x2300             MOVS     R3,#+0
   \   0000003C   0x2201             MOVS     R2,#+1
   \   0000003E   0x2106             MOVS     R1,#+6
   \   00000040   0x4620             MOV      R0,R4
   \   00000042   0x.... 0x....      BL       ADC_InjectedChannelConfig
    376            ADC_InjectedChannelConfig(ADC1, PHASE_B_ADC_CHANNEL,2,SAMPLING_TIME_CK);
   \   00000046   0x2300             MOVS     R3,#+0
   \   00000048   0x2202             MOVS     R2,#+2
   \   0000004A   0x2107             MOVS     R1,#+7
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x.... 0x....      BL       ADC_InjectedChannelConfig
    377            ADC_InjectedChannelConfig(ADC1, PHASE_C_ADC_CHANNEL,3,SAMPLING_TIME_CK);
   \   00000052   0x2300             MOVS     R3,#+0
   \   00000054   0x2203             MOVS     R2,#+3
   \   00000056   0x210E             MOVS     R1,#+14
   \   00000058   0x4620             MOV      R0,R4
   \   0000005A   0x.... 0x....      BL       ADC_InjectedChannelConfig
    378            
    379            /* Clear the ADC1 JEOC pending flag */
    380            ADC_ClearFlag(ADC1, ADC_FLAG_JEOC);  
   \   0000005E   0x2104             MOVS     R1,#+4
   \   00000060   0x4620             MOV      R0,R4
   \   00000062   0x.... 0x....      BL       ADC_ClearFlag
    381            ADC_SoftwareStartInjectedConvCmd(ADC1,ENABLE);
   \   00000066   0x2101             MOVS     R1,#+1
   \   00000068   0x4620             MOV      R0,R4
   \   0000006A   0x.... 0x....      BL       ADC_SoftwareStartInjectedConvCmd
    382             
    383            /* ADC Channel used for current reading are read 
    384               in order to get zero currents ADC values*/ 
    385            for(bIndex=0; bIndex <NB_CONVERSIONS; bIndex++)//得到地电压
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x8128             STRH     R0,[R5, #+8]
    386            {
    387              while(!ADC_GetFlagStatus(ADC1,ADC_FLAG_JEOC)) { }
   \                     ??SVPWM_3ShuntCurrentReadingCalibration_0:
   \   00000072   0x2104             MOVS     R1,#+4
   \   00000074   0x4620             MOV      R0,R4
   \   00000076   0x.... 0x....      BL       ADC_GetFlagStatus
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD0F9             BEQ.N    ??SVPWM_3ShuntCurrentReadingCalibration_0
    388              
    389              hPhaseAOffset += (ADC_GetInjectedConversionValue(ADC1,ADC_InjectedChannel_1)>>3);
   \   0000007E   0x2114             MOVS     R1,#+20
   \   00000080   0x4620             MOV      R0,R4
   \   00000082   0x.... 0x....      BL       ADC_GetInjectedConversionValue
   \   00000086   0x8869             LDRH     R1,[R5, #+2]
   \   00000088   0xEB01 0x00D0      ADD      R0,R1,R0, LSR #+3
   \   0000008C   0x8068             STRH     R0,[R5, #+2]
    390              hPhaseBOffset += (ADC_GetInjectedConversionValue(ADC1,ADC_InjectedChannel_2)>>3);
   \   0000008E   0x2118             MOVS     R1,#+24
   \   00000090   0x4620             MOV      R0,R4
   \   00000092   0x.... 0x....      BL       ADC_GetInjectedConversionValue
   \   00000096   0x88A9             LDRH     R1,[R5, #+4]
   \   00000098   0xEB01 0x00D0      ADD      R0,R1,R0, LSR #+3
   \   0000009C   0x80A8             STRH     R0,[R5, #+4]
    391              hPhaseCOffset += (ADC_GetInjectedConversionValue(ADC1,ADC_InjectedChannel_3)>>3);    
   \   0000009E   0x211C             MOVS     R1,#+28
   \   000000A0   0x4620             MOV      R0,R4
   \   000000A2   0x.... 0x....      BL       ADC_GetInjectedConversionValue
   \   000000A6   0x88E9             LDRH     R1,[R5, #+6]
   \   000000A8   0xEB01 0x00D0      ADD      R0,R1,R0, LSR #+3
   \   000000AC   0x80E8             STRH     R0,[R5, #+6]
    392                  
    393              /* Clear the ADC1 JEOC pending flag */
    394              ADC_ClearFlag(ADC1, ADC_FLAG_JEOC);    
   \   000000AE   0x2104             MOVS     R1,#+4
   \   000000B0   0x4620             MOV      R0,R4
   \   000000B2   0x.... 0x....      BL       ADC_ClearFlag
    395              ADC_SoftwareStartInjectedConvCmd(ADC1,ENABLE);
   \   000000B6   0x2101             MOVS     R1,#+1
   \   000000B8   0x4620             MOV      R0,R4
   \   000000BA   0x.... 0x....      BL       ADC_SoftwareStartInjectedConvCmd
    396            }
   \   000000BE   0x8928             LDRH     R0,[R5, #+8]
   \   000000C0   0x1C40             ADDS     R0,R0,#+1
   \   000000C2   0x8128             STRH     R0,[R5, #+8]
   \   000000C4   0xB280             UXTH     R0,R0
   \   000000C6   0x2810             CMP      R0,#+16
   \   000000C8   0xD3D3             BCC.N    ??SVPWM_3ShuntCurrentReadingCalibration_0
    397            
    398            SVPWM_InjectedConvConfig();  
   \   000000CA   0xB001             ADD      SP,SP,#+4
   \   000000CC   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   000000D0                      REQUIRE SVPWM_InjectedConvConfig
   \   000000D0                      ;; // Fall through to label SVPWM_InjectedConvConfig
    399          }

   \                                 In section .bss, align 2
   \                     bSector:
   \   00000000                      DS8 1
   \                     PWM4Direction:
   \   00000001                      DS8 1
   \                     hPhaseAOffset:
   \   00000002                      DS8 2
   \                     hPhaseBOffset:
   \   00000004                      DS8 2
   \                     hPhaseCOffset:
   \   00000006                      DS8 2
   \   00000008                      DS8 2
    400          
    401          
    402          
    403          /*******************************************************************************
    404          * Function Name  : SVPWM_InjectedConvConfig
    405          * Description    : This function configure ADC1 for 3 shunt current 
    406          *                  reading and temperature and voltage feedbcak after a 
    407          *                  calibration of the three utilized ADC Channels
    408          * Input          : None
    409          * Output         : None
    410          * Return         : None
    411          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    412          void SVPWM_InjectedConvConfig(void)
    413          {
   \                     SVPWM_InjectedConvConfig:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    414            /* ADC1 Injected conversions configuration */ 
    415            ADC_InjectedSequencerLengthConfig(ADC1,2);
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable6_4  ;; 0x40012400
   \   00000008   0x2102             MOVS     R1,#+2
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       ADC_InjectedSequencerLengthConfig
    416            ADC_InjectedSequencerLengthConfig(ADC2,2);
   \   00000010   0x.... 0x....      LDR.W    R5,??DataTable6_5  ;; 0x40012800
   \   00000014   0x2102             MOVS     R1,#+2
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0x.... 0x....      BL       ADC_InjectedSequencerLengthConfig
    417            
    418            ADC_InjectedChannelConfig(ADC1, PHASE_B_ADC_CHANNEL, 1, 
    419                                                                SAMPLING_TIME_CK);
   \   0000001C   0x2300             MOVS     R3,#+0
   \   0000001E   0x2201             MOVS     R2,#+1
   \   00000020   0x2107             MOVS     R1,#+7
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       ADC_InjectedChannelConfig
    420            ADC_InjectedChannelConfig(ADC1, BUS_VOLT_FDBK_CHANNEL, 
    421                                                             2, SAMPLING_TIME_CK);
   \   00000028   0x2300             MOVS     R3,#+0
   \   0000002A   0x2202             MOVS     R2,#+2
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       ADC_InjectedChannelConfig
    422              
    423            /* ADC1 Injected conversions trigger is TIM1 TRGO */ 
    424            ADC_ExternalTrigInjectedConvConfig(ADC1, ADC_ExternalTrigInjecConv_T1_TRGO); //trgo 触发 Trgo 是什么
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       ADC_ExternalTrigInjectedConvConfig
    425            
    426            ADC_ExternalTrigInjectedConvCmd(ADC2,ENABLE);
   \   0000003C   0x2101             MOVS     R1,#+1
   \   0000003E   0x4628             MOV      R0,R5
   \   00000040   0x.... 0x....      BL       ADC_ExternalTrigInjectedConvCmd
    427            
    428            /* Bus voltage protection initialization*/                            
    429            //ADC_AnalogWatchdogCmd(ADC1,ADC_AnalogWatchdog_SingleInjecEnable);//电压过高，看门狗复位
    430            
    431            //ADC_AnalogWatchdogSingleChannelConfig(ADC1,BUS_VOLT_FDBK_CHANNEL);
    432            //ADC_AnalogWatchdogThresholdsConfig(ADC1, OVERVOLTAGE_THRESHOLD>>3,0x00);//设置高值
    433            
    434            
    435            /* ADC1 Injected group of conversions end and Analog Watchdog interrupts
    436                                                                               enabling */
    437            ADC_ITConfig(ADC1, ADC_IT_JEOC | ADC_IT_AWD, ENABLE);
   \   00000044   0x2201             MOVS     R2,#+1
   \   00000046   0xF44F 0x61B8      MOV      R1,#+1472
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0xB001             ADD      SP,SP,#+4
   \   0000004E   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   00000052   0x.... 0x....      B.W      ADC_ITConfig
    438          }
    439          
    440          /*******************************************************************************
    441          * Function Name  : SVPWM_3ShuntGetPhaseCurrentValues
    442          * Description    : This function computes current values of Phase A and Phase B 
    443          *                 in q1.15 format starting from values acquired from the A/D 
    444          *                 Converter peripheral.
    445          * Input          : None
    446          * Output         : Stat_Curr_a_b
    447          * Return         : None
    448          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    449          Curr_Components SVPWM_3ShuntGetPhaseCurrentValues(void)
    450          {
   \                     SVPWM_3ShuntGetPhaseCurrentValues:
   \   00000000   0xB081             SUB      SP,SP,#+4
    451            Curr_Components Local_Stator_Currents;
    452            s32 wAux;
    453          
    454            switch (bSector)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable6_6
   \   00000006   0x7801             LDRB     R1,[R0, #+0]
   \   00000008   0x1E49             SUBS     R1,R1,#+1
   \   0000000A   0x2905             CMP      R1,#+5
   \   0000000C   0xD83F             BHI.N    ??SVPWM_3ShuntGetPhaseCurrentValues_1
   \   0000000E   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??SVPWM_3ShuntGetPhaseCurrentValues_0:
   \   00000012   0x13 0x2A          DC8      0x13,0x2A,0x2A,0x3
   \              0x2A 0x03    
   \   00000016   0x03 0x13          DC8      0x3,0x13
    455             {
    456             case 4:  //取得在那个扇区的时候在读取AD
    457             case 5: //Current on Phase C not accessible     
    458                     // Ia = (hPhaseAOffset)-(ADC Channel 11 value)    
    459                      wAux = (s32)(hPhaseAOffset)- ((ADC1->JDR1)<<1);          
   \                     ??SVPWM_3ShuntGetPhaseCurrentValues_2:
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable6_7  ;; 0x4001243c
   \   0000001C   0x8842             LDRH     R2,[R0, #+2]
   \   0000001E   0x680B             LDR      R3,[R1, #+0]
   \   00000020   0xEBA2 0x0243      SUB      R2,R2,R3, LSL #+1
    460                     //Saturation of Ia 
    461                      if (wAux < S16_MIN)
   \   00000024   0xF302 0x020F      SSAT     R2,#+16,R2
   \   00000028   0xF8AD 0x2000      STRH     R2,[SP, #+0]
    462                      {
    463                        Local_Stator_Currents.qI_Component1= S16_MIN;
    464                      }  
    465                      else  if (wAux > S16_MAX)
    466                            { 
    467                              Local_Stator_Currents.qI_Component1= S16_MAX;
    468                            }
    469                            else
    470                            {
    471                              Local_Stator_Currents.qI_Component1= wAux;
    472                            }
    473                               
    474                     // Ib = (hPhaseBOffset)-(ADC Channel 12 value)
    475                      wAux = (s32)(hPhaseBOffset)-((ADC2->JDR1)<<1);
   \   0000002C   0x8880             LDRH     R0,[R0, #+4]
   \   0000002E   0xF8D1 0x1400      LDR      R1,[R1, #+1024]
   \   00000032   0xEBA0 0x0041      SUB      R0,R0,R1, LSL #+1
    476                     // Saturation of Ib
    477                      if (wAux < S16_MIN)
   \   00000036   0xE026             B.N      ??SVPWM_3ShuntGetPhaseCurrentValues_3
    478                      {
    479                        Local_Stator_Currents.qI_Component2= S16_MIN;
    480                      }  
    481                      else  if (wAux > S16_MAX)
    482                            { 
    483                              Local_Stator_Currents.qI_Component2= S16_MAX;
    484                            }
    485                            else
    486                            {
    487                              Local_Stator_Currents.qI_Component2= wAux;
    488                            }
    489                     break;
    490                     
    491             case 6:
    492             case 1:  //Current on Phase A not accessible     
    493                      // Ib = (hPhaseBOffset)-(ADC Channel 12 value)
    494                      wAux = (s32)(hPhaseBOffset)-((ADC1->JDR1)<<1);
   \                     ??SVPWM_3ShuntGetPhaseCurrentValues_4:
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable6_7  ;; 0x4001243c
   \   0000003C   0x8882             LDRH     R2,[R0, #+4]
   \   0000003E   0x680B             LDR      R3,[R1, #+0]
   \   00000040   0xEBA2 0x0243      SUB      R2,R2,R3, LSL #+1
    495                      //Saturation of Ib 
    496                      if (wAux < S16_MIN)
   \   00000044   0xF302 0x020F      SSAT     R2,#+16,R2
   \   00000048   0xF8AD 0x2002      STRH     R2,[SP, #+2]
    497                      {
    498                        Local_Stator_Currents.qI_Component2= S16_MIN;
    499                      }  
    500                      else  if (wAux > S16_MAX)
    501                            { 
    502                              Local_Stator_Currents.qI_Component2= S16_MAX;
    503                            }
    504                            else
    505                            {
    506                              Local_Stator_Currents.qI_Component2= wAux;
    507                            }
    508                      // Ia = -Ic -Ib 
    509                      wAux = ((ADC2->JDR1)<<1)-hPhaseCOffset-
    510                                                      Local_Stator_Currents.qI_Component2;
   \   0000004C   0xF8D1 0x1400      LDR      R1,[R1, #+1024]
   \   00000050   0x88C0             LDRH     R0,[R0, #+6]
   \   00000052   0xEBC0 0x0041      RSB      R0,R0,R1, LSL #+1
   \   00000056   0x1A80             SUBS     R0,R0,R2
    511                      //Saturation of Ia
    512                      if (wAux> S16_MAX)
   \   00000058   0xF300 0x000F      SSAT     R0,#+16,R0
   \   0000005C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   00000060   0x9800             LDR      R0,[SP, #+0]
   \   00000062   0xB001             ADD      SP,SP,#+4
   \   00000064   0x4770             BX       LR
    513                      {
    514                         Local_Stator_Currents.qI_Component1 = S16_MAX;
    515                      }
    516                      else  if (wAux <S16_MIN)
    517                            {
    518                             Local_Stator_Currents.qI_Component1 = S16_MIN;
    519                            }
    520                            else
    521                            {  
    522                              Local_Stator_Currents.qI_Component1 = wAux;
    523                            }
    524                     break;
    525                     
    526             case 2:
    527             case 3:  // Current on Phase B not accessible
    528                      // Ia = (hPhaseAOffset)-(ADC Channel 11 value)     
    529                      wAux = (s32)(hPhaseAOffset)-((ADC1->JDR1)<<1);
   \                     ??SVPWM_3ShuntGetPhaseCurrentValues_5:
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable6_7  ;; 0x4001243c
   \   0000006A   0x8842             LDRH     R2,[R0, #+2]
   \   0000006C   0x680B             LDR      R3,[R1, #+0]
   \   0000006E   0xEBA2 0x0243      SUB      R2,R2,R3, LSL #+1
    530                      //Saturation of Ia 
    531                      if (wAux < S16_MIN)
   \   00000072   0xF302 0x020F      SSAT     R2,#+16,R2
   \   00000076   0xF8AD 0x2000      STRH     R2,[SP, #+0]
    532                      {
    533                        Local_Stator_Currents.qI_Component1= S16_MIN;
    534                      }  
    535                      else  if (wAux > S16_MAX)
    536                            { 
    537                              Local_Stator_Currents.qI_Component1= S16_MAX;
    538                            }
    539                            else
    540                            {
    541                              Local_Stator_Currents.qI_Component1= wAux;
    542                            }
    543               
    544                      // Ib = -Ic-Ia;
    545                      wAux = ((ADC2->JDR1)<<1) - hPhaseCOffset - 
    546                                                      Local_Stator_Currents.qI_Component1;
   \   0000007A   0xF8D1 0x1400      LDR      R1,[R1, #+1024]
   \   0000007E   0x88C0             LDRH     R0,[R0, #+6]
   \   00000080   0xEBC0 0x0041      RSB      R0,R0,R1, LSL #+1
   \   00000084   0x1A80             SUBS     R0,R0,R2
    547                      // Saturation of Ib
    548                      if (wAux> S16_MAX)
   \                     ??SVPWM_3ShuntGetPhaseCurrentValues_3:
   \   00000086   0xF300 0x000F      SSAT     R0,#+16,R0
   \   0000008A   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    549                      {
    550                        Local_Stator_Currents.qI_Component2=S16_MAX;
    551                      }
    552                      else  if (wAux <S16_MIN)
    553                            {  
    554                              Local_Stator_Currents.qI_Component2 = S16_MIN;
    555                            }
    556                            else  
    557                            {
    558                              Local_Stator_Currents.qI_Component2 = wAux;
    559                            }                     
    560                     break;
    561          
    562             default:
    563                     break;
    564             } 
    565            
    566            return(Local_Stator_Currents); 
   \                     ??SVPWM_3ShuntGetPhaseCurrentValues_1:
   \   0000008E   0x9800             LDR      R0,[SP, #+0]
   \   00000090   0xB001             ADD      SP,SP,#+4
   \   00000092   0x4770             BX       LR               ;; return
    567          }
    568          
    569          /*******************************************************************************
    570          * Function Name  : SVPWM_3ShuntCalcDutyCycles
    571          * Description    : Computes duty cycle values corresponding to the input value
    572          		   and configures the AD converter and TIM0 for next period 
    573          		   current reading conversion synchronization
    574          * Input          : Stat_Volt_alfa_beta
    575          * Output         : None
    576          * Return         : None
    577          *******************************************************************************/
    578          

   \                                 In section .text, align 4, keep-with-next
    579          void SVPWM_3ShuntCalcDutyCycles (Volt_Components Stat_Volt_Input)
    580          {
   \                     SVPWM_3ShuntCalcDutyCycles:
   \   00000000   0xE92D 0x43F1      PUSH     {R0,R4-R9,LR}
    581             s32 wX, wY, wZ, wUAlpha, wUBeta;
    582             u16  hTimePhA=0, hTimePhB=0, hTimePhC=0, hTimePhD=0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x4602             MOV      R2,R0
   \   0000000A   0x4603             MOV      R3,R0
    583             u16  hDeltaDuty;
    584              
    585             wUAlpha = Stat_Volt_Input.qV_Component1 * T_SQRT3 ;
   \   0000000C   0xF9BD 0x4000      LDRSH    R4,[SP, #+0]
   \   00000010   0xF244 0x35A8      MOVW     R5,#+17320
   \   00000014   0x4365             MULS     R5,R5,R4
    586             wUBeta = -(Stat_Volt_Input.qV_Component2 * T);
   \   00000016   0xF9BD 0x4002      LDRSH    R4,[SP, #+2]
   \   0000001A   0x.... 0x....      LDR.W    R6,??DataTable6_8  ;; 0xffffd8f0
   \   0000001E   0x4374             MULS     R4,R4,R6
    587          
    588             wX = wUBeta;
    589             wY = (wUBeta + wUAlpha)/2;
   \   00000020   0x192E             ADDS     R6,R5,R4
   \   00000022   0xEB06 0x76D6      ADD      R6,R6,R6, LSR #+31
   \   00000026   0x1077             ASRS     R7,R6,#+1
    590             wZ = (wUBeta - wUAlpha)/2;
   \   00000028   0x1B65             SUBS     R5,R4,R5
   \   0000002A   0xEB05 0x75D5      ADD      R5,R5,R5, LSR #+31
   \   0000002E   0xEA4F 0x0E65      ASR      LR,R5,#+1
    591             
    592            // Sector calculation from wX, wY, wZ
    593             if (wY<0)
   \   00000032   0x2F00             CMP      R7,#+0
   \   00000034   0xD509             BPL.N    ??SVPWM_3ShuntCalcDutyCycles_1
    594             {
    595                if (wZ<0)
   \   00000036   0xF1BE 0x0F00      CMP      LR,#+0
   \   0000003A   0xBF48             IT       MI 
   \   0000003C   0x2605             MOVMI    R6,#+5
    596                {
    597                  bSector = SECTOR_5;
   \   0000003E   0xD40D             BMI.N    ??SVPWM_3ShuntCalcDutyCycles_2
    598                }
    599                else // wZ >= 0
    600                  if (wX<=0)
   \   00000040   0x2C01             CMP      R4,#+1
   \   00000042   0xBFAC             ITE      GE 
   \   00000044   0x2603             MOVGE    R6,#+3
   \   00000046   0x2604             MOVLT    R6,#+4
    601                  {
    602                    bSector = SECTOR_4;
   \   00000048   0xE008             B.N      ??SVPWM_3ShuntCalcDutyCycles_2
    603                  }
    604                  else // wX > 0
    605                  {
    606                    bSector = SECTOR_3;
    607                  }
    608             }
    609             else // wY > 0
    610             {
    611               if (wZ>=0)
   \                     ??SVPWM_3ShuntCalcDutyCycles_1:
   \   0000004A   0xF1BE 0x0F00      CMP      LR,#+0
   \   0000004E   0xBF58             IT       PL 
   \   00000050   0x2602             MOVPL    R6,#+2
    612               {
    613                 bSector = SECTOR_2;
   \   00000052   0xD503             BPL.N    ??SVPWM_3ShuntCalcDutyCycles_2
    614               }
    615               else // wZ < 0
    616                 if (wX<=0)
   \   00000054   0x2C01             CMP      R4,#+1
   \   00000056   0xBFB4             ITE      LT 
   \   00000058   0x2606             MOVLT    R6,#+6
   \   0000005A   0x2601             MOVGE    R6,#+1
    617                 {  
    618                   bSector = SECTOR_6;
    619                 }
    620                 else // wX > 0
    621                 {
    622                   bSector = SECTOR_1;
   \                     ??SVPWM_3ShuntCalcDutyCycles_2:
   \   0000005C   0x....             LDR.N    R5,??DataTable6_6
   \   0000005E   0x702E             STRB     R6,[R5, #+0]
    623                 }
    624              }
    625             
    626             /* Duty cycles computation */
    627            PWM4Direction=PWM2_MODE;
   \   00000060   0x4680             MOV      R8,R0
    628              
    629            switch(bSector)
   \   00000062   0x....             LDR.N    R6,??DataTable6_9  ;; 0x40012438
   \   00000064   0xF895 0x9000      LDRB     R9,[R5, #+0]
   \   00000068   0xF1A9 0x0901      SUB      R9,R9,#+1
   \   0000006C   0xF1B9 0x0F05      CMP      R9,#+5
   \   00000070   0xD842             BHI.N    ??SVPWM_3ShuntCalcDutyCycles_3
   \   00000072   0xE8DF 0xF019      TBH      [PC, R9, LSL #+1]
   \                     ??SVPWM_3ShuntCalcDutyCycles_0:
   \   00000076   0x0006 0x004E      DC16     0x6,0x4E,0x84,0xB0
   \              0x0084 0x00B0
   \   0000007E   0x00E8 0x0118      DC16     0xE8,0x118
    630            {  
    631              case SECTOR_1:
    632                          hTimePhA = (T/8) + ((((T + wX) - wZ)/2)/131072);
   \                     ??SVPWM_3ShuntCalcDutyCycles_4:
   \   00000082   0xF504 0x501C      ADD      R0,R4,#+9984
   \   00000086   0x3010             ADDS     R0,R0,#+16
   \   00000088   0xEBA0 0x000E      SUB      R0,R0,LR
   \   0000008C   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   00000090   0x1040             ASRS     R0,R0,#+1
   \   00000092   0x1401             ASRS     R1,R0,#+16
   \   00000094   0xEB00 0x30D1      ADD      R0,R0,R1, LSR #+15
   \   00000098   0x1440             ASRS     R0,R0,#+17
   \   0000009A   0xF200 0x40E2      ADDW     R0,R0,#+1250
   \   0000009E   0xB280             UXTH     R0,R0
    633          				hTimePhB = hTimePhA + wZ/131072;
   \   000000A0   0xEA4F 0x412E      ASR      R1,LR,#+16
   \   000000A4   0xEB0E 0x31D1      ADD      R1,LR,R1, LSR #+15
   \   000000A8   0xEB00 0x4161      ADD      R1,R0,R1, ASR #+17
   \   000000AC   0xB289             UXTH     R1,R1
    634          				hTimePhC = hTimePhB - wX/131072;
   \   000000AE   0x1422             ASRS     R2,R4,#+16
   \   000000B0   0xEB04 0x32D2      ADD      R2,R4,R2, LSR #+15
   \   000000B4   0xEBA1 0x4262      SUB      R2,R1,R2, ASR #+17
   \   000000B8   0xB292             UXTH     R2,R2
    635                          
    636                          // ADC Syncronization setting value             
    637                          if ((u16)(PWM_PERIOD-hTimePhA) > TW_AFTER)
   \   000000BA   0xF640 0x13C4      MOVW     R3,#+2500
   \   000000BE   0x1A1B             SUBS     R3,R3,R0
   \   000000C0   0xB29B             UXTH     R3,R3
   \   000000C2   0x2BF2             CMP      R3,#+242
   \   000000C4   0xF080 0x810F      BCS.W    ??SVPWM_3ShuntCalcDutyCycles_5
    638                          {
    639                            hTimePhD = PWM_PERIOD - 1;
    640                          }
    641                          else
    642                          {
    643                            hDeltaDuty = (u16)(hTimePhA - hTimePhB);
    644                            
    645          				  // Definition of crossing point
    646                            if (hDeltaDuty > (u16)(PWM_PERIOD-hTimePhA)*2) 
   \   000000C8   0x005B             LSLS     R3,R3,#+1
   \   000000CA   0x1A44             SUBS     R4,R0,R1
   \   000000CC   0xB2A4             UXTH     R4,R4
   \   000000CE   0x42A3             CMP      R3,R4
   \   000000D0   0xF2C0 0x8112      BLT.W    ??SVPWM_3ShuntCalcDutyCycles_6
    647                            {
    648                                hTimePhD = hTimePhA - TW_BEFORE; // Ts before Phase A 
    649                            }
    650                            else
    651                            {
    652                                hTimePhD = hTimePhA + TW_AFTER; // DT + Tn after Phase A
    653                               
    654                              if (hTimePhD >= PWM_PERIOD)
    655                              {
    656                                // Trigger of ADC at Falling Edge PWM4
    657                                // OCR update
    658                                
    659                                //Set Polarity of CC4 Low
    660                                PWM4Direction=PWM1_MODE;
    661                                
    662                                hTimePhD = (2 * PWM_PERIOD) - hTimePhD-1;
    663                              }
    664                            }
    665                          }
    666                          
    667                          // ADC_InjectedChannelConfig(ADC1, PHASE_B_CHANNEL,1,
    668                          //                                    SAMPLING_TIME_CK);               
    669                          ADC1->JSQR = PHASE_B_MSK + BUS_VOLT_FDBK_MSK + SEQUENCE_LENGHT;
    670                          //ADC_InjectedChannelConfig(ADC2, PHASE_C_CHANNEL,1,
    671                          //                                    SAMPLING_TIME_CK);                     
    672                          ADC2->JSQR = PHASE_C_MSK + TEMP_FDBK_MSK + SEQUENCE_LENGHT;                                         
    673                          break;
    674              case SECTOR_2:
    675                          hTimePhA = (T/8) + ((((T + wY) - wZ)/2)/131072);
    676          				hTimePhB = hTimePhA + wZ/131072;
    677          				hTimePhC = hTimePhA - wY/131072;
    678                          
    679                          // ADC Syncronization setting value
    680                          if ((u16)(PWM_PERIOD-hTimePhB) > TW_AFTER)
    681                          {
    682                            hTimePhD = PWM_PERIOD - 1;
    683                          }
    684                          else
    685                          {
    686                            hDeltaDuty = (u16)(hTimePhB - hTimePhA);
    687                            
    688                            // Definition of crossing point
    689                            if (hDeltaDuty > (u16)(PWM_PERIOD-hTimePhB)*2) 
    690                            {
    691                              hTimePhD = hTimePhB - TW_BEFORE; // Ts before Phase B 
    692                            }
    693                            else
    694                            {
    695                              hTimePhD = hTimePhB + TW_AFTER; // DT + Tn after Phase B
    696                              
    697                              if (hTimePhD >= PWM_PERIOD)
    698                              {
    699                                // Trigger of ADC at Falling Edge PWM4
    700                                // OCR update
    701                                
    702                                //Set Polarity of CC4 Low
    703                                PWM4Direction=PWM1_MODE;
    704                                
    705                                hTimePhD = (2 * PWM_PERIOD) - hTimePhD-1;
    706                              }
    707                            }
    708                          }
    709                          
    710                          //ADC_InjectedChannelConfig(ADC1, PHASE_A_CHANNEL,1,
    711                          //                                     SAMPLING_TIME_CK);               
    712                          ADC1->JSQR = PHASE_A_MSK + BUS_VOLT_FDBK_MSK + SEQUENCE_LENGHT;                
    713                          //ADC_InjectedChannelConfig(ADC2, 
    714                          //                   PHASE_C_CHANNEL,1,SAMPLING_TIME_CK);                              
    715          				ADC2->JSQR = PHASE_C_MSK + TEMP_FDBK_MSK + SEQUENCE_LENGHT;
    716                          break;
    717          
    718              case SECTOR_3:
    719                          hTimePhA = (T/8) + ((((T - wX) + wY)/2)/131072);
    720          				hTimePhC = hTimePhA - wY/131072;
    721          				hTimePhB = hTimePhC + wX/131072;
    722          		
    723                          // ADC Syncronization setting value
    724                          if ((u16)(PWM_PERIOD-hTimePhB) > TW_AFTER)
    725                          {
    726                            hTimePhD = PWM_PERIOD - 1;
    727                          }
    728                          else
    729                          {
    730                            hDeltaDuty = (u16)(hTimePhB - hTimePhC);
    731                            
    732                            // Definition of crossing point
    733                            if (hDeltaDuty > (u16)(PWM_PERIOD-hTimePhB)*2) 
    734                            {
    735                              hTimePhD = hTimePhB - TW_BEFORE; // Ts before Phase B 
    736                            }
    737                            else
    738                            {
    739                              hTimePhD = hTimePhB + TW_AFTER; // DT + Tn after Phase B
    740                              
    741                              if (hTimePhD >= PWM_PERIOD)
    742                              {
    743                                // Trigger of ADC at Falling Edge PWM4
    744                                // OCR update
    745                                
    746                                //Set Polarity of CC4 Low
    747                                PWM4Direction=PWM1_MODE;
    748                                
    749                                hTimePhD = (2 * PWM_PERIOD) - hTimePhD-1;
    750                              }
    751                            }
    752                          }
    753                          
    754                          //ADC_InjectedChannelConfig(ADC1, PHASE_A_CHANNEL,1,
    755                          //                                    SAMPLING_TIME_CK);               
    756                          ADC1->JSQR = PHASE_A_MSK + BUS_VOLT_FDBK_MSK + SEQUENCE_LENGHT;                
    757                          //ADC_InjectedChannelConfig(ADC2, PHASE_C_CHANNEL,1,
    758                          //                                    SAMPLING_TIME_CK);                                        
    759          				ADC2->JSQR = PHASE_C_MSK + TEMP_FDBK_MSK + SEQUENCE_LENGHT;
    760                          break;
    761              
    762              case SECTOR_4:
    763                          hTimePhA = (T/8) + ((((T + wX) - wZ)/2)/131072);
    764                          hTimePhB = hTimePhA + wZ/131072;
    765                          hTimePhC = hTimePhB - wX/131072;
    766                          
    767                          // ADC Syncronization setting value
    768                          if ((u16)(PWM_PERIOD-hTimePhC) > TW_AFTER)
    769                          {
    770                            hTimePhD = PWM_PERIOD - 1;
    771                          }
    772                          else
    773                          {
    774                            hDeltaDuty = (u16)(hTimePhC - hTimePhB);
    775                            
    776                            // Definition of crossing point
    777                            if (hDeltaDuty > (u16)(PWM_PERIOD-hTimePhC)*2)
    778                            {
    779                              hTimePhD = hTimePhC - TW_BEFORE; // Ts before Phase C 
    780                            }
    781                            else
    782                            {
    783                              hTimePhD = hTimePhC + TW_AFTER; // DT + Tn after Phase C
    784                              
    785                              if (hTimePhD >= PWM_PERIOD)
    786                              {
    787                                // Trigger of ADC at Falling Edge PWM4
    788                                // OCR update
    789                                
    790                                //Set Polarity of CC4 Low
    791                                PWM4Direction=PWM1_MODE;
    792                                
    793                                hTimePhD = (2 * PWM_PERIOD) - hTimePhD-1;
    794                              }
    795                            }
    796                          }
    797                          
    798                          //ADC_InjectedChannelConfig(ADC1, PHASE_A_CHANNEL,1,
    799                          //                                    SAMPLING_TIME_CK);             
    800                          ADC1->JSQR = PHASE_A_MSK + BUS_VOLT_FDBK_MSK + SEQUENCE_LENGHT;                
    801                          //ADC_InjectedChannelConfig(ADC2, PHASE_B_CHANNEL,1,
    802                          //                                     SAMPLING_TIME_CK);                                    
    803          				ADC2->JSQR = PHASE_B_MSK + TEMP_FDBK_MSK + SEQUENCE_LENGHT;
    804                          break;  
    805              
    806              case SECTOR_5:
    807                          hTimePhA = (T/8) + ((((T + wY) - wZ)/2)/131072);
    808          				hTimePhB = hTimePhA + wZ/131072;
    809          				hTimePhC = hTimePhA - wY/131072;
    810                          
    811                          // ADC Syncronization setting value
    812                          if ((u16)(PWM_PERIOD-hTimePhC) > TW_AFTER)
    813                          {
    814                            hTimePhD = PWM_PERIOD - 1;
    815                          }
    816                          else
    817                          {
    818                            hDeltaDuty = (u16)(hTimePhC - hTimePhA);
    819                            
    820                            // Definition of crossing point
    821                            if (hDeltaDuty > (u16)(PWM_PERIOD-hTimePhC)*2) 
    822                            {
    823                              hTimePhD = hTimePhC - TW_BEFORE; // Ts before Phase C 
    824                            }
    825                            else
    826                            {
    827                              hTimePhD = hTimePhC + TW_AFTER; // DT + Tn after Phase C
    828                              
    829                              if (hTimePhD >= PWM_PERIOD)
    830                              {
    831                                // Trigger of ADC at Falling Edge PWM4
    832                                // OCR update
    833                                
    834                                //Set Polarity of CC4 Low
    835                                PWM4Direction=PWM1_MODE;
    836                                
    837                                hTimePhD = (2 * PWM_PERIOD) - hTimePhD-1;
    838                              }
    839                            }
    840                          }
    841                          
    842                          //ADC_InjectedChannelConfig(ADC1, PHASE_A_CHANNEL,1,
    843                          //                                   SAMPLING_TIME_CK);              
    844                          ADC1->JSQR = PHASE_A_MSK + BUS_VOLT_FDBK_MSK + SEQUENCE_LENGHT;                
    845                          //ADC_InjectedChannelConfig(ADC2, PHASE_B_CHANNEL,1,
    846                          //                                     SAMPLING_TIME_CK);                                      
    847          				ADC2->JSQR = PHASE_B_MSK + TEMP_FDBK_MSK + SEQUENCE_LENGHT;
    848          		break;
    849                          
    850              case SECTOR_6:
    851                          hTimePhA = (T/8) + ((((T - wX) + wY)/2)/131072);
    852          				hTimePhC = hTimePhA - wY/131072;
    853          				hTimePhB = hTimePhC + wX/131072;
    854                          
    855                          // ADC Syncronization setting value
    856                          if ((u16)(PWM_PERIOD-hTimePhA) > TW_AFTER)
    857                          {
    858                            hTimePhD = PWM_PERIOD - 1;
    859                          }
    860                          else
    861                          {
    862                            hDeltaDuty = (u16)(hTimePhA - hTimePhC);
    863                            
    864                            // Definition of crossing point
    865                            if (hDeltaDuty > (u16)(PWM_PERIOD-hTimePhA)*2) 
    866                            {
    867                              hTimePhD = hTimePhA - TW_BEFORE; // Ts before Phase A 
    868                            }
    869                            else
    870                            {
    871                              hTimePhD = hTimePhA + TW_AFTER; // DT + Tn after Phase A
   \                     ??SVPWM_3ShuntCalcDutyCycles_7:
   \   000000D4   0xF100 0x03F1      ADD      R3,R0,#+241
   \   000000D8   0xB29B             UXTH     R3,R3
    872                              
    873                              if (hTimePhD >= PWM_PERIOD)
   \   000000DA   0xF640 0x14C4      MOVW     R4,#+2500
   \   000000DE   0x42A3             CMP      R3,R4
   \   000000E0   0xDB05             BLT.N    ??SVPWM_3ShuntCalcDutyCycles_8
    874                              {
    875                                // Trigger of ADC at Falling Edge PWM4
    876                                // OCR update
    877                                
    878                                //Set Polarity of CC4 Low
    879                                PWM4Direction=PWM1_MODE;
   \   000000E2   0xF04F 0x0801      MOV      R8,#+1
    880                                
    881                                hTimePhD = (2 * PWM_PERIOD) - hTimePhD-1;
   \   000000E6   0xF241 0x3487      MOVW     R4,#+4999
   \   000000EA   0x1AE3             SUBS     R3,R4,R3
   \                     ??SVPWM_3ShuntCalcDutyCycles_9:
   \   000000EC   0xB29B             UXTH     R3,R3
    882                              }
    883                            }
    884                          }
    885                          
    886                          //ADC_InjectedChannelConfig(ADC1, PHASE_B_CHANNEL,1,
    887                          //                                    SAMPLING_TIME_CK);     
    888                          ADC1->JSQR = PHASE_B_MSK + BUS_VOLT_FDBK_MSK + SEQUENCE_LENGHT;                
   \                     ??SVPWM_3ShuntCalcDutyCycles_8:
   \   000000EE   0x....             LDR.N    R4,??DataTable6_10  ;; 0x101c00
   \                     ??SVPWM_3ShuntCalcDutyCycles_10:
   \   000000F0   0x6034             STR      R4,[R6, #+0]
    889                          //ADC_InjectedChannelConfig(ADC2, PHASE_C_CHANNEL,1,
    890                          //                                    SAMPLING_TIME_CK);                               
    891          				ADC2->JSQR = PHASE_C_MSK + TEMP_FDBK_MSK + SEQUENCE_LENGHT;
   \   000000F2   0x....             LDR.N    R4,??DataTable6_11  ;; 0x16b800
   \                     ??SVPWM_3ShuntCalcDutyCycles_11:
   \   000000F4   0xF8C6 0x4400      STR      R4,[R6, #+1024]
    892                          break;
   \                     ??SVPWM_3ShuntCalcDutyCycles_3:
   \   000000F8   0xF885 0x8001      STRB     R8,[R5, #+1]
    893              default:
    894          		break;
    895             }
    896            
    897            if (PWM4Direction == PWM2_MODE)
   \   000000FC   0x786C             LDRB     R4,[R5, #+1]
   \   000000FE   0x07E4             LSLS     R4,R4,#+31
   \   00000100   0xF8B6 0x47E8      LDRH     R4,[R6, #+2024]
   \   00000104   0xBF5A             ITTE     PL 
   \   00000106   0xF64D 0x75FF      MOVWPL   R5,#+57343
   \   0000010A   0x402C             ANDPL    R4,R5,R4
   \   0000010C   0xF444 0x5400      ORRMI    R4,R4,#0x2000
    898            {
    899              //Set Polarity of CC4 High
    900              TIM1->CCER &= 0xDFFF;    
   \   00000110   0xE0F5             B.N      ??SVPWM_3ShuntCalcDutyCycles_12
    901            }
   \                     ??SVPWM_3ShuntCalcDutyCycles_13:
   \   00000112   0xF507 0x501C      ADD      R0,R7,#+9984
   \   00000116   0x3010             ADDS     R0,R0,#+16
   \   00000118   0xEBA0 0x000E      SUB      R0,R0,LR
   \   0000011C   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   00000120   0x1040             ASRS     R0,R0,#+1
   \   00000122   0x1401             ASRS     R1,R0,#+16
   \   00000124   0xEB00 0x30D1      ADD      R0,R0,R1, LSR #+15
   \   00000128   0x1440             ASRS     R0,R0,#+17
   \   0000012A   0xF200 0x40E2      ADDW     R0,R0,#+1250
   \   0000012E   0xB280             UXTH     R0,R0
   \   00000130   0xEA4F 0x412E      ASR      R1,LR,#+16
   \   00000134   0xEB0E 0x31D1      ADD      R1,LR,R1, LSR #+15
   \   00000138   0xEB00 0x4161      ADD      R1,R0,R1, ASR #+17
   \   0000013C   0xB289             UXTH     R1,R1
   \   0000013E   0x143A             ASRS     R2,R7,#+16
   \   00000140   0xEB07 0x32D2      ADD      R2,R7,R2, LSR #+15
   \   00000144   0xEBA0 0x4262      SUB      R2,R0,R2, ASR #+17
   \   00000148   0xB292             UXTH     R2,R2
   \   0000014A   0xF640 0x13C4      MOVW     R3,#+2500
   \   0000014E   0x1A5B             SUBS     R3,R3,R1
   \   00000150   0xB29B             UXTH     R3,R3
   \   00000152   0x2BF2             CMP      R3,#+242
   \   00000154   0xD233             BCS.N    ??SVPWM_3ShuntCalcDutyCycles_14
   \   00000156   0x005B             LSLS     R3,R3,#+1
   \   00000158   0x1A0C             SUBS     R4,R1,R0
   \   0000015A   0xB2A4             UXTH     R4,R4
   \   0000015C   0x42A3             CMP      R3,R4
   \   0000015E   0xDB37             BLT.N    ??SVPWM_3ShuntCalcDutyCycles_15
   \                     ??SVPWM_3ShuntCalcDutyCycles_16:
   \   00000160   0xF101 0x03F1      ADD      R3,R1,#+241
   \   00000164   0xB29B             UXTH     R3,R3
   \   00000166   0xF640 0x14C4      MOVW     R4,#+2500
   \   0000016A   0x42A3             CMP      R3,R4
   \   0000016C   0xDB05             BLT.N    ??SVPWM_3ShuntCalcDutyCycles_17
   \   0000016E   0xF04F 0x0801      MOV      R8,#+1
   \   00000172   0xF241 0x3487      MOVW     R4,#+4999
   \   00000176   0x1AE3             SUBS     R3,R4,R3
   \                     ??SVPWM_3ShuntCalcDutyCycles_18:
   \   00000178   0xB29B             UXTH     R3,R3
   \                     ??SVPWM_3ShuntCalcDutyCycles_17:
   \   0000017A   0x....             LDR.N    R4,??DataTable6_12  ;; 0x101800
   \   0000017C   0xE7B8             B.N      ??SVPWM_3ShuntCalcDutyCycles_10
   \                     ??SVPWM_3ShuntCalcDutyCycles_19:
   \   0000017E   0xF242 0x7010      MOVW     R0,#+10000
   \   00000182   0x1B00             SUBS     R0,R0,R4
   \   00000184   0x1838             ADDS     R0,R7,R0
   \   00000186   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   0000018A   0x1040             ASRS     R0,R0,#+1
   \   0000018C   0x1401             ASRS     R1,R0,#+16
   \   0000018E   0xEB00 0x30D1      ADD      R0,R0,R1, LSR #+15
   \   00000192   0x1440             ASRS     R0,R0,#+17
   \   00000194   0xF200 0x40E2      ADDW     R0,R0,#+1250
   \   00000198   0xB280             UXTH     R0,R0
   \   0000019A   0x1439             ASRS     R1,R7,#+16
   \   0000019C   0xEB07 0x31D1      ADD      R1,R7,R1, LSR #+15
   \   000001A0   0xEBA0 0x4261      SUB      R2,R0,R1, ASR #+17
   \   000001A4   0xB292             UXTH     R2,R2
   \   000001A6   0x1421             ASRS     R1,R4,#+16
   \   000001A8   0xEB04 0x31D1      ADD      R1,R4,R1, LSR #+15
   \   000001AC   0xEB02 0x4161      ADD      R1,R2,R1, ASR #+17
   \   000001B0   0xB289             UXTH     R1,R1
   \   000001B2   0xF640 0x13C4      MOVW     R3,#+2500
   \   000001B6   0x1A5B             SUBS     R3,R3,R1
   \   000001B8   0xB29B             UXTH     R3,R3
   \   000001BA   0x2BF2             CMP      R3,#+242
   \   000001BC   0xD303             BCC.N    ??SVPWM_3ShuntCalcDutyCycles_20
   \                     ??SVPWM_3ShuntCalcDutyCycles_14:
   \   000001BE   0xF640 0x13C3      MOVW     R3,#+2499
   \   000001C2   0x....             LDR.N    R4,??DataTable6_12  ;; 0x101800
   \   000001C4   0xE794             B.N      ??SVPWM_3ShuntCalcDutyCycles_10
   \                     ??SVPWM_3ShuntCalcDutyCycles_20:
   \   000001C6   0x005B             LSLS     R3,R3,#+1
   \   000001C8   0x1A8C             SUBS     R4,R1,R2
   \   000001CA   0xB2A4             UXTH     R4,R4
   \   000001CC   0x42A3             CMP      R3,R4
   \   000001CE   0xDAC7             BGE.N    ??SVPWM_3ShuntCalcDutyCycles_16
   \                     ??SVPWM_3ShuntCalcDutyCycles_15:
   \   000001D0   0xF1A1 0x030F      SUB      R3,R1,#+15
   \   000001D4   0xE7D0             B.N      ??SVPWM_3ShuntCalcDutyCycles_18
   \                     ??SVPWM_3ShuntCalcDutyCycles_21:
   \   000001D6   0xF504 0x501C      ADD      R0,R4,#+9984
   \   000001DA   0x3010             ADDS     R0,R0,#+16
   \   000001DC   0xEBA0 0x000E      SUB      R0,R0,LR
   \   000001E0   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   000001E4   0x1040             ASRS     R0,R0,#+1
   \   000001E6   0x1401             ASRS     R1,R0,#+16
   \   000001E8   0xEB00 0x30D1      ADD      R0,R0,R1, LSR #+15
   \   000001EC   0x1440             ASRS     R0,R0,#+17
   \   000001EE   0xF200 0x40E2      ADDW     R0,R0,#+1250
   \   000001F2   0xB280             UXTH     R0,R0
   \   000001F4   0xEA4F 0x412E      ASR      R1,LR,#+16
   \   000001F8   0xEB0E 0x31D1      ADD      R1,LR,R1, LSR #+15
   \   000001FC   0xEB00 0x4161      ADD      R1,R0,R1, ASR #+17
   \   00000200   0xB289             UXTH     R1,R1
   \   00000202   0x1422             ASRS     R2,R4,#+16
   \   00000204   0xEB04 0x32D2      ADD      R2,R4,R2, LSR #+15
   \   00000208   0xEBA1 0x4262      SUB      R2,R1,R2, ASR #+17
   \   0000020C   0xB292             UXTH     R2,R2
   \   0000020E   0xF640 0x13C4      MOVW     R3,#+2500
   \   00000212   0x1A9B             SUBS     R3,R3,R2
   \   00000214   0xB29B             UXTH     R3,R3
   \   00000216   0x2BF2             CMP      R3,#+242
   \   00000218   0xD237             BCS.N    ??SVPWM_3ShuntCalcDutyCycles_22
   \   0000021A   0x005B             LSLS     R3,R3,#+1
   \   0000021C   0x1A54             SUBS     R4,R2,R1
   \   0000021E   0xB2A4             UXTH     R4,R4
   \   00000220   0x42A3             CMP      R3,R4
   \   00000222   0xDB3D             BLT.N    ??SVPWM_3ShuntCalcDutyCycles_23
   \                     ??SVPWM_3ShuntCalcDutyCycles_24:
   \   00000224   0xF102 0x03F1      ADD      R3,R2,#+241
   \   00000228   0xB29B             UXTH     R3,R3
   \   0000022A   0xF640 0x14C4      MOVW     R4,#+2500
   \   0000022E   0x42A3             CMP      R3,R4
   \   00000230   0xDB05             BLT.N    ??SVPWM_3ShuntCalcDutyCycles_25
   \   00000232   0xF04F 0x0801      MOV      R8,#+1
   \   00000236   0xF241 0x3487      MOVW     R4,#+4999
   \   0000023A   0x1AE3             SUBS     R3,R4,R3
   \                     ??SVPWM_3ShuntCalcDutyCycles_26:
   \   0000023C   0xB29B             UXTH     R3,R3
   \                     ??SVPWM_3ShuntCalcDutyCycles_25:
   \   0000023E   0x....             LDR.N    R4,??DataTable6_12  ;; 0x101800
   \   00000240   0x6034             STR      R4,[R6, #+0]
   \   00000242   0x....             LDR.N    R4,??DataTable6_13  ;; 0x169c00
   \   00000244   0xE756             B.N      ??SVPWM_3ShuntCalcDutyCycles_11
   \                     ??SVPWM_3ShuntCalcDutyCycles_27:
   \   00000246   0xF507 0x501C      ADD      R0,R7,#+9984
   \   0000024A   0x3010             ADDS     R0,R0,#+16
   \   0000024C   0xEBA0 0x000E      SUB      R0,R0,LR
   \   00000250   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   00000254   0x1040             ASRS     R0,R0,#+1
   \   00000256   0x1401             ASRS     R1,R0,#+16
   \   00000258   0xEB00 0x30D1      ADD      R0,R0,R1, LSR #+15
   \   0000025C   0x1440             ASRS     R0,R0,#+17
   \   0000025E   0xF200 0x40E2      ADDW     R0,R0,#+1250
   \   00000262   0xB280             UXTH     R0,R0
   \   00000264   0xEA4F 0x412E      ASR      R1,LR,#+16
   \   00000268   0xEB0E 0x31D1      ADD      R1,LR,R1, LSR #+15
   \   0000026C   0xEB00 0x4161      ADD      R1,R0,R1, ASR #+17
   \   00000270   0xB289             UXTH     R1,R1
   \   00000272   0x143A             ASRS     R2,R7,#+16
   \   00000274   0xEB07 0x32D2      ADD      R2,R7,R2, LSR #+15
   \   00000278   0xEBA0 0x4262      SUB      R2,R0,R2, ASR #+17
   \   0000027C   0xB292             UXTH     R2,R2
   \   0000027E   0xF640 0x13C4      MOVW     R3,#+2500
   \   00000282   0x1A9B             SUBS     R3,R3,R2
   \   00000284   0xB29B             UXTH     R3,R3
   \   00000286   0x2BF2             CMP      R3,#+242
   \   00000288   0xD305             BCC.N    ??SVPWM_3ShuntCalcDutyCycles_28
   \                     ??SVPWM_3ShuntCalcDutyCycles_22:
   \   0000028A   0xF640 0x13C3      MOVW     R3,#+2499
   \   0000028E   0x....             LDR.N    R4,??DataTable6_12  ;; 0x101800
   \   00000290   0x6034             STR      R4,[R6, #+0]
   \   00000292   0x....             LDR.N    R4,??DataTable6_13  ;; 0x169c00
   \   00000294   0xE72E             B.N      ??SVPWM_3ShuntCalcDutyCycles_11
   \                     ??SVPWM_3ShuntCalcDutyCycles_28:
   \   00000296   0x005B             LSLS     R3,R3,#+1
   \   00000298   0x1A14             SUBS     R4,R2,R0
   \   0000029A   0xB2A4             UXTH     R4,R4
   \   0000029C   0x42A3             CMP      R3,R4
   \   0000029E   0xDAC1             BGE.N    ??SVPWM_3ShuntCalcDutyCycles_24
   \                     ??SVPWM_3ShuntCalcDutyCycles_23:
   \   000002A0   0xF1A2 0x030F      SUB      R3,R2,#+15
   \   000002A4   0xE7CA             B.N      ??SVPWM_3ShuntCalcDutyCycles_26
   \                     ??SVPWM_3ShuntCalcDutyCycles_29:
   \   000002A6   0xF242 0x7010      MOVW     R0,#+10000
   \   000002AA   0x1B00             SUBS     R0,R0,R4
   \   000002AC   0x1838             ADDS     R0,R7,R0
   \   000002AE   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   000002B2   0x1040             ASRS     R0,R0,#+1
   \   000002B4   0x1401             ASRS     R1,R0,#+16
   \   000002B6   0xEB00 0x30D1      ADD      R0,R0,R1, LSR #+15
   \   000002BA   0x1440             ASRS     R0,R0,#+17
   \   000002BC   0xF200 0x40E2      ADDW     R0,R0,#+1250
   \   000002C0   0xB280             UXTH     R0,R0
   \   000002C2   0x1439             ASRS     R1,R7,#+16
   \   000002C4   0xEB07 0x31D1      ADD      R1,R7,R1, LSR #+15
   \   000002C8   0xEBA0 0x4261      SUB      R2,R0,R1, ASR #+17
   \   000002CC   0xB292             UXTH     R2,R2
   \   000002CE   0x1421             ASRS     R1,R4,#+16
   \   000002D0   0xEB04 0x31D1      ADD      R1,R4,R1, LSR #+15
   \   000002D4   0xEB02 0x4161      ADD      R1,R2,R1, ASR #+17
   \   000002D8   0xB289             UXTH     R1,R1
   \   000002DA   0xF640 0x13C4      MOVW     R3,#+2500
   \   000002DE   0x1A1B             SUBS     R3,R3,R0
   \   000002E0   0xB29B             UXTH     R3,R3
   \   000002E2   0x2BF2             CMP      R3,#+242
   \   000002E4   0xD302             BCC.N    ??SVPWM_3ShuntCalcDutyCycles_30
   \                     ??SVPWM_3ShuntCalcDutyCycles_5:
   \   000002E6   0xF640 0x13C3      MOVW     R3,#+2499
   \   000002EA   0xE700             B.N      ??SVPWM_3ShuntCalcDutyCycles_8
   \                     ??SVPWM_3ShuntCalcDutyCycles_30:
   \   000002EC   0x005B             LSLS     R3,R3,#+1
   \   000002EE   0x1A84             SUBS     R4,R0,R2
   \   000002F0   0xB2A4             UXTH     R4,R4
   \   000002F2   0x42A3             CMP      R3,R4
   \   000002F4   0xF6BF 0xAEEE      BGE.W    ??SVPWM_3ShuntCalcDutyCycles_7
   \                     ??SVPWM_3ShuntCalcDutyCycles_6:
   \   000002F8   0xF1A0 0x030F      SUB      R3,R0,#+15
   \   000002FC   0xE6F6             B.N      ??SVPWM_3ShuntCalcDutyCycles_9
   \                     ??SVPWM_3ShuntCalcDutyCycles_12:
   \   000002FE   0xF8A6 0x47E8      STRH     R4,[R6, #+2024]
    902            else
    903            {
    904              //Set Polarity of CC4 Low
    905              TIM1->CCER |= 0x2000;
    906            }
    907            
    908            /* Load compare registers values */ 
    909            TIM1->CCR1 = hTimePhA;
   \   00000302   0xF8A6 0x07FC      STRH     R0,[R6, #+2044]
    910            TIM1->CCR2 = hTimePhB;
   \   00000306   0xF8A6 0x1800      STRH     R1,[R6, #+2048]
    911            TIM1->CCR3 = hTimePhC;
   \   0000030A   0xF8A6 0x2804      STRH     R2,[R6, #+2052]
    912            TIM1->CCR4 = hTimePhD; // To Syncronyze the ADC
   \   0000030E   0xF8A6 0x3808      STRH     R3,[R6, #+2056]
    913          }
   \   00000312   0xB001             ADD      SP,SP,#+4
   \   00000314   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    914          
    915          /*******************************************************************************
    916          * Function Name  : SVPWM_3ShuntAdvCurrentReading
    917          * Description    :  It is used to enable or disable the advanced current reading.
    918          			if disabled the current readign will be performed after update event
    919          * Input          : cmd (ENABLE or DISABLE)
    920          * Output         : None
    921          * Return         : None
    922          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    923          void SVPWM_3ShuntAdvCurrentReading(FunctionalState cmd)
    924          {
   \                     SVPWM_3ShuntAdvCurrentReading:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    925            if (cmd == ENABLE)
   \   00000004   0x....             LDR.N    R4,??DataTable6_3  ;; 0x40012c00
   \   00000006   0x....             LDR.N    R5,??DataTable6_14  ;; 0x40012408
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD10F             BNE.N    ??SVPWM_3ShuntAdvCurrentReading_0
    926            {
    927              // Enable ADC trigger sync with CC4
    928              //ADC_ExternalTrigInjectedConvConfig(ADC1, ADC_ExternalTrigInjecConv_T1_CC4);  
    929              ADC1->CR2 |= 0x00001000;
   \   0000000C   0x6828             LDR      R0,[R5, #+0]
   \   0000000E   0xF440 0x5080      ORR      R0,R0,#0x1000
   \   00000012   0x6028             STR      R0,[R5, #+0]
    930              
    931              // Enable UPDATE ISR
    932              // Clear Update Flag
    933              TIM_ClearFlag(TIM1, TIM_FLAG_Update);
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       TIM_ClearFlag
    934              TIM_ITConfig(TIM1, TIM_IT_Update, ENABLE);
   \   0000001C   0x2201             MOVS     R2,#+1
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0xB001             ADD      SP,SP,#+4
   \   00000024   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   00000028   0x.... 0x....      B.W      TIM_ITConfig
    935            }
    936            else
    937            {
    938              // Disable UPDATE ISR
    939              TIM_ITConfig(TIM1, TIM_IT_Update, DISABLE);
   \                     ??SVPWM_3ShuntAdvCurrentReading_0:
   \   0000002C   0x2200             MOVS     R2,#+0
   \   0000002E   0x2101             MOVS     R1,#+1
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       TIM_ITConfig
    940          
    941              // Sync ADC trigger with Update
    942              //ADC_ExternalTrigInjectedConvConfig(ADC1, ADC_ExternalTrigInjecConv_T1_TRGO);
    943              ADC1->CR2 &=0xFFFFEFFF;
   \   00000036   0x6828             LDR      R0,[R5, #+0]
   \   00000038   0xF420 0x5080      BIC      R0,R0,#0x1000
   \   0000003C   0x6028             STR      R0,[R5, #+0]
    944              
    945              // ReEnable EXT. ADC Triggering
    946              ADC1->CR2 |=0x00008000;    
   \   0000003E   0x6828             LDR      R0,[R5, #+0]
   \   00000040   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   00000044   0x6028             STR      R0,[R5, #+0]
    947            }
    948          }
   \   00000046   0xB001             ADD      SP,SP,#+4
   \   00000048   0xBD30             POP      {R4,R5,PC}       ;; return
    949          
    950          /*******************************************************************************
    951          * Function Name  : SVPWMUpdateEvent
    952          * Description    :  Routine to be performed inside the update event ISR  it reenable the ext adc. triggering
    953          		        It must be assigned to pSVPWM_UpdateEvent pointer.	
    954          * Input           : None
    955          * Output         : None
    956          * Return         : None
    957          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    958          void SVPWMUpdateEvent(void)
    959          {
    960            // ReEnable EXT. ADC Triggering
    961            ADC1->CR2 |= 0x00008000;
   \                     SVPWMUpdateEvent:
   \   00000000   0x....             LDR.N    R0,??DataTable6_4  ;; 0x40012400
   \   00000002   0x6881             LDR      R1,[R0, #+8]
   \   00000004   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000008   0x6081             STR      R1,[R0, #+8]
    962            
    963            // Clear unwanted current sampling
    964            ADC_ClearFlag(ADC1, ADC_FLAG_JEOC);
   \   0000000A   0x2104             MOVS     R1,#+4
   \   0000000C   0x.... 0x....      B.W      ADC_ClearFlag
    965          }
    966          
    967          /*******************************************************************************
    968          * Function Name  : SVPWMEOCEvent
    969          * Description    :  Routine to be performed inside the end of conversion ISR
    970          		         It computes the bus voltage and temperature sensor sampling 
    971          		        and disable the ext. adc triggering.	
    972          * Input           : None
    973          * Output         : None
    974          * Return         : None
    975          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    976          u8 SVPWMEOCEvent(void)
    977          {
   \                     SVPWMEOCEvent:
   \   00000000   0xB510             PUSH     {R4,LR}
    978            // Store the Bus Voltage and temperature sampled values
    979            h_ADCTemp = ADC_GetInjectedConversionValue(ADC2,ADC_InjectedChannel_2);
   \   00000002   0x2118             MOVS     R1,#+24
   \   00000004   0x....             LDR.N    R0,??DataTable6_5  ;; 0x40012800
   \   00000006   0x.... 0x....      BL       ADC_GetInjectedConversionValue
   \   0000000A   0x....             LDR.N    R1,??DataTable6_15
   \   0000000C   0x8008             STRH     R0,[R1, #+0]
    980            h_ADCBusvolt = ADC_GetInjectedConversionValue(ADC1,ADC_InjectedChannel_2);
   \   0000000E   0x....             LDR.N    R4,??DataTable6_4  ;; 0x40012400
   \   00000010   0x2118             MOVS     R1,#+24
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       ADC_GetInjectedConversionValue
   \   00000018   0x....             LDR.N    R1,??DataTable6_16
   \   0000001A   0x8008             STRH     R0,[R1, #+0]
    981              
    982            if ((State == START) || (State == RUN))
   \   0000001C   0x....             LDR.N    R0,??DataTable6_17
   \   0000001E   0x7801             LDRB     R1,[R0, #+0]
   \   00000020   0x2902             CMP      R1,#+2
   \   00000022   0xBF1C             ITT      NE 
   \   00000024   0x7800             LDRBNE   R0,[R0, #+0]
   \   00000026   0x2803             CMPNE    R0,#+3
   \   00000028   0xD103             BNE.N    ??SVPWMEOCEvent_0
    983            {          
    984              // Disable EXT. ADC Triggering
    985              ADC1->CR2 = ADC1->CR2 & 0xFFFF7FFF;
   \   0000002A   0x68A0             LDR      R0,[R4, #+8]
   \   0000002C   0xF420 0x4000      BIC      R0,R0,#0x8000
   \   00000030   0x60A0             STR      R0,[R4, #+8]
    986            }
    987            return ((u8)(1));
   \                     ??SVPWMEOCEvent_0:
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    988          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x40010C00         DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x40012C00         DC32     0x40012c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x40012400         DC32     0x40012400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x40012800         DC32     0x40012800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x........         DC32     bSector

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x4001243C         DC32     0x4001243c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0xFFFFD8F0         DC32     0xffffd8f0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \   00000000   0x40012438         DC32     0x40012438

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \   00000000   0x00101C00         DC32     0x101c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_11:
   \   00000000   0x0016B800         DC32     0x16b800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_12:
   \   00000000   0x00101800         DC32     0x101800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_13:
   \   00000000   0x00169C00         DC32     0x169c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_14:
   \   00000000   0x40012408         DC32     0x40012408

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_15:
   \   00000000   0x........         DC32     h_ADCTemp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_16:
   \   00000000   0x........         DC32     h_ADCBusvolt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_17:
   \   00000000   0x........         DC32     State
    989          
    990          #endif
    991          
    992          /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/  

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  SVPWMEOCEvent
              8 -> ADC_GetInjectedConversionValue
        0  SVPWMUpdateEvent
              0 -> ADC_ClearFlag
       16  SVPWM_3ShuntAdvCurrentReading
             16 -> TIM_ClearFlag
              0 -> TIM_ITConfig
             16 -> TIM_ITConfig
       32  SVPWM_3ShuntCalcDutyCycles
       16  SVPWM_3ShuntCurrentReadingCalibration
             16 -> ADC_ClearFlag
             16 -> ADC_ExternalTrigInjectedConvCmd
             16 -> ADC_ExternalTrigInjectedConvConfig
             16 -> ADC_GetFlagStatus
             16 -> ADC_GetInjectedConversionValue
             16 -> ADC_ITConfig
             16 -> ADC_InjectedChannelConfig
             16 -> ADC_InjectedSequencerLengthConfig
             16 -> ADC_SoftwareStartInjectedConvCmd
              0 -> SVPWM_InjectedConvConfig
        4  SVPWM_3ShuntGetPhaseCurrentValues
       96  SVPWM_3ShuntInit
             96 -> ADC_Cmd
             96 -> ADC_DeInit
             96 -> ADC_GetCalibrationStatus
             96 -> ADC_Init
             96 -> ADC_InjectedChannelConfig
             96 -> ADC_InjectedSequencerLengthConfig
             96 -> ADC_StartCalibration
             96 -> ADC_StructInit
             96 -> GPIO_Init
             96 -> GPIO_StructInit
             96 -> NVIC_Init
             96 -> NVIC_PriorityGroupConfig
             96 -> NVIC_StructInit
             96 -> RCC_ADCCLKConfig
             96 -> RCC_AHBPeriphClockCmd
             96 -> RCC_APB2PeriphClockCmd
             96 -> SVPWM_3ShuntCurrentReadingCalibration
             96 -> TIM_BDTRConfig
             96 -> TIM_ClearFlag
             96 -> TIM_ClearITPendingBit
             96 -> TIM_Cmd
             96 -> TIM_DeInit
             96 -> TIM_GenerateEvent
             96 -> TIM_ITConfig
             96 -> TIM_OC1Init
             96 -> TIM_OC1PreloadConfig
             96 -> TIM_OC2Init
             96 -> TIM_OC2PreloadConfig
             96 -> TIM_OC3Init
             96 -> TIM_OC3PreloadConfig
             96 -> TIM_OC4Init
             96 -> TIM_OC4PreloadConfig
             96 -> TIM_OCStructInit
             96 -> TIM_SelectOutputTrigger
             96 -> TIM_TimeBaseInit
             96 -> TIM_TimeBaseStructInit
       16  SVPWM_InjectedConvConfig
             16 -> ADC_ExternalTrigInjectedConvCmd
             16 -> ADC_ExternalTrigInjectedConvConfig
              0 -> ADC_ITConfig
             16 -> ADC_InjectedChannelConfig
             16 -> ADC_InjectedSequencerLengthConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_12
       4  ??DataTable6_13
       4  ??DataTable6_14
       4  ??DataTable6_15
       4  ??DataTable6_16
       4  ??DataTable6_17
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
      54  SVPWMEOCEvent
      16  SVPWMUpdateEvent
      74  SVPWM_3ShuntAdvCurrentReading
     792  SVPWM_3ShuntCalcDutyCycles
     208  SVPWM_3ShuntCurrentReadingCalibration
     148  SVPWM_3ShuntGetPhaseCurrentValues
     818  SVPWM_3ShuntInit
      86  SVPWM_InjectedConvConfig
      10  bSector
          PWM4Direction
          hPhaseAOffset
          hPhaseBOffset
          hPhaseCOffset
          bIndex

 
    10 bytes in section .bss
 2 268 bytes in section .text
 
 2 268 bytes of CODE memory
    10 bytes of DATA memory

Errors: none
Warnings: 3
