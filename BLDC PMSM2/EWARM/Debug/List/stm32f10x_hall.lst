###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.1.53790/W32 for ARM     24/Feb/2014  19:26:46 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\stm32\BLDC PMSM2\src\stm32f10x_hall.c                 #
#    Command line =  "D:\stm32\BLDC PMSM2\src\stm32f10x_hall.c" -D            #
#                    VECT_TAB_FLASH -lCN "D:\stm32\BLDC                       #
#                    PMSM2\EWARM\Debug\List\" --diag_error Pe068,Pe069 -o     #
#                    "D:\stm32\BLDC PMSM2\EWARM\Debug\Obj\" --debug           #
#                    --endian=little --cpu=Cortex-M3 --fpu=None               #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 6.4\arm\INC\c\DLib_Config_Normal.h" -I         #
#                    "D:\stm32\BLDC PMSM2\EWARM\..\" -I "D:\stm32\BLDC        #
#                    PMSM2\EWARM\..\..\STM32F10XFWLIB\inc\" -I                #
#                    "D:\stm32\BLDC PMSM2\EWARM\..\inc\" -Oh                  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  D:\stm32\BLDC PMSM2\EWARM\Debug\List\stm32f10x_hall.lst  #
#    Object file  =  D:\stm32\BLDC PMSM2\EWARM\Debug\Obj\stm32f10x_hall.o     #
#                                                                             #
#                                                                             #
###############################################################################

D:\stm32\BLDC PMSM2\src\stm32f10x_hall.c
      1          /******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
      2          * File Name          : stm32f10x_hall.c
      3          * Author             : IMS Systems Lab 
      4          * Date First Issued  : 21/11/07
      5          * Description        : Module handling speed feedback provided by three Hall 
      6          *                      sensors
      7          ********************************************************************************
      8          * History:
      9          * 21/11/07 v1.0
     10          * 29/05/08 v2.0
     11          * 26/06/08 v2.0.1
     12          * 27/06/08 v2.0.2
     13          ********************************************************************************
     14          * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     15          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     16          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     17          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     18          * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     19          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     20          *
     21          * THIS SOURCE CODE IS PROTECTED BY A LICENSE.
     22          * FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED
     23          * IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
     24          *******************************************************************************/
     25          
     26          /* Includes ------------------------------------------------------------------*/
     27          #include "stm32f10x_lib.h"
     28          #include "stm32f10x_hall.h"
     29          #include "MC_hall_prm.h"
     30          #include "MC_Globals.h"
     31          #include "stm32f10x_MClib.h"
     32          #include "stm32f10x_it.h"
     33          /* Private define ------------------------------------------------------------*/
     34          #define HALL_MAX_SPEED_FDBK (u16)(HALL_MAX_SPEED_FDBK_RPM/6 * POLE_PAIR_NUM)
     35          #define HALL_MIN_SPEED_FDBK (u16)(HALL_MIN_SPEED_FDBK_RPM/6* POLE_PAIR_NUM)
     36          #define LOW_RES_THRESHOLD   ((u16)0x5500u)// If capture below, ck prsc decreases
     37          #define	ROTOR_SPEED_FACTOR  ((u32)((CKTIM*10)) / 3)
     38          #define PSEUDO_FREQ_CONV    ((u32)(ROTOR_SPEED_FACTOR / (SAMPLING_FREQ * 10)) * 0x10000uL)
     39          #define SPEED_OVERFLOW      ((u32)(ROTOR_SPEED_FACTOR / HALL_MAX_SPEED_FDBK))
     40          #define MAX_PERIOD          ((u32)(ROTOR_SPEED_FACTOR / HALL_MIN_SPEED_FDBK))
     41          #define HALL_COUNTER_RESET  ((u16) 0)
     42          #define S16_PHASE_SHIFT     (s16)(HALL_PHASE_SHIFT * 65536/360)
     43          #define S16_120_PHASE_SHIFT (s16)(65536/3)
     44          #define S16_60_PHASE_SHIFT  (s16)(65536/6)
     45          
     46          #define STATE_0 (u8)0
     47          #define STATE_1 (u8)1
     48          #define STATE_2 (u8)2
     49          #define STATE_3 (u8)3
     50          #define STATE_4 (u8)4
     51          #define STATE_5 (u8)5
     52          #define STATE_6 (u8)6
     53          #define STATE_7 (u8)7
     54          
     55          #define NEGATIVE          (s8)-1
     56          #define POSITIVE          (s8)1
     57          #define NEGATIVE_SWAP     (s8)-2
     58          #define POSITIVE_SWAP     (s8)2
     59          #define ERROR             (s8)127
     60          
     61          #define GPIO_MSK (u8)0x07
     62          #define ICx_FILTER (u8) 0x0B // 11 <-> 1333 nsec 
     63          
     64          #define TIMx_PRE_EMPTION_PRIORITY 2
     65          #define TIMx_SUB_PRIORITY 0
     66          
     67          /* if (HALL_SENSORS_PLACEMENT == DEGREES_120)
     68          The sequence of the states is {STATE_5,STATE_1,STATE_3,STATE_2,STATE_6,STATE_4}
     69          else if (HALL_SENSORS_PLACEMENT == DEGREES_60)
     70          the sequence is {STATE_1,STATE_3,STATE_7,STATE_6,STATE_4,STATE_0}*/
     71          
     72          // Here is practically assigned the timer for Hall handling
     73          #if defined(TIMER2_HANDLES_HALL)
     74              #define HALL_TIMER TIM2
     75          #elif defined(TIMER3_HANDLES_HALL)
     76              #define HALL_TIMER TIM3
     77          #else // TIMER4_HANDLES_HALL
     78              #define HALL_TIMER TIM4
     79          #endif
     80          
     81          /* Private macro -------------------------------------------------------------*/
     82          /* Private typedef -----------------------------------------------------------*/
     83          typedef struct {
     84          	u16 hCapture;
     85          	u16 hPrscReg;
     86                  s8 bDirection;
     87          	} SpeedMeas_s;
     88          
     89          typedef struct {
     90                  u32 wPeriod;
     91                  s8 bDirection;
     92                  } PeriodMeas_s;
     93          /* Private variables ---------------------------------------------------------*/
     94          

   \                                 In section .bss, align 4
     95          volatile SpeedMeas_s SensorPeriod[HALL_SPEED_FIFO_SIZE];// Holding the last captures
   \                     SensorPeriod:
   \   00000000                      DS8 36
     96          vu8 bSpeedFIFO_Index;   // Index of above array
     97          vu8 bGP1_OVF_Counter;   // Count overflows if prescaler is too low
     98          vu16 hCaptCounter;      // Counts the number of captures interrupts
     99          volatile PeriodMeas_s PeriodMeas;
    100          
    101          volatile bool RatioDec;
    102          volatile bool RatioInc;
    103          volatile bool DoRollingAverage;
    104          volatile bool InitRollingAverage;
    105          volatile bool HallTimeOut;
    106          static s16 hElectrical_Angle; 
    107          static s16 hRotorFreq_dpp;
    108          #if (defined HALL_SENSORS || defined VIEW_HALL_FEEDBACK)
    109          static s8 bSpeed;
    110          #endif
    111          /* Private function prototypes -----------------------------------------------*/
    112          PeriodMeas_s GetLastHallPeriod(void);
    113          PeriodMeas_s GetAvrgHallPeriod(void);
    114          void HALL_StartHallFiltering(void);
    115          u16  HALL_GetCaptCounter(void);
    116          void HALL_ClrCaptCounter(void);
    117          
    118          u8  ReadHallState(void); 
    119          /*******************************************************************************
    120          * Function Name  : Hall_HallTimerInit
    121          * Description    : Initializes the timer handling Hall sensors feedback
    122          * Input          : None
    123          * Output         : None
    124          * Return         : None
    125          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    126          void HALL_HallTimerInit(void)
    127          {
   \                     HALL_HallTimerInit:
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
    128          
    129            TIM_TimeBaseInitTypeDef TIM_HALLTimeBaseInitStructure;
    130            TIM_ICInitTypeDef       TIM_HALLICInitStructure;
    131            NVIC_InitTypeDef        NVIC_InitHALLStructure;
    132            GPIO_InitTypeDef        GPIO_InitStructure;
    133            
    134          #if defined(TIMER2_HANDLES_HALL)
    135              /* TIM2 clock source enable */
    136              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
    137              /* Enable GPIOA, clock */
    138              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x2004             MOVS     R0,#+4
   \   00000010   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    139          
    140              GPIO_StructInit(&GPIO_InitStructure);
   \   00000014   0xA801             ADD      R0,SP,#+4
   \   00000016   0x.... 0x....      BL       GPIO_StructInit
    141              /* Configure PA.00,01 ,02 as Hall sensors input */
    142              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2;
   \   0000001A   0x2007             MOVS     R0,#+7
   \   0000001C   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    143              GPIO_InitStructure.GPIO_Mode =GPIO_Mode_IPU;// GPIO_Mode_IN_FLOATING;
   \   00000020   0x2048             MOVS     R0,#+72
   \   00000022   0xF88D 0x0007      STRB     R0,[SP, #+7]
    144              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   00000026   0xA901             ADD      R1,SP,#+4
   \   00000028   0x....             LDR.N    R0,??DataTable14  ;; 0x40010800
   \   0000002A   0x.... 0x....      BL       GPIO_Init
    145          #elif defined(TIMER3_HANDLES_HALL)
    146          	GPIO_PinRemapConfig(GPIO_Remap_TIM4, ENABLE);
    147              /* TIM3 clock source enable */
    148              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
    149              /* Enable GPIOA, clock */
    150              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC|RCC_APB2Periph_AFIO, ENABLE);
    151              /* Enable GPIOB, clock */
    152              //RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
    153          
    154              GPIO_StructInit(&GPIO_InitStructure);
    155              /* Configure PA.06,07  PB.00 as Hall sensors input */
    156              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7| GPIO_Pin_8;
    157              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    158              GPIO_Init(GPIOC, &GPIO_InitStructure);
    159          
    160              //GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
    161              //GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    162              //GPIO_Init(GPIOB, &GPIO_InitStructure);
    163            #else // TIMER4_HANDLES_HALL
    164              /* TIM4 clock source enable */
    165              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);
    166              /* Enable GPIOB, clock */
    167              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
    168              /* Configure PB.06,07,08 as Hall sensors input */	
    169              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6, GPIO_Pin_7, GPIO_Pin_8;
    170              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    171              GPIO_Init(GPIOB, &GPIO_InitStructure);	
    172            #endif
    173                
    174              // Timer configuration in Clear on capture mode
    175              TIM_DeInit(HALL_TIMER);
   \   0000002E   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000032   0x.... 0x....      BL       TIM_DeInit
    176              
    177              TIM_TimeBaseStructInit(&TIM_HALLTimeBaseInitStructure);
   \   00000036   0xA805             ADD      R0,SP,#+20
   \   00000038   0x.... 0x....      BL       TIM_TimeBaseStructInit
    178              // Set full 16-bit working range
    179              TIM_HALLTimeBaseInitStructure.TIM_Period = U16_MAX;
   \   0000003C   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000040   0xF8AD 0x0018      STRH     R0,[SP, #+24]
    180              TIM_HALLTimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF8AD 0x001A      STRH     R0,[SP, #+26]
    181              TIM_TimeBaseInit(HALL_TIMER,&TIM_HALLTimeBaseInitStructure);
   \   0000004A   0xA905             ADD      R1,SP,#+20
   \   0000004C   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000050   0x.... 0x....      BL       TIM_TimeBaseInit
    182              
    183              TIM_ICStructInit(&TIM_HALLICInitStructure);
   \   00000054   0xA802             ADD      R0,SP,#+8
   \   00000056   0x.... 0x....      BL       TIM_ICStructInit
    184              TIM_HALLICInitStructure.TIM_Channel = TIM_Channel_1;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    185              TIM_HALLICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Falling;
   \   00000060   0x2002             MOVS     R0,#+2
   \   00000062   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    186              TIM_HALLICInitStructure.TIM_ICFilter = ICx_FILTER;
   \   00000066   0x200B             MOVS     R0,#+11
   \   00000068   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    187              
    188              TIM_ICInit(HALL_TIMER,&TIM_HALLICInitStructure);
   \   0000006C   0xA902             ADD      R1,SP,#+8
   \   0000006E   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000072   0x.... 0x....      BL       TIM_ICInit
    189              
    190              // Force the HALL_TIMER prescaler with immediate access (no need of an update event) 
    191              TIM_PrescalerConfig(HALL_TIMER, (u16) HALL_MAX_RATIO, 
    192                                 TIM_PSCReloadMode_Immediate);
   \   00000076   0x2201             MOVS     R2,#+1
   \   00000078   0xF44F 0x7148      MOV      R1,#+800
   \   0000007C   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000080   0x.... 0x....      BL       TIM_PrescalerConfig
    193              TIM_InternalClockConfig(HALL_TIMER);
   \   00000084   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000088   0x.... 0x....      BL       TIM_InternalClockConfig
    194              
    195              //Enables the XOR of channel 1, channel2 and channel3
    196              TIM_SelectHallSensor(HALL_TIMER, ENABLE);
   \   0000008C   0x2101             MOVS     R1,#+1
   \   0000008E   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000092   0x.... 0x....      BL       TIM_SelectHallSensor
    197              
    198              TIM_SelectInputTrigger(HALL_TIMER, TIM_TS_TI1FP1);
   \   00000096   0x2150             MOVS     R1,#+80
   \   00000098   0xF04F 0x4080      MOV      R0,#+1073741824
   \   0000009C   0x.... 0x....      BL       TIM_SelectInputTrigger
    199              TIM_SelectSlaveMode(HALL_TIMER,TIM_SlaveMode_Reset);
   \   000000A0   0x2104             MOVS     R1,#+4
   \   000000A2   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000A6   0x.... 0x....      BL       TIM_SelectSlaveMode
    200             
    201              // Source of Update event is only counter overflow/underflow
    202              TIM_UpdateRequestConfig(HALL_TIMER, TIM_UpdateSource_Regular);
   \   000000AA   0x2101             MOVS     R1,#+1
   \   000000AC   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000B0   0x.... 0x....      BL       TIM_UpdateRequestConfig
    203              
    204              /* Enable the HALL_TIMER IRQChannel*/
    205          #if defined(TIMER2_HANDLES_HALL)
    206              NVIC_InitHALLStructure.NVIC_IRQChannel = TIM2_IRQChannel;
   \   000000B4   0x201C             MOVS     R0,#+28
   \   000000B6   0xF88D 0x0000      STRB     R0,[SP, #+0]
    207          #elif defined(TIMER3_HANDLES_HALL)
    208              NVIC_InitHALLStructure.NVIC_IRQChannel = TIM3_IRQChannel;
    209          #else // TIMER4_HANDLES_HALL
    210              NVIC_InitHALLStructure.NVIC_IRQChannel = TIM4_IRQChannel;
    211          #endif
    212            
    213              NVIC_InitHALLStructure.NVIC_IRQChannelPreemptionPriority = 
    214                                                                TIMx_PRE_EMPTION_PRIORITY;
   \   000000BA   0x2002             MOVS     R0,#+2
   \   000000BC   0xF88D 0x0001      STRB     R0,[SP, #+1]
    215              NVIC_InitHALLStructure.NVIC_IRQChannelSubPriority = TIMx_SUB_PRIORITY;
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0xF88D 0x0002      STRB     R0,[SP, #+2]
    216              NVIC_InitHALLStructure.NVIC_IRQChannelCmd = ENABLE;
   \   000000C6   0x2001             MOVS     R0,#+1
   \   000000C8   0xF88D 0x0003      STRB     R0,[SP, #+3]
    217              
    218              NVIC_Init(&NVIC_InitHALLStructure);
   \   000000CC   0xA800             ADD      R0,SP,#+0
   \   000000CE   0x.... 0x....      BL       NVIC_Init
    219          
    220              // Clear the TIMx's pending flags
    221              TIM_ClearFlag(HALL_TIMER, TIM_FLAG_Update + TIM_FLAG_CC1 + TIM_FLAG_CC2 + \
    222                            TIM_FLAG_CC3 + TIM_FLAG_CC4 + TIM_FLAG_Trigger + TIM_FLAG_CC1OF + \
    223                            TIM_FLAG_CC2OF + TIM_FLAG_CC3OF + TIM_FLAG_CC4OF);
   \   000000D2   0xF641 0x615F      MOVW     R1,#+7775
   \   000000D6   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000DA   0x.... 0x....      BL       TIM_ClearFlag
    224            
    225              // Selected input capture and Update (overflow) events generate interrupt
    226              TIM_ITConfig(HALL_TIMER, TIM_IT_CC1, ENABLE);
   \   000000DE   0x2201             MOVS     R2,#+1
   \   000000E0   0x2102             MOVS     R1,#+2
   \   000000E2   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000E6   0x.... 0x....      BL       TIM_ITConfig
    227              TIM_ITConfig(HALL_TIMER, TIM_IT_Update, ENABLE);
   \   000000EA   0x2201             MOVS     R2,#+1
   \   000000EC   0x4611             MOV      R1,R2
   \   000000EE   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000F2   0x.... 0x....      BL       TIM_ITConfig
    228          
    229              TIM_SetCounter(HALL_TIMER, HALL_COUNTER_RESET);
   \   000000F6   0x2100             MOVS     R1,#+0
   \   000000F8   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000FC   0x.... 0x....      BL       TIM_SetCounter
    230                 TIM_Cmd(HALL_TIMER, ENABLE);
   \   00000100   0x2101             MOVS     R1,#+1
   \   00000102   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000106   0x.... 0x....      BL       TIM_Cmd
    231          }
   \   0000010A   0xB009             ADD      SP,SP,#+36
   \   0000010C   0xBD00             POP      {PC}             ;; return
    232          
    233          
    234          /*******************************************************************************
    235          * ROUTINE Name : HALL_InitHallMeasure
    236          *
    237          * Description : Clear software FIFO where are "pushed" latest speed information
    238          *           This function must be called before starting the motor to initialize
    239          *	    the speed measurement process.
    240          *
    241          * Input       : None
    242          * Output      : None
    243          * Return      : None
    244          * Note        : First measurements following this function call will be done
    245          *               without filtering (no rolling average).
    246          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    247          void HALL_InitHallMeasure( void )
    248          {
   \                     HALL_InitHallMeasure:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    249             // Mask interrupts to insure a clean intialization
    250          
    251             TIM_ITConfig(HALL_TIMER, TIM_IT_CC1, DISABLE);
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x2102             MOVS     R1,#+2
   \   00000006   0xF04F 0x4080      MOV      R0,#+1073741824
   \   0000000A   0x.... 0x....      BL       TIM_ITConfig
    252              
    253             RatioDec = FALSE;
   \   0000000E   0x....             LDR.N    R0,??DataTable14_1
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x7081             STRB     R1,[R0, #+2]
    254             RatioInc = FALSE;
   \   00000014   0x70C1             STRB     R1,[R0, #+3]
    255            // DoRollingAverage = FALSE;  
    256             DoRollingAverage = TRUE;
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x7101             STRB     R1,[R0, #+4]
    257          
    258             InitRollingAverage = FALSE;
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x7141             STRB     R1,[R0, #+5]
    259             HallTimeOut = FALSE;
   \   0000001E   0x7181             STRB     R1,[R0, #+6]
    260          
    261             hCaptCounter = 0;
   \   00000020   0x8101             STRH     R1,[R0, #+8]
    262             bGP1_OVF_Counter = 0;
   \   00000022   0x7041             STRB     R1,[R0, #+1]
    263          
    264             for (bSpeedFIFO_Index=0; bSpeedFIFO_Index < HALL_SPEED_FIFO_SIZE; 
   \   00000024   0x7001             STRB     R1,[R0, #+0]
   \   00000026   0xF44F 0x7148      MOV      R1,#+800
   \   0000002A   0x....             LDR.N    R2,??DataTable14_2
   \   0000002C   0xF64F 0x73FF      MOVW     R3,#+65535
   \   00000030   0xE014             B.N      ??HALL_InitHallMeasure_0
    265                                                                       bSpeedFIFO_Index++)
    266             {
    267                SensorPeriod[bSpeedFIFO_Index].hCapture = U16_MAX;
   \                     ??HALL_InitHallMeasure_1:
   \   00000032   0x7804             LDRB     R4,[R0, #+0]
   \   00000034   0xEB04 0x0544      ADD      R5,R4,R4, LSL #+1
   \   00000038   0x006C             LSLS     R4,R5,#+1
   \   0000003A   0x52A3             STRH     R3,[R4, R2]
    268                SensorPeriod[bSpeedFIFO_Index].hPrscReg = HALL_MAX_RATIO;
   \   0000003C   0x7804             LDRB     R4,[R0, #+0]
   \   0000003E   0xEB04 0x0544      ADD      R5,R4,R4, LSL #+1
   \   00000042   0xEB02 0x0445      ADD      R4,R2,R5, LSL #+1
   \   00000046   0x8061             STRH     R1,[R4, #+2]
    269                SensorPeriod[bSpeedFIFO_Index].bDirection = POSITIVE;
   \   00000048   0x7804             LDRB     R4,[R0, #+0]
   \   0000004A   0xEB04 0x0544      ADD      R5,R4,R4, LSL #+1
   \   0000004E   0xEB02 0x0445      ADD      R4,R2,R5, LSL #+1
   \   00000052   0x2501             MOVS     R5,#+1
   \   00000054   0x7125             STRB     R5,[R4, #+4]
    270             }
   \   00000056   0x7804             LDRB     R4,[R0, #+0]
   \   00000058   0x1C64             ADDS     R4,R4,#+1
   \   0000005A   0x7004             STRB     R4,[R0, #+0]
   \                     ??HALL_InitHallMeasure_0:
   \   0000005C   0x7804             LDRB     R4,[R0, #+0]
   \   0000005E   0x2C06             CMP      R4,#+6
   \   00000060   0xD3E7             BCC.N    ??HALL_InitHallMeasure_1
    271          
    272             // First measurement will be stored in the 1st array location
    273             bSpeedFIFO_Index = HALL_SPEED_FIFO_SIZE-1;
   \   00000062   0x2205             MOVS     R2,#+5
   \   00000064   0x7002             STRB     R2,[R0, #+0]
    274          
    275             // Re-initialize partly the timer
    276             HALL_TIMER->PSC = HALL_MAX_RATIO;
   \   00000066   0xF04F 0x4280      MOV      R2,#+1073741824
   \   0000006A   0x8511             STRH     R1,[R2, #+40]
    277             
    278             HALL_ClrCaptCounter();
   \   0000006C   0x2100             MOVS     R1,#+0
   \   0000006E   0x8101             STRH     R1,[R0, #+8]
    279               
    280             TIM_SetCounter(HALL_TIMER, HALL_COUNTER_RESET);
   \   00000070   0x4610             MOV      R0,R2
   \   00000072   0x.... 0x....      BL       TIM_SetCounter
    281             
    282             TIM_Cmd(HALL_TIMER, ENABLE);
   \   00000076   0x2101             MOVS     R1,#+1
   \   00000078   0xF04F 0x4080      MOV      R0,#+1073741824
   \   0000007C   0x.... 0x....      BL       TIM_Cmd
    283          
    284             TIM_ITConfig(HALL_TIMER, TIM_IT_CC1, ENABLE);
   \   00000080   0x2201             MOVS     R2,#+1
   \   00000082   0x2102             MOVS     R1,#+2
   \   00000084   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000088   0xE8BD 0x4038      POP      {R3-R5,LR}
   \   0000008C   0x.... 0x....      B.W      TIM_ITConfig
    285          
    286          }
    287          
    288          
    289          /*******************************************************************************
    290          * ROUTINE Name : HALL_GetSpeed
    291          *
    292          * Description : This routine returns Rotor frequency with [0.1Hz] definition.
    293          *		Result is given by the following formula:
    294          *		Frotor = K x (Fosc / (Capture x number of overflow)))
    295          *		where K depends on the number of motor poles pairs
    296          *
    297          * Input    : None
    298          * Output   : None
    299          * Returns  : Rotor mechanical frequency, with 0.1Hz resolution.
    300          * Comments : Result is zero if speed is too low (glitches at start for instance)
    301          *           Excessive speed (or high freq glitches will result in a pre-defined
    302          *           value returned.
    303          * Warning : Maximum expectable accuracy depends on CKTIM: 72MHz will give the
    304          * 	    best results.
    305          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    306          s16 HALL_GetSpeed ( void )
    307          { 
   \                     HALL_GetSpeed:
   \   00000000   0x....             LDR.N    R0,??DataTable14_1
   \   00000002   0xF9B0 0x000C      LDRSH    R0,[R0, #+12]
   \   00000006   0x....             LDR.N    R1,??DataTable14_3  ;; 0xffff8000
   \   00000008   0x4288             CMP      R0,R1
   \   0000000A   0xD102             BNE.N    ??HALL_GetSpeed_0
    308            s32 wAux;
    309            
    310            if( hRotorFreq_dpp == HALL_MAX_PSEUDO_SPEED)
    311            {
    312              return (HALL_MAX_SPEED);
   \   0000000C   0xF241 0x3088      MOVW     R0,#+5000
   \   00000010   0x4770             BX       LR
    313            }
    314            else
    315            {
    316              wAux = ((hRotorFreq_dpp* SAMPLING_FREQ * 10)/(65536*POLE_PAIR_NUM));
    317              return (s16)wAux;
   \                     ??HALL_GetSpeed_0:
   \   00000012   0x....             LDR.N    R1,??DataTable14_4  ;; 0x23280
   \   00000014   0x4348             MULS     R0,R1,R0
   \   00000016   0x1401             ASRS     R1,R0,#+16
   \   00000018   0xEB00 0x30D1      ADD      R0,R0,R1, LSR #+15
   \   0000001C   0x1440             ASRS     R0,R0,#+17
   \   0000001E   0x4770             BX       LR               ;; return
    318            }
    319          }
    320          
    321          /*******************************************************************************
    322          * ROUTINE Name : Hall_GetRotorFreq
    323          *
    324          * Description : This routine returns Rotor frequency with an unit that can be
    325          *               directly integrated to get the speed in the field oriented
    326          *               control loop.
    327          *
    328          * Input    : None
    329          * Output   : None
    330          * Returns  : Rotor mechanical frequency with rad/PWM period unit
    331          *             (here 2*PI rad = 0xFFFF).
    332          * Comments : Result is zero if speed is too low (glitches at start for instance)
    333          *           Excessive speed (or high freq glitches will result in a pre-defined
    334          *           value returned.
    335          * Warning : Maximum expectable accuracy depends on CKTIM: 72MHz will give the
    336          * 	    best results.
    337          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    338          s16 HALL_GetRotorFreq ( void )
    339          {
   \                     HALL_GetRotorFreq:
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    340             PeriodMeas_s PeriodMeasAux;
    341          
    342             if ( DoRollingAverage)
   \   00000002   0x....             LDR.N    R4,??DataTable14_1
   \   00000004   0x7920             LDRB     R0,[R4, #+4]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xA800             ADD      R0,SP,#+0
   \   0000000A   0xD002             BEQ.N    ??HALL_GetRotorFreq_0
    343             {
    344                PeriodMeasAux = GetAvrgHallPeriod();
   \   0000000C   0x.... 0x....      BL       GetAvrgHallPeriod
   \   00000010   0xE001             B.N      ??HALL_GetRotorFreq_1
    345             }
    346             else
    347             {  // Raw period
    348                PeriodMeasAux = GetLastHallPeriod();
   \                     ??HALL_GetRotorFreq_0:
   \   00000012   0x.... 0x....      BL       GetLastHallPeriod
    349             }
    350          
    351             if (HallTimeOut == TRUE)
   \                     ??HALL_GetRotorFreq_1:
   \   00000016   0x79A0             LDRB     R0,[R4, #+6]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xBF08             IT       EQ 
   \   0000001C   0x2000             MOVEQ    R0,#+0
    352             {
    353                hRotorFreq_dpp = 0;
   \   0000001E   0xD020             BEQ.N    ??HALL_GetRotorFreq_2
    354             }
    355             else
    356             {
    357               if(PeriodMeasAux.bDirection != ERROR)
   \   00000020   0xF99D 0x0004      LDRSB    R0,[SP, #+4]
   \   00000024   0x287F             CMP      R0,#+127
   \   00000026   0xD01D             BEQ.N    ??HALL_GetRotorFreq_3
    358               //No errors have been detected during rotor speed information extrapolation          
    359               {
    360                  if ( HALL_TIMER->PSC >= HALL_MAX_RATIO )/* At start-up or very low freq */
   \   00000028   0x....             LDR.N    R1,??DataTable14_5  ;; 0x40000028
   \   0000002A   0x8809             LDRH     R1,[R1, #+0]
   \   0000002C   0xF5B1 0x7F48      CMP      R1,#+800
   \   00000030   0xBF28             IT       CS 
   \   00000032   0x2000             MOVCS    R0,#+0
    361                  {                           /* Based on current prescaler value only */
    362                     hRotorFreq_dpp = 0;
   \   00000034   0xD215             BCS.N    ??HALL_GetRotorFreq_2
    363                  }
    364                  else
    365                  {
    366                     if( PeriodMeasAux.wPeriod > MAX_PERIOD) /* Speed is too low */
   \   00000036   0x9900             LDR      R1,[SP, #+0]
   \   00000038   0x....             LDR.N    R2,??DataTable14_6  ;; 0xb71b01
   \   0000003A   0x4291             CMP      R1,R2
   \   0000003C   0xBF28             IT       CS 
   \   0000003E   0x2000             MOVCS    R0,#+0
    367                     {
    368                        hRotorFreq_dpp = 0;
   \   00000040   0xD20F             BCS.N    ??HALL_GetRotorFreq_2
    369                     }
    370                     else
    371                     {  /*Avoid u32 DIV Overflow*/
    372                        if ( PeriodMeasAux.wPeriod > (u32)SPEED_OVERFLOW )
   \   00000042   0xF645 0x52C1      MOVW     R2,#+24001
   \   00000046   0x4291             CMP      R1,R2
   \   00000048   0xD30A             BCC.N    ??HALL_GetRotorFreq_4
    373                        {
    374                          if (HALL_GetCaptCounter()<2)// First capture must be discarded
   \   0000004A   0x8921             LDRH     R1,[R4, #+8]
   \   0000004C   0x2902             CMP      R1,#+2
   \   0000004E   0xBF38             IT       CC 
   \   00000050   0x2000             MOVCC    R0,#+0
    375                          {
    376                            hRotorFreq_dpp=0;
   \   00000052   0xD306             BCC.N    ??HALL_GetRotorFreq_2
    377                          }
    378                          else                  
    379                          {
    380                             hRotorFreq_dpp = (s16)((u16) (PSEUDO_FREQ_CONV /
    381                                                                    PeriodMeasAux.wPeriod));
    382                             hRotorFreq_dpp *= PeriodMeasAux.bDirection;               
   \   00000054   0x....             LDR.N    R1,??DataTable14_7  ;; 0x6820000
   \   00000056   0x9A00             LDR      R2,[SP, #+0]
   \   00000058   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   0000005C   0x4348             MULS     R0,R0,R1
   \   0000005E   0xE000             B.N      ??HALL_GetRotorFreq_2
    383                          }
    384                        }
    385                        else
    386                        {
    387                          hRotorFreq_dpp = HALL_MAX_PSEUDO_SPEED;
   \                     ??HALL_GetRotorFreq_4:
   \   00000060   0x....             LDR.N    R0,??DataTable14_3  ;; 0xffff8000
   \                     ??HALL_GetRotorFreq_2:
   \   00000062   0x81A0             STRH     R0,[R4, #+12]
    388                        }
    389                     }
    390                  }
    391               }          
    392             }
    393          
    394             return (hRotorFreq_dpp);
   \                     ??HALL_GetRotorFreq_3:
   \   00000064   0xF9B4 0x000C      LDRSH    R0,[R4, #+12]
   \   00000068   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    395          }
    396          
    397          
    398          /*******************************************************************************
    399          * ROUTINE Name : HALL_ClrTimeOut
    400          *
    401          * Description     : Clears the flag indicating that that informations are lost,
    402          *                   or speed is decreasing sharply.
    403          * Input           : None
    404          * Output          : Clear HallTimeOut
    405          * Return          : None
    406          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    407          void HALL_ClrTimeOut(void)
    408          {
    409             HallTimeOut = FALSE;
   \                     HALL_ClrTimeOut:
   \   00000000   0x....             LDR.N    R0,??DataTable14_1
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x7181             STRB     R1,[R0, #+6]
    410          }
   \   00000006   0x4770             BX       LR               ;; return
    411          
    412          
    413          /*******************************************************************************
    414          * ROUTINE Name : HALL_IsTimedOut
    415          *
    416          * Description     : This routine indicates to the upper layer SW that Hall 
    417          *                   sensors information disappeared or timed out.
    418          * Input           : None
    419          * Output          : None
    420          * Return          : boolean, TRUE in case of Time Out
    421          * Note            : The time-out duration depends on timer pre-scaler,
    422          *                   which is variable; the time-out will be higher at low speed.
    423          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    424          bool HALL_IsTimedOut(void)
    425          {
    426             return(HallTimeOut);
   \                     HALL_IsTimedOut:
   \   00000000   0x....             LDR.N    R0,??DataTable14_1
   \   00000002   0x7980             LDRB     R0,[R0, #+6]
   \   00000004   0x4770             BX       LR               ;; return
    427          }
    428          
    429          
    430          /*******************************************************************************
    431          * ROUTINE Name : Hall_GetCaptCounter
    432          *
    433          * Description     : Gives the number of Hall sensors capture interrupts since last call
    434          *                   of the HALL_ClrCaptCounter function.
    435          * Input           : None
    436          * Output          : None
    437          * Return          : u16 integer (Roll-over is prevented in the input capture
    438          *                   routine itself).
    439          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    440          u16 HALL_GetCaptCounter(void)
    441          {
    442             return(hCaptCounter);
   \                     HALL_GetCaptCounter:
   \   00000000   0x....             LDR.N    R0,??DataTable14_1
   \   00000002   0x8900             LDRH     R0,[R0, #+8]
   \   00000004   0x4770             BX       LR               ;; return
    443          }
    444          
    445          
    446          /*******************************************************************************
    447          * ROUTINE Name : HALL_ClrCaptCounter
    448          *
    449          * Description     : Clears the variable holding the number of capture events.
    450          * Input           : None
    451          * Output          : hCaptCounter is cleared.
    452          * Return          : None
    453          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    454          void HALL_ClrCaptCounter(void)
    455          {
    456             hCaptCounter = 0;
   \                     HALL_ClrCaptCounter:
   \   00000000   0x....             LDR.N    R0,??DataTable14_1
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x8101             STRH     R1,[R0, #+8]
    457          }
   \   00000006   0x4770             BX       LR               ;; return
    458          
    459          
    460          /*******************************************************************************
    461          * ROUTINE Name : GetLastHallPeriod
    462          *
    463          * Description     : returns the rotor pseudo-period based on last capture
    464          * Input           : None
    465          * Output          : None
    466          * Return          : rotor pseudo-period, as a number of CKTIM periods
    467          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    468          PeriodMeas_s GetLastHallPeriod(void)
    469          {
   \                     GetLastHallPeriod:
   \   00000000   0xB082             SUB      SP,SP,#+8
    470                PeriodMeas_s PeriodMeasAux;
    471                u8 bLastSpeedFIFO_Index;
    472          
    473             // Store current index to prevent errors if Capture occurs during processing
    474             bLastSpeedFIFO_Index = bSpeedFIFO_Index;
   \   00000002   0x....             LDR.N    R1,??DataTable14_1
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
    475          
    476             // This is done assuming interval between captures is higher than time
    477             // to read the two values
    478             PeriodMeasAux.wPeriod = SensorPeriod[bLastSpeedFIFO_Index].hCapture;
   \   00000006   0xEB01 0x0241      ADD      R2,R1,R1, LSL #+1
   \   0000000A   0x0051             LSLS     R1,R2,#+1
   \   0000000C   0x....             LDR.N    R2,??DataTable14_2
   \   0000000E   0x5A8B             LDRH     R3,[R1, R2]
    479             PeriodMeasAux.wPeriod *= (SensorPeriod[bLastSpeedFIFO_Index].hPrscReg + 1);
   \   00000010   0x1889             ADDS     R1,R1,R2
   \   00000012   0x884A             LDRH     R2,[R1, #+2]
   \   00000014   0x1C52             ADDS     R2,R2,#+1
   \   00000016   0x435A             MULS     R2,R2,R3
   \   00000018   0x9200             STR      R2,[SP, #+0]
    480             
    481             PeriodMeasAux.bDirection = SensorPeriod[bLastSpeedFIFO_Index].bDirection;
   \   0000001A   0x7909             LDRB     R1,[R1, #+4]
   \   0000001C   0xF88D 0x1004      STRB     R1,[SP, #+4]
    482             return (PeriodMeasAux);
   \   00000020   0xE9DD 0x2300      LDRD     R2,R3,[SP, #+0]
   \   00000024   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
   \   00000028   0xB002             ADD      SP,SP,#+8
   \   0000002A   0x4770             BX       LR               ;; return
    483          }
    484          
    485          
    486          /*******************************************************************************
    487          * ROUTINE Name : GetAvrgHallPeriod
    488          *
    489          * Description    : returns the rotor pseudo-period based on 4 last captures
    490          * Input          : None
    491          * Output         : None
    492          * Return         : averaged rotor pseudo-period, as a number of CKTIM periods
    493          * Side effect: the very last period acquired may not be considered for the
    494          * calculation if a capture occurs during averaging.
    495          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    496          PeriodMeas_s GetAvrgHallPeriod(void)
    497          {
   \                     GetAvrgHallPeriod:
   \   00000000   0xB4FC             PUSH     {R2-R7}
    498              u32 wFreqBuffer, wAvrgBuffer, wIndex;
    499              PeriodMeas_s PeriodMeasAux;
    500          
    501            wAvrgBuffer = 0;
   \   00000002   0x2400             MOVS     R4,#+0
    502          
    503            for ( wIndex = 0; wIndex < HALL_SPEED_FIFO_SIZE; wIndex++ )
   \   00000004   0x....             LDR.N    R1,??DataTable14_2
   \   00000006   0x2206             MOVS     R2,#+6
   \   00000008   0x....             LDR.N    R3,??DataTable14_8  ;; 0x4000000c
    504            {
    505               // Disable capture interrupts to have presc and capture of the same period
    506               HALL_TIMER->DIER &= ~TIM_IT_CC1; // NB:Std libray not used for perf issues
   \                     ??GetAvrgHallPeriod_0:
   \   0000000A   0x881D             LDRH     R5,[R3, #+0]
   \   0000000C   0xF64F 0x76FD      MOVW     R6,#+65533
   \   00000010   0x4035             ANDS     R5,R6,R5
   \   00000012   0x801D             STRH     R5,[R3, #+0]
    507               
    508               wFreqBuffer = SensorPeriod[wIndex].hCapture;
   \   00000014   0xF831 0x5B02      LDRH     R5,[R1], #+2
    509               wFreqBuffer *= (SensorPeriod[wIndex].hPrscReg + 1);
   \   00000018   0xF831 0x6B02      LDRH     R6,[R1], #+2
    510               
    511               HALL_TIMER->DIER |= TIM_IT_CC1;   // NB:Std libray not used for perf issue
   \   0000001C   0x881F             LDRH     R7,[R3, #+0]
   \   0000001E   0xF047 0x0702      ORR      R7,R7,#0x2
   \   00000022   0x801F             STRH     R7,[R3, #+0]
    512               wAvrgBuffer += wFreqBuffer;	// Sum the whole periods FIFO
   \   00000024   0x1C76             ADDS     R6,R6,#+1
   \   00000026   0xFB06 0x4405      MLA      R4,R6,R5,R4
    513               PeriodMeasAux.bDirection = SensorPeriod[wIndex].bDirection;
   \   0000002A   0xF911 0x5B02      LDRSB    R5,[R1], #+2
   \   0000002E   0xF88D 0x5004      STRB     R5,[SP, #+4]
    514            }
   \   00000032   0x1E52             SUBS     R2,R2,#+1
   \   00000034   0xD1E9             BNE.N    ??GetAvrgHallPeriod_0
    515            // Round to upper value
    516            wAvrgBuffer = (u32)(wAvrgBuffer + (HALL_SPEED_FIFO_SIZE/2)-1);  
    517            wAvrgBuffer /= HALL_SPEED_FIFO_SIZE;        // Average value	
    518          
    519            PeriodMeasAux.wPeriod = wAvrgBuffer;
   \   00000036   0x1CA1             ADDS     R1,R4,#+2
   \   00000038   0x2206             MOVS     R2,#+6
   \   0000003A   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   0000003E   0x9100             STR      R1,[SP, #+0]
    520            
    521            return (PeriodMeasAux);
   \   00000040   0xE9DD 0x2300      LDRD     R2,R3,[SP, #+0]
   \   00000044   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
   \   00000048   0xBCF6             POP      {R1,R2,R4-R7}
   \   0000004A   0x4770             BX       LR               ;; return
    522          }
    523          
    524          
    525          /*******************************************************************************
    526          * ROUTINE Name : HALL_StartHallFiltering
    527          *
    528          * Description : Set the flags to initiate hall speed values smoothing mechanism.
    529          * Input       : None
    530          * Output      : The result of the next capture will be copied in the whole array
    531          *               to have 1st average = last value.
    532          * Return      : None
    533          * Note: The initialization of the FIFO used to do the averaging will be done
    534          *       when the next input capture interrupt will occur.
    535          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    536          void HALL_StartHallFiltering( void )
    537          {
    538             InitRollingAverage = TRUE;
   \                     HALL_StartHallFiltering:
   \   00000000   0x....             LDR.N    R0,??DataTable14_1
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x7141             STRB     R1,[R0, #+5]
    539          }
   \   00000006   0x4770             BX       LR               ;; return
    540          
    541          /*******************************************************************************
    542          * ROUTINE Name : HALL_ReadHallState
    543          *
    544          * Description : Read the GPIO Input used for Hall sensor IC and return the state  
    545          * Input       : None
    546          * Output      : None
    547          * Return      : STATE_X
    548          *
    549          *******************************************************************************/
    550          

   \                                 In section .text, align 2, keep-with-next
    551          u8 ReadHallState(void)
    552          {
   \                     ReadHallState:
   \   00000000   0xB580             PUSH     {R7,LR}
    553            u8 ReadValue;
    554          #if defined(TIMER2_HANDLES_HALL)  
    555          
    556             ReadValue= (u8)(GPIO_ReadInputData(GPIOA));
    557            
    558             ReadValue = ReadValue & GPIO_MSK;
    559            
    560          #elif defined(TIMER3_HANDLES_HALL)
    561            
    562            ReadValue = GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_0)<<2;
    563            ReadValue |= GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_6)<<1;
    564            ReadValue |= GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_7);
    565          
    566          #elif defined(TIMER4_HANDLES_HALL)
    567            ReadValue = ((u8)(GPIO_ReadInputData(GPIOA))>>6) & GPIO_MSK;
    568          #endif
    569            
    570            return(ReadValue);
   \   00000002   0x....             LDR.N    R0,??DataTable14  ;; 0x40010800
   \   00000004   0x.... 0x....      BL       GPIO_ReadInputData
   \   00000008   0xF000 0x0007      AND      R0,R0,#0x7
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
    571          }
    572          
    573          /*******************************************************************************
    574          * ROUTINE Name : HALL_GetElectricalAngle
    575          *
    576          * Description : Export the variable containing the latest angle updated by IC 
    577          *               interrupt
    578          * Input       : None
    579          * Output      : None
    580          * Return      : Electrical angle s16 format
    581          *
    582          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    583          s16 HALL_GetElectricalAngle(void)
    584          {
    585            return(hElectrical_Angle);
   \                     HALL_GetElectricalAngle:
   \   00000000   0x....             LDR.N    R0,??DataTable14_1
   \   00000002   0xF9B0 0x000A      LDRSH    R0,[R0, #+10]
   \   00000006   0x4770             BX       LR               ;; return
    586          }
    587          
    588          /*******************************************************************************
    589          * ROUTINE Name : HALL_IncElectricalAngle
    590          *
    591          * Description : Increment the variable containing the rotor position information.
    592          *               This function is called at each FOC cycle for integrating 
    593          *               the speed information
    594          * Input       : None
    595          * Output      : None
    596          * Return      : Electrical angle s16 format
    597          *
    598          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    599          void HALL_IncElectricalAngle(void)
    600          { 
    601            static s16 hPrevRotorFreq;
    602           
    603            if (hRotorFreq_dpp != HALL_MAX_PSEUDO_SPEED)
   \                     HALL_IncElectricalAngle:
   \   00000000   0x....             LDR.N    R0,??DataTable14_1
   \   00000002   0xF9B0 0x100A      LDRSH    R1,[R0, #+10]
   \   00000006   0xF9B0 0x200C      LDRSH    R2,[R0, #+12]
   \   0000000A   0x....             LDR.N    R3,??DataTable14_3  ;; 0xffff8000
   \   0000000C   0x429A             CMP      R2,R3
   \   0000000E   0xBF19             ITTEE    NE 
   \   00000010   0x1851             ADDNE    R1,R2,R1
   \   00000012   0x81C2             STRHNE   R2,[R0, #+14]
   \   00000014   0x89C2             LDRHEQ   R2,[R0, #+14]
   \   00000016   0x1851             ADDEQ    R1,R2,R1
    604            {
    605              hElectrical_Angle += hRotorFreq_dpp;
    606              hPrevRotorFreq = hRotorFreq_dpp;
    607            }
    608            else
    609            {
    610              hElectrical_Angle += hPrevRotorFreq;
   \   00000018   0x8141             STRH     R1,[R0, #+10]
    611            }
    612          }
   \   0000001A   0x4770             BX       LR               ;; return

   \                                 In section .bss, align 2
   \                     bSpeedFIFO_Index:
   \   00000000                      DS8 1
   \                     bGP1_OVF_Counter:
   \   00000001                      DS8 1
   \                     RatioDec:
   \   00000002                      DS8 1
   \                     RatioInc:
   \   00000003                      DS8 1
   \                     DoRollingAverage:
   \   00000004                      DS8 1
   \                     InitRollingAverage:
   \   00000005                      DS8 1
   \                     HallTimeOut:
   \   00000006                      DS8 1
   \   00000007                      DS8 1
   \                     hCaptCounter:
   \   00000008                      DS8 2
   \   0000000A                      DS8 2
   \   0000000C                      DS8 2
   \   0000000E                      DS8 2

   \                                 In section .bss, align 4
   \                     PeriodMeas:
   \   00000000                      DS8 8
    613          
    614          /*******************************************************************************
    615          * ROUTINE Name : HALL_Init_Electrical_Angle
    616          *
    617          * Description : Read the logic level of the three Hall sensor and individuates   
    618          *               this way the position of the rotor (+/- 30). Electrical angle 
    619          *               variable is then initialized
    620          *
    621          * Input       : None
    622          * Output      : None
    623          * Return      : Electrical angle s16 format
    624          *
    625          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    626          void HALL_Init_Electrical_Angle(void)
    627          {
   \                     HALL_Init_Electrical_Angle:
   \   00000000   0xB580             PUSH     {R7,LR}
    628          #if (HALL_SENSORS_PLACEMENT == DEGREES_120) 
    629           switch(ReadHallState())
   \   00000002   0x....             LDR.N    R0,??DataTable14  ;; 0x40010800
   \   00000004   0x.... 0x....      BL       GPIO_ReadInputData
   \   00000008   0xF000 0x0007      AND      R0,R0,#0x7
   \   0000000C   0x1E40             SUBS     R0,R0,#+1
   \   0000000E   0x2805             CMP      R0,#+5
   \   00000010   0xD819             BHI.N    ??HALL_Init_Electrical_Angle_1
   \   00000012   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??HALL_Init_Electrical_Angle_0:
   \   00000016   0x06 0x0E          DC8      0x6,0xE,0xA,0x15
   \              0x0A 0x15    
   \   0000001A   0x03 0x12          DC8      0x3,0x12
    630           {
    631            case STATE_5:
    632              hElectrical_Angle = (s16)(S16_PHASE_SHIFT+S16_60_PHASE_SHIFT/2);
   \                     ??HALL_Init_Electrical_Angle_2:
   \   0000001C   0x....             LDR.N    R0,??DataTable14_1
   \   0000001E   0x....             LDR.N    R1,??DataTable14_9  ;; 0xffffeaaa
   \   00000020   0xE010             B.N      ??HALL_Init_Electrical_Angle_3
    633              break;
    634            case STATE_1:
    635              hElectrical_Angle =(s16)(S16_PHASE_SHIFT+S16_60_PHASE_SHIFT+
    636                                                                    S16_60_PHASE_SHIFT/2);
   \                     ??HALL_Init_Electrical_Angle_4:
   \   00000022   0x....             LDR.N    R0,??DataTable14_1
   \   00000024   0xF241 0x5154      MOVW     R1,#+5460
   \   00000028   0xE00C             B.N      ??HALL_Init_Electrical_Angle_3
    637              break;
    638            case STATE_3:
    639              hElectrical_Angle =(s16)(S16_PHASE_SHIFT+S16_120_PHASE_SHIFT+
    640                                                                    S16_60_PHASE_SHIFT/2);      
   \                     ??HALL_Init_Electrical_Angle_5:
   \   0000002A   0x....             LDR.N    R0,??DataTable14_1
   \   0000002C   0xF643 0x71FF      MOVW     R1,#+16383
   \   00000030   0xE008             B.N      ??HALL_Init_Electrical_Angle_3
    641              break;
    642            case STATE_2:
    643              hElectrical_Angle =(s16)(S16_PHASE_SHIFT-S16_120_PHASE_SHIFT-
    644                                                                    S16_60_PHASE_SHIFT/2);      
   \                     ??HALL_Init_Electrical_Angle_6:
   \   00000032   0x....             LDR.N    R0,??DataTable14_1
   \   00000034   0xF646 0x21AB      MOVW     R1,#+27307
   \   00000038   0xE004             B.N      ??HALL_Init_Electrical_Angle_3
    645              break;
    646            case STATE_6:
    647              hElectrical_Angle =(s16)(S16_PHASE_SHIFT-S16_60_PHASE_SHIFT-
    648                                                                    S16_60_PHASE_SHIFT/2);          
   \                     ??HALL_Init_Electrical_Angle_7:
   \   0000003A   0x....             LDR.N    R0,??DataTable14_1
   \   0000003C   0x....             LDR.N    R1,??DataTable14_10  ;; 0xffff9556
   \   0000003E   0xE001             B.N      ??HALL_Init_Electrical_Angle_3
    649              break;
    650            case STATE_4:
    651              hElectrical_Angle =(s16)(S16_PHASE_SHIFT-S16_60_PHASE_SHIFT/2);          
   \                     ??HALL_Init_Electrical_Angle_8:
   \   00000040   0x....             LDR.N    R0,??DataTable14_1
   \   00000042   0x....             LDR.N    R1,??DataTable14_11  ;; 0xffffc000
   \                     ??HALL_Init_Electrical_Angle_3:
   \   00000044   0x8141             STRH     R1,[R0, #+10]
    652              break;    
    653            default:    
    654              break;
    655            }
    656          #elif (HALL_SENSORS_PLACEMENT == DEGREES_60)
    657           switch(ReadHallState())
    658           {  
    659            case STATE_1:
    660              hElectrical_Angle =(s16)(S16_PHASE_SHIFT+S16_60_PHASE_SHIFT/2);
    661              break;
    662            case STATE_3:
    663              hElectrical_Angle =(s16)(S16_PHASE_SHIFT+S16_60_PHASE_SHIFT+
    664                                                                    S16_60_PHASE_SHIFT/2);
    665              break;
    666            case STATE_7:
    667              hElectrical_Angle =(s16)(S16_PHASE_SHIFT+S16_120_PHASE_SHIFT+
    668                                                                    S16_60_PHASE_SHIFT/2);      
    669              break;
    670            case STATE_6:
    671              hElectrical_Angle =(s16)(S16_PHASE_SHIFT-S16_120_PHASE_SHIFT-
    672                                                                    S16_60_PHASE_SHIFT/2);      
    673              break;
    674            case STATE_4:
    675              hElectrical_Angle =(s16)(S16_PHASE_SHIFT-S16_60_PHASE_SHIFT-
    676                                                                    S16_60_PHASE_SHIFT/2);          
    677              break;
    678            case STATE_0:
    679              hElectrical_Angle =(s16)(S16_PHASE_SHIFT-S16_60_PHASE_SHIFT/2);          
    680              break;    
    681            default:    
    682              break;
    683            }
    684          #endif
    685          }
   \                     ??HALL_Init_Electrical_Angle_1:
   \   00000046   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x........         DC32     bSpeedFIFO_Index

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x........         DC32     SensorPeriod

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0xFFFF8000         DC32     0xffff8000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \   00000000   0x00023280         DC32     0x23280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \   00000000   0x40000028         DC32     0x40000028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \   00000000   0x00B71B01         DC32     0xb71b01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \   00000000   0x06820000         DC32     0x6820000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_8:
   \   00000000   0x4000000C         DC32     0x4000000c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_9:
   \   00000000   0xFFFFEAAA         DC32     0xffffeaaa

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_10:
   \   00000000   0xFFFF9556         DC32     0xffff9556

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_11:
   \   00000000   0xFFFFC000         DC32     0xffffc000
    686          
    687          /*******************************************************************************
    688          * Function Name  : TIMx_IRQHandler
    689          * Description    : This function handles both the capture event and Update event 
    690          *                  interrupt handling the hall sensors signal period measurement
    691          *                  
    692          *                  - On 'CAPTURE' event case:
    693          *                    The spinning direction is extracted
    694          *                    The electrical angle is updated (synchronized)
    695          *                    If the average is initialized, the last captured measure is
    696          *                    copied into the whole array.
    697          *                    Period captures are managed as following:
    698          *                    If too low, the clock prescaler is decreased for next measure
    699          *                    If too high (ie there was overflows), the result is
    700          *                    re-computed as if there was no overflow and the prescaler is
    701          *                    increased to avoid overflows during the next capture
    702          *                   
    703          *                  - On 'UPDATE' event case:
    704          *                    This function handles the overflow of the timer handling
    705          *                    the hall sensors signal period measurement.
    706          * Input          : 
    707          *                  - On 'CAPTURE' event case:
    708          *                    None
    709          *                   
    710          *                  - On 'UPDATE' event case: 
    711          *                    None
    712          *
    713          * Output         : 
    714          *                  - On 'CAPTURE' event case:
    715          *                   Updates the array holding the 4 latest period measures, reset
    716          *                   the overflow counter and update the clock prescaler to
    717          *                   optimize the accuracy of the measurement.
    718          *                   
    719          *                  - On 'UPDATE' event case:
    720          *                    Updates a Counter of overflows, handled and reset when next
    721          *                    capture occurs. 
    722          *
    723          * Return         : None (Interrupt Service routine)
    724          *******************************************************************************/
    725          #if (defined HALL_SENSORS || defined VIEW_HALL_FEEDBACK)
    726          #if defined(TIMER2_HANDLES_HALL)
    727          void TIM2_IRQHandler(void)
    728          #elif defined(TIMER3_HANDLES_HALL)
    729          void TIM3_IRQHandler(void)
    730          #else // TIMER4_HANDLES_HALL
    731          void TIM4_IRQHandler(void)
    732          #endif
    733          
    734          {
    735            static u8  bHallState; 
    736            u8 bPrevHallState;
    737          
    738          // Check for the source of TIMx int - Capture or Update Event - 
    739            if ( TIM_GetFlagStatus(HALL_TIMER, TIM_FLAG_Update) == RESET )
    740            {
    741              // A capture event generated this interrupt
    742              bPrevHallState = bHallState;
    743              bHallState = ReadHallState();
    744          #if (HALL_SENSORS_PLACEMENT == DEGREES_120)    
    745              switch(bHallState)
    746              {
    747                case STATE_5:
    748                  if (bPrevHallState == STATE_5)
    749                  {
    750          	 //a speed reversal occured 
    751                   if(bSpeed<0)
    752                   {
    753                     bSpeed = POSITIVE_SWAP;
    754                   }
    755                   else
    756                   {
    757                     bSpeed = NEGATIVE_SWAP;
    758                   }
    759                  }
    760                  else   
    761                    if (bPrevHallState == STATE_6)
    762                    {
    763                     bSpeed = POSITIVE;
    764                    }
    765                    else 
    766                      if (bPrevHallState == STATE_3)
    767                      {
    768                        bSpeed = NEGATIVE;
    769                      }
    770          		// Update angle
    771                  if(bSpeed<0)
    772                  {
    773                    hElectrical_Angle = (s16)(S16_PHASE_SHIFT+S16_60_PHASE_SHIFT);
    774                  }
    775                  else if(bSpeed!= ERROR)
    776                  {
    777                    hElectrical_Angle = S16_PHASE_SHIFT;  
    778                  }
    779                  break;
    780                       
    781              case STATE_3:
    782                  if (bPrevHallState == STATE_3)
    783                  {
    784          		 //a speed reversal occured
    785                   if(bSpeed<0)
    786                   {
    787                     bSpeed = POSITIVE_SWAP;
    788                   }
    789                   else
    790                   {
    791                     bSpeed = NEGATIVE_SWAP;
    792                   }
    793                  }
    794                  else
    795                    if (bPrevHallState == STATE_5)
    796                    {
    797                     bSpeed = POSITIVE;
    798                    }
    799                    else 
    800                      if (bPrevHallState == STATE_6)
    801                      {
    802                        bSpeed = NEGATIVE;
    803                      }
    804          		// Update of the electrical angle
    805                  if(bSpeed<0)
    806                  {
    807                    hElectrical_Angle = (s16)(S16_PHASE_SHIFT+S16_120_PHASE_SHIFT+
    808                                                                      S16_60_PHASE_SHIFT);
    809                  }
    810                  else if(bSpeed!= ERROR)
    811                  {
    812                    hElectrical_Angle =(s16)(S16_PHASE_SHIFT + S16_120_PHASE_SHIFT);
    813                  }
    814                  break;  
    815                
    816                case STATE_6: 
    817                  if (bPrevHallState == STATE_6)
    818                  {
    819                   if(bSpeed<0)
    820                   {
    821                     bSpeed = POSITIVE_SWAP;
    822                   }
    823                   else
    824                   {
    825                     bSpeed = NEGATIVE_SWAP;
    826                   }
    827                  }
    828                  
    829                  if (bPrevHallState == STATE_3)
    830                  {
    831                   bSpeed = POSITIVE; 
    832                  }
    833                  else 
    834                    if (bPrevHallState == STATE_5)
    835                    {
    836                      bSpeed = NEGATIVE;
    837                    }  
    838                  if(bSpeed<0)
    839                  {
    840                    hElectrical_Angle =(s16)(S16_PHASE_SHIFT - S16_60_PHASE_SHIFT);  
    841                  }
    842                  else if(bSpeed!= ERROR)
    843                  {
    844                    hElectrical_Angle =(s16)(S16_PHASE_SHIFT - S16_120_PHASE_SHIFT); 
    845                  }
    846                  break;
    847                  
    848                default:
    849                  bSpeed = ERROR;
    850                  break;
    851              }
    852          #elif (HALL_SENSORS_PLACEMENT == DEGREES_60)    
    853              switch(bHallState)
    854              {
    855                case STATE_3:
    856                  if (bPrevHallState == STATE_3)
    857                  {
    858                   if(bSpeed<0)
    859                   {
    860                     bSpeed = POSITIVE_SWAP;
    861                   }
    862                   else
    863                   {
    864                     bSpeed = NEGATIVE_SWAP;
    865                   }
    866                  }
    867                  else          
    868                    if (bPrevHallState == STATE_0)
    869                    {
    870                     bSpeed = POSITIVE;
    871                    }
    872                    else 
    873                      if (bPrevHallState == STATE_6)
    874                      {
    875                        bSpeed = NEGATIVE;              
    876                      }
    877                  if(bSpeed<0)
    878                  {
    879                    hElectrical_Angle = (s16)(S16_PHASE_SHIFT+S16_120_PHASE_SHIFT);
    880                  }
    881                  else if(bSpeed!= ERROR)
    882                  {
    883                    hElectrical_Angle = (s16)(S16_PHASE_SHIFT+S16_60_PHASE_SHIFT);
    884                  }
    885                  break;
    886                       
    887                case STATE_6:
    888                  if (bPrevHallState == STATE_6)
    889                  {
    890                   if(bSpeed<0)
    891                   {
    892                     bSpeed = POSITIVE_SWAP;
    893                   }
    894                   else
    895                   {
    896                     bSpeed = NEGATIVE_SWAP;
    897                   }
    898                  } 
    899                  else
    900                    if (bPrevHallState == STATE_3)
    901                    {
    902                     bSpeed = POSITIVE;           
    903                    }
    904                    else 
    905                      if (bPrevHallState == STATE_0)
    906                      {
    907                        bSpeed = NEGATIVE;
    908                      }
    909                  if(bSpeed<0)
    910                  {
    911                    hElectrical_Angle = (s16)(S16_PHASE_SHIFT-S16_120_PHASE_SHIFT);
    912                  }
    913                  else if(bSpeed!= ERROR)
    914                  {
    915                    hElectrical_Angle =(s16)(S16_PHASE_SHIFT + S16_120_PHASE_SHIFT+
    916                                                                      S16_60_PHASE_SHIFT);
    917                  }
    918                  break;  
    919                
    920                case STATE_0:
    921                  if (bPrevHallState == STATE_0)
    922                  {
    923                   if(bSpeed<0)
    924                   {
    925                     bSpeed = POSITIVE_SWAP;
    926                   }
    927                   else
    928                   {
    929                     bSpeed = NEGATIVE_SWAP;
    930                   }
    931                  } 
    932                  else
    933                    if (bPrevHallState == STATE_6)
    934                    {
    935                     bSpeed = POSITIVE;
    936                    }
    937                    else 
    938                      if (bPrevHallState == STATE_3)
    939                      {
    940                        bSpeed = NEGATIVE;
    941                      }
    942                  
    943                  if(bSpeed<0)
    944                  {
    945                    hElectrical_Angle =(s16)(S16_PHASE_SHIFT );  
    946                  }
    947                  else if(bSpeed!= ERROR)
    948                  {
    949                    hElectrical_Angle =(s16)(S16_PHASE_SHIFT - S16_60_PHASE_SHIFT);  
    950                  }                      
    951                  break;
    952                  
    953                default:
    954                  bSpeed = ERROR;
    955                  break;
    956              }
    957          #endif
    958             // A capture event occured, it clears the flag  	
    959          	TIM_ClearFlag(HALL_TIMER, TIM_FLAG_CC1);
    960             
    961             // used for discarding first capture
    962             if (hCaptCounter < U16_MAX)
    963             {
    964                hCaptCounter++;
    965             }
    966          
    967             // Compute new array index
    968             if (bSpeedFIFO_Index != HALL_SPEED_FIFO_SIZE-1)
    969             {
    970                bSpeedFIFO_Index++;
    971             }
    972             else
    973             {
    974                bSpeedFIFO_Index = 0;
    975             }
    976          
    977             //Timeout Flag is cleared when receiving an IC
    978             HALL_ClrTimeOut();
    979             
    980             // Store the latest speed acquisition
    981             if (bGP1_OVF_Counter != 0)	// There was counter overflow before capture
    982             {
    983                  u32 wCaptBuf;
    984                  u16 hPrscBuf;
    985          
    986                wCaptBuf = (u32)TIM_GetCapture1(HALL_TIMER);        
    987                
    988                hPrscBuf = HALL_TIMER->PSC;
    989          
    990                while (bGP1_OVF_Counter != 0)
    991                {
    992                   wCaptBuf += 0x10000uL;// Compute the real captured value (> 16-bit)
    993                   bGP1_OVF_Counter--;
    994                   // OVF Counter is 8-bit and Capt is 16-bit, thus max CaptBuf is 24-bits
    995                }
    996                while(wCaptBuf > U16_MAX)
    997                {
    998                   wCaptBuf /= 2;		// Make it fit 16-bit using virtual prescaler
    999                   // Reduced resolution not a problem since result just slightly < 16-bit
   1000                   hPrscBuf = (hPrscBuf * 2) + 1;
   1001                   if (hPrscBuf > U16_MAX/2) // Avoid Prsc overflow
   1002                   {
   1003                      hPrscBuf = U16_MAX;
   1004                      wCaptBuf = U16_MAX;
   1005                   }
   1006                }
   1007                SensorPeriod[bSpeedFIFO_Index].hCapture = wCaptBuf;
   1008                SensorPeriod[bSpeedFIFO_Index].hPrscReg = hPrscBuf;
   1009                SensorPeriod[bSpeedFIFO_Index].bDirection = bSpeed;
   1010                if (RatioInc)
   1011                {
   1012                   RatioInc = FALSE;	// Previous capture caused overflow
   1013                   // Don't change prescaler (delay due to preload/update mechanism)
   1014                }
   1015                else
   1016                {
   1017                   if ((HALL_TIMER->PSC) < HALL_MAX_RATIO) // Avoid OVF w/ very low freq
   1018                   {
   1019                      (HALL_TIMER->PSC)++; // To avoid OVF during speed decrease
   1020                      RatioInc = TRUE;	  // new prsc value updated at next capture only
   1021                   }
   1022                }
   1023             }
   1024             else		// No counter overflow
   1025             {
   1026                u16 hHighSpeedCapture, hClockPrescaler;   
   1027          
   1028                hHighSpeedCapture = (u32)TIM_GetCapture1(HALL_TIMER);
   1029                  
   1030                SensorPeriod[bSpeedFIFO_Index].hCapture = hHighSpeedCapture;
   1031                SensorPeriod[bSpeedFIFO_Index].bDirection = bSpeed;
   1032                // Store prescaler directly or incremented if value changed on last capt
   1033                hClockPrescaler = HALL_TIMER->PSC;
   1034          
   1035                // If prsc preload reduced in last capture, store current register + 1
   1036                if (RatioDec)  // and don't decrease it again
   1037                {
   1038                   SensorPeriod[bSpeedFIFO_Index].hPrscReg = (hClockPrescaler)+1;
   1039                   RatioDec = FALSE;
   1040                }
   1041                else  // If prescaler was not modified on previous capture
   1042                {
   1043                   if (hHighSpeedCapture >= LOW_RES_THRESHOLD)// If capture range correct
   1044                   {
   1045                      SensorPeriod[bSpeedFIFO_Index].hPrscReg = hClockPrescaler;
   1046                   }
   1047                   else
   1048                   {
   1049                      if(HALL_TIMER->PSC == 0) // or prescaler cannot be further reduced
   1050                      {
   1051                         SensorPeriod[bSpeedFIFO_Index].hPrscReg = hClockPrescaler;
   1052                      }
   1053                      else  // The prescaler needs to be modified to optimize the accuracy
   1054                      {
   1055                         SensorPeriod[bSpeedFIFO_Index].hPrscReg = hClockPrescaler;
   1056                         (HALL_TIMER->PSC)--;	// Increase accuracy by decreasing prsc
   1057                         // Avoid decrementing again in next capt.(register preload delay)
   1058                         RatioDec = TRUE;
   1059                      }
   1060                   }
   1061                }
   1062             }
   1063              
   1064             if (InitRollingAverage)
   1065             {
   1066                  u16 hCaptBuf, hPrscBuf;
   1067                  s8 bSpeedAux;
   1068                  u32 wIndex;
   1069                // Read last captured value and copy it into the whole array
   1070                hCaptBuf = SensorPeriod[bSpeedFIFO_Index].hCapture;
   1071                hPrscBuf = SensorPeriod[bSpeedFIFO_Index].hPrscReg;
   1072                bSpeedAux = SensorPeriod[bSpeedFIFO_Index].bDirection;
   1073                
   1074                for (wIndex = 0; wIndex != HALL_SPEED_FIFO_SIZE-1; wIndex++)
   1075                {
   1076                   SensorPeriod[wIndex].hCapture = hCaptBuf;
   1077                   SensorPeriod[wIndex].hPrscReg = hPrscBuf;
   1078                   SensorPeriod[wIndex].bDirection = bSpeedAux;
   1079                }
   1080                InitRollingAverage = FALSE;
   1081                // Starting from now, the values returned by MTC_GetRotorFreq are averaged
   1082                DoRollingAverage = TRUE;
   1083              }
   1084             
   1085            //Update Rotor Frequency Computation
   1086             hRotorFreq_dpp = HALL_GetRotorFreq();
   1087            
   1088            }
   1089            else 
   1090            {
   1091              TIM_ClearFlag(HALL_TIMER, TIM_FLAG_Update);  
   1092            	// an update event occured for this interrupt request generation
   1093              if (bGP1_OVF_Counter < U8_MAX)
   1094              {
   1095                 bGP1_OVF_Counter++;
   1096              }
   1097            
   1098              if (bGP1_OVF_Counter >= HALL_MAX_OVERFLOWS)		 //
   1099              {
   1100                 HallTimeOut = TRUE;
   1101                 hRotorFreq_dpp = 0;
   1102              }    
   1103            }
   1104          }
   1105          
   1106          #endif // HALL_SENSORS defined
   1107          
   1108          /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       24  GetAvrgHallPeriod
        8  GetLastHallPeriod
        0  HALL_ClrCaptCounter
        0  HALL_ClrTimeOut
        0  HALL_GetCaptCounter
        0  HALL_GetElectricalAngle
       16  HALL_GetRotorFreq
             16 -> GetAvrgHallPeriod
             16 -> GetLastHallPeriod
        0  HALL_GetSpeed
       40  HALL_HallTimerInit
             40 -> GPIO_Init
             40 -> GPIO_StructInit
             40 -> NVIC_Init
             40 -> RCC_APB1PeriphClockCmd
             40 -> RCC_APB2PeriphClockCmd
             40 -> TIM_ClearFlag
             40 -> TIM_Cmd
             40 -> TIM_DeInit
             40 -> TIM_ICInit
             40 -> TIM_ICStructInit
             40 -> TIM_ITConfig
             40 -> TIM_InternalClockConfig
             40 -> TIM_PrescalerConfig
             40 -> TIM_SelectHallSensor
             40 -> TIM_SelectInputTrigger
             40 -> TIM_SelectSlaveMode
             40 -> TIM_SetCounter
             40 -> TIM_TimeBaseInit
             40 -> TIM_TimeBaseStructInit
             40 -> TIM_UpdateRequestConfig
        0  HALL_IncElectricalAngle
       16  HALL_InitHallMeasure
             16 -> TIM_Cmd
              0 -> TIM_ITConfig
             16 -> TIM_ITConfig
             16 -> TIM_SetCounter
        8  HALL_Init_Electrical_Angle
              8 -> GPIO_ReadInputData
        0  HALL_IsTimedOut
        0  HALL_StartHallFiltering
        8  ReadHallState
              8 -> GPIO_ReadInputData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_10
       4  ??DataTable14_11
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
      76  GetAvrgHallPeriod
      44  GetLastHallPeriod
       8  HALL_ClrCaptCounter
       8  HALL_ClrTimeOut
       6  HALL_GetCaptCounter
       8  HALL_GetElectricalAngle
     106  HALL_GetRotorFreq
      32  HALL_GetSpeed
     270  HALL_HallTimerInit
      28  HALL_IncElectricalAngle
     144  HALL_InitHallMeasure
      72  HALL_Init_Electrical_Angle
       6  HALL_IsTimedOut
       8  HALL_StartHallFiltering
       8  PeriodMeas
      14  ReadHallState
      36  SensorPeriod
      16  bSpeedFIFO_Index
          bGP1_OVF_Counter
          RatioDec
          RatioInc
          DoRollingAverage
          InitRollingAverage
          HallTimeOut
          hCaptCounter
          hElectrical_Angle
          hRotorFreq_dpp
          hPrevRotorFreq

 
  60 bytes in section .bss
 878 bytes in section .text
 
 878 bytes of CODE memory
  60 bytes of DATA memory

Errors: none
Warnings: 3
