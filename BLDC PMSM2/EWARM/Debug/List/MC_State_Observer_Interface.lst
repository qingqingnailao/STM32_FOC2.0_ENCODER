###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.1.53790/W32 for ARM     24/Feb/2014  19:26:39 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\stm32\BLDC PMSM2\src\MC_State_Observer_Interface.c    #
#    Command line =  "D:\stm32\BLDC PMSM2\src\MC_State_Observer_Interface.c"  #
#                    -D VECT_TAB_FLASH -lCN "D:\stm32\BLDC                    #
#                    PMSM2\EWARM\Debug\List\" --diag_error Pe068,Pe069 -o     #
#                    "D:\stm32\BLDC PMSM2\EWARM\Debug\Obj\" --debug           #
#                    --endian=little --cpu=Cortex-M3 --fpu=None               #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 6.4\arm\INC\c\DLib_Config_Normal.h" -I         #
#                    "D:\stm32\BLDC PMSM2\EWARM\..\" -I "D:\stm32\BLDC        #
#                    PMSM2\EWARM\..\..\STM32F10XFWLIB\inc\" -I                #
#                    "D:\stm32\BLDC PMSM2\EWARM\..\inc\" -Oh                  #
#                    --use_c++_inline --require_prototypes                    #
#    List file    =  D:\stm32\BLDC PMSM2\EWARM\Debug\List\MC_State_Observer_I #
#                    nterface.lst                                             #
#    Object file  =  D:\stm32\BLDC PMSM2\EWARM\Debug\Obj\MC_State_Observer_In #
#                    terface.o                                                #
#                                                                             #
#                                                                             #
###############################################################################

D:\stm32\BLDC PMSM2\src\MC_State_Observer_Interface.c
      1          /******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
      2          * File Name          : MC_State_Observer_Interface.c
      3          * Author             : IMS Systems Lab 
      4          * Date First Issued  : 21/11/07
      5          * Description        : This module implements the State Observer of 
      6          *                      the PMSM B-EMF, thus identifying rotor speed and position
      7          *
      8          ********************************************************************************
      9          * History:
     10          * 21/11/07 v1.0
     11          * 29/05/08 v2.0
     12          * 11/07/08 v2.0.1
     13          ********************************************************************************
     14          * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     15          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     16          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     17          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     18          * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     19          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     20          *
     21          * THIS SOURCE CODE IS PROTECTED BY A LICENSE.
     22          * FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED
     23          * IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
     24          *******************************************************************************/
     25          
     26          /* Includes ------------------------------------------------------------------*/
     27          #include "stm32f10x_lib.h"
     28          #include "stm32f10x_MClib.h"
     29          #include "MC_Globals.h"
     30          #include "MC_const.h"
     31          
     32          #include "MC_PMSM_motor_param.h"
     33          #include "MC_State_Observer_Interface.h"
     34          #include "MC_State_Observer.h"
     35          #include "MC_State_Observer_param.h"
     36          
     37          /* Private typedef -----------------------------------------------------------*/
     38          typedef enum 
     39          {
     40           S_INIT, ALIGNMENT, RAMP_UP
     41          } Start_upStatus_t;
     42          
     43          /* Private define ------------------------------------------------------------*/
     44          #define LOWER_THRESHOLD_FACTOR    0.8  //percentage of forced speed
     45          #define UPPER_THRESHOLD_FACTOR    1    //percentage of forced speed
     46          
     47          #define LOW_THRESHOLD             (u8) (LOWER_THRESHOLD_FACTOR*10)
     48          #define UP_THRESHOLD              (u8) (UPPER_THRESHOLD_FACTOR*10)
     49          
     50          #define HC2_INIT                  (s16)((F1*wK1_LO)/SAMPLING_FREQ)
     51          #define HC4_INIT                  (s16)(((wK2_LO*MAX_CURRENT)/MAX_BEMF_VOLTAGE)\
     52                                                  *F2/SAMPLING_FREQ)
     53          //Do not be modified
     54          #define SLESS_T_ALIGNMENT_PWM_STEPS       (u32) ((SLESS_T_ALIGNMENT * SAMPLING_FREQ)\
     55                                                                                    /1000) 
     56          #define SLESS_ALIGNMENT_ANGLE_S16         (s16)((s32)(SLESS_ALIGNMENT_ANGLE)\
     57                                                                              * 65536/360)
     58          /* Private macro -------------------------------------------------------------*/
     59          /* Private variables ---------------------------------------------------------*/

   \                                 In section .bss, align 4
     60          static u16 bConvCounter;
     61          static s16 hAngle = 0;
     62          static u32 wTime = 0;
     63          static s32 wStart_Up_Freq = 0;
     64          static s32 wStart_Up_I;
     65          static s16 hFreq_Inc;
     66          static s32 hI_Inc;
     67          
     68          static Start_upStatus_t  Start_Up_State = S_INIT;
   \                     Start_Up_State:
   \   00000000                      DS8 1
   \   00000001                      DS8 1
   \   00000002                      DS8 2
   \   00000004                      DS8 2
   \   00000006                      DS8 2
   \   00000008                      DS8 4
   \   0000000C                      DS8 4
   \   00000010                      DS8 4
   \   00000014                      DS8 4
     69          
     70          #ifdef OBSERVER_GAIN_TUNING

   \                                 In section .data, align 4
     71          volatile s32 wK1_LO = K1;
     72          volatile s32 wK2_LO = K2;
     73          volatile s16 hPLL_P_Gain = PLL_KP_GAIN;
   \                     hPLL_P_Gain:
   \   00000000   0x010A             DC16 266
     74          volatile s16 hPLL_I_Gain = PLL_KI_GAIN;
   \                     hPLL_I_Gain:
   \   00000002   0x0034             DC16 52
   \                     wK1_LO:
   \   00000004   0xFFFFB2F3         DC32 -19725
   \                     wK2_LO:
   \   00000008   0x00012132         DC32 74034
     75          #endif
     76          
     77          /* Private functions ---------------------------------------------------------*/
     78          bool IsObserverConverged(void);
     79          void STO_StartUp_Init(void);
     80          
     81          /*******************************************************************************
     82          * Function Name : STO_StateObserverInterface_Init
     83          * Description : It fills and passes to the State Obsever module the data 
     84          *               structure necessary for rotor position observation 
     85          * Input : None
     86          * Output : None
     87          * Return : None
     88          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     89          void STO_StateObserverInterface_Init(void)
     90          {
   \                     STO_StateObserverInterface_Init:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
     91           StateObserver_Const StateObserver_ConstStruct;
     92           
     93           StateObserver_ConstStruct.hC1 = C1;
   \   00000004   0xF640 0x301C      MOVW     R0,#+2844
   \   00000008   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     94           StateObserver_ConstStruct.hC3 = C3;
   \   0000000C   0xF640 0x60A6      MOVW     R0,#+3750
   \   00000010   0xF8AD 0x0004      STRH     R0,[SP, #+4]
     95           StateObserver_ConstStruct.hC5 = C5; 
   \   00000014   0xF8AD 0x0008      STRH     R0,[SP, #+8]
     96            
     97             {
     98              s16 htempk;
     99              StateObserver_ConstStruct.hF3 = 1;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    100              htempk = (s16)((100*65536)/(F2*2*PI));
   \   0000001E   0x207F             MOVS     R0,#+127
    101              while (htempk != 0)
    102              {
    103                htempk /=2;
   \                     ??STO_StateObserverInterface_Init_0:
   \   00000020   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   00000024   0x03C0             LSLS     R0,R0,#+15
   \   00000026   0x1400             ASRS     R0,R0,#+16
    104                StateObserver_ConstStruct.hF3 *=2;
   \   00000028   0xF8BD 0x1010      LDRH     R1,[SP, #+16]
   \   0000002C   0x0049             LSLS     R1,R1,#+1
   \   0000002E   0xF8AD 0x1010      STRH     R1,[SP, #+16]
    105              }
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD1F4             BNE.N    ??STO_StateObserverInterface_Init_0
    106              StateObserver_ConstStruct.hC6 = (s16)((F2*StateObserver_ConstStruct.hF3*2*
    107                                                                              PI)/65536);//10000
   \   00000036   0x0409             LSLS     R1,R1,#+16
   \   00000038   0x1088             ASRS     R0,R1,#+2
   \   0000003A   0x.... 0x....      BL       __aeabi_i2d
   \   0000003E   0x....             LDR.N    R2,??DataTable6  ;; 0x2e48e8a7
   \   00000040   0x....             LDR.N    R3,??DataTable6_1  ;; 0x400921ff
   \   00000042   0x.... 0x....      BL       __aeabi_dmul
   \   00000046   0x2200             MOVS     R2,#+0
   \   00000048   0x....             LDR.N    R3,??DataTable6_2  ;; 0x3ef00000
   \   0000004A   0x.... 0x....      BL       __aeabi_dmul
   \   0000004E   0x.... 0x....      BL       __aeabi_d2iz
   \   00000052   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    108            }
    109          
    110          #ifdef OBSERVER_GAIN_TUNING  
    111            /* lines below for debug porpose*/
    112            StateObserver_ConstStruct.hC2 = C2;
   \   00000056   0x....             LDR.N    R0,??DataTable6_3  ;; 0xffffa856
   \   00000058   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    113            StateObserver_ConstStruct.hC4 = C4;
   \   0000005C   0xF245 0x302C      MOVW     R0,#+21292
   \   00000060   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    114              
    115            StateObserver_ConstStruct.hC2 = (s16)((F1*wK1_LO)/SAMPLING_FREQ);
   \   00000064   0x....             LDR.N    R4,??DataTable6_4
   \   00000066   0x6860             LDR      R0,[R4, #+4]
   \   00000068   0x0380             LSLS     R0,R0,#+14
   \   0000006A   0xF44F 0x5161      MOV      R1,#+14400
   \   0000006E   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000072   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    116            StateObserver_ConstStruct.hC4 = (s16)((((wK2_LO*MAX_CURRENT)/(MAX_BEMF_VOLTAGE
    117                                                                 ))*F2)/(SAMPLING_FREQ));
   \   00000076   0x68A0             LDR      R0,[R4, #+8]
   \   00000078   0x.... 0x....      BL       __aeabi_i2d
   \   0000007C   0xF04F 0x3233      MOV      R2,#+858993459
   \   00000080   0x....             LDR.N    R3,??DataTable6_5  ;; 0x40223333
   \   00000082   0x.... 0x....      BL       __aeabi_dmul
   \   00000086   0x2200             MOVS     R2,#+0
   \   00000088   0x....             LDR.N    R3,??DataTable6_6  ;; 0x40320000
   \   0000008A   0x.... 0x....      BL       __aeabi_ddiv
   \   0000008E   0x2200             MOVS     R2,#+0
   \   00000090   0x....             LDR.N    R3,??DataTable6_7  ;; 0x40c00000
   \   00000092   0x.... 0x....      BL       __aeabi_dmul
   \   00000096   0x2200             MOVS     R2,#+0
   \   00000098   0x....             LDR.N    R3,??DataTable6_8  ;; 0x40cc2000
   \   0000009A   0x.... 0x....      BL       __aeabi_ddiv
   \   0000009E   0x.... 0x....      BL       __aeabi_d2iz
   \   000000A2   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    118            StateObserver_ConstStruct.PLL_P = hPLL_P_Gain;
   \   000000A6   0x8820             LDRH     R0,[R4, #+0]
   \   000000A8   0xF8AD 0x0012      STRH     R0,[SP, #+18]
    119            StateObserver_ConstStruct.PLL_I = hPLL_I_Gain;
   \   000000AC   0x8860             LDRH     R0,[R4, #+2]
   \   000000AE   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    120          #else
    121            StateObserver_ConstStruct.hC2 = C2;
    122            StateObserver_ConstStruct.hC4 = C4;
    123            StateObserver_ConstStruct.PLL_P = PLL_KP_GAIN;
    124            StateObserver_ConstStruct.PLL_I = PLL_KI_GAIN;  
    125          #endif    
    126            StateObserver_ConstStruct.hF1 = F1;
   \   000000B2   0xF44F 0x4080      MOV      R0,#+16384
   \   000000B6   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    127            StateObserver_ConstStruct.hF2 = F2;
   \   000000BA   0xF44F 0x5000      MOV      R0,#+8192
   \   000000BE   0xF8AD 0x000E      STRH     R0,[SP, #+14]
    128            StateObserver_ConstStruct.wMotorMaxSpeed_dpp = MOTOR_MAX_SPEED_DPP;
   \   000000C2   0xF240 0x208F      MOVW     R0,#+655
   \   000000C6   0x9006             STR      R0,[SP, #+24]
    129            StateObserver_ConstStruct.hPercentageFactor = PERCENTAGE_FACTOR;
   \   000000C8   0x2008             MOVS     R0,#+8
   \   000000CA   0xF8AD 0x001C      STRH     R0,[SP, #+28]
    130            
    131            STO_Gains_Init(&StateObserver_ConstStruct);
   \   000000CE   0xA800             ADD      R0,SP,#+0
   \   000000D0   0x.... 0x....      BL       STO_Gains_Init
    132          }
   \   000000D4   0xB008             ADD      SP,SP,#+32
   \   000000D6   0xBD10             POP      {R4,PC}          ;; return
    133            
    134          /*******************************************************************************
    135          * Function Name : STO_Check_Speed_Reliability
    136          * Description : Check for the continuity of the speed reliability. If the speed 
    137          *               is continously not reliable, the motor must be stopped 
    138          * Input : None
    139          * Output : None
    140          * Return : boolean value: TRUE if speed is reliable, FALSE otherwise.
    141          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    142          bool STO_Check_Speed_Reliability(void)
    143          {
   \                     STO_Check_Speed_Reliability:
   \   00000000   0xB510             PUSH     {R4,LR}
    144            static u8 bCounter=0;
    145            bool baux;
    146            
    147            if(STO_IsSpeed_Reliable() == FALSE)
   \   00000002   0x....             LDR.N    R4,??DataTable6_9
   \   00000004   0x.... 0x....      BL       STO_IsSpeed_Reliable
   \   00000008   0xB938             CBNZ.N   R0,??STO_Check_Speed_Reliability_0
    148            {
    149             bCounter++;
   \   0000000A   0x7820             LDRB     R0,[R4, #+0]
   \   0000000C   0x1C41             ADDS     R1,R0,#+1
    150             if (bCounter >= RELIABILITY_HYSTERESYS)
   \   0000000E   0xB2C9             UXTB     R1,R1
   \   00000010   0x2903             CMP      R1,#+3
   \   00000012   0xD303             BCC.N    ??STO_Check_Speed_Reliability_1
    151             {
    152               bCounter = 0;
   \   00000014   0x2100             MOVS     R1,#+0
    153               baux = FALSE;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE001             B.N      ??STO_Check_Speed_Reliability_2
    154             }
    155             else
    156             {
    157               baux = TRUE;
    158             }
    159            }
    160            else
    161            {
    162             bCounter = 0;
   \                     ??STO_Check_Speed_Reliability_0:
   \   0000001A   0x2100             MOVS     R1,#+0
    163             baux = TRUE;
   \                     ??STO_Check_Speed_Reliability_1:
   \   0000001C   0x2001             MOVS     R0,#+1
   \                     ??STO_Check_Speed_Reliability_2:
   \   0000001E   0x7021             STRB     R1,[R4, #+0]
    164            }
    165            return(baux);
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    166          }

   \                                 In section .bss, align 1
   \                     ??bCounter:
   \   00000000                      DS8 1
    167                     
    168          /*******************************************************************************
    169          * Function Name : IsObserverConverged
    170          * Description : Check for algorithm convergence. The speed reliability and the
    171          *               range of the value of the estimated speed are checked. 
    172          * Input : None
    173          * Output : None
    174          * Return : boolean value: TRUE if algortihm converged, FALSE otherwise.
    175          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    176          bool IsObserverConverged(void)
    177          { 
   \                     IsObserverConverged:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    178            s16 hEstimatedSpeed;
    179            s16 hUpperThreshold;
    180            s16 hLowerThreshold;
    181          
    182            hEstimatedSpeed = STO_Get_Speed_Hz();
   \   00000002   0x.... 0x....      BL       STO_Get_Speed_Hz
   \   00000006   0x0005             MOVS     R5,R0
    183            hEstimatedSpeed = (hEstimatedSpeed < 0 ? -hEstimatedSpeed : hEstimatedSpeed);  
   \   00000008   0xBF44             ITT      MI 
   \   0000000A   0x426D             RSBMI    R5,R5,#+0
   \   0000000C   0xB22D             SXTHMI   R5,R5
    184            hUpperThreshold = ((wStart_Up_Freq/65536) * 160)/(POLE_PAIR_NUM * 16);
   \   0000000E   0x....             LDR.N    R4,??DataTable6_10
   \   00000010   0x68E0             LDR      R0,[R4, #+12]
   \   00000012   0x13C1             ASRS     R1,R0,#+15
   \   00000014   0xEB00 0x4111      ADD      R1,R0,R1, LSR #+16
   \   00000018   0x1409             ASRS     R1,R1,#+16
   \   0000001A   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \   0000001E   0x0152             LSLS     R2,R2,#+5
   \   00000020   0x1113             ASRS     R3,R2,#+4
   \   00000022   0xEB02 0x62D3      ADD      R2,R2,R3, LSR #+27
   \   00000026   0x02D6             LSLS     R6,R2,#+11
    185            hUpperThreshold = (hUpperThreshold < 0 ? -hUpperThreshold : hUpperThreshold);
   \   00000028   0x1436             ASRS     R6,R6,#+16
   \   0000002A   0xBF48             IT       MI 
   \   0000002C   0x4276             RSBMI    R6,R6,#+0
    186            hLowerThreshold = ((wStart_Up_Freq/65536) *150) / (POLE_PAIR_NUM * 16);
   \   0000002E   0x2296             MOVS     R2,#+150
   \   00000030   0x4351             MULS     R1,R2,R1
   \   00000032   0x110A             ASRS     R2,R1,#+4
   \   00000034   0xEB01 0x61D2      ADD      R1,R1,R2, LSR #+27
   \   00000038   0x02CF             LSLS     R7,R1,#+11
    187            hLowerThreshold = (hLowerThreshold < 0 ? -hLowerThreshold : hLowerThreshold);
   \   0000003A   0x143F             ASRS     R7,R7,#+16
   \   0000003C   0xBF48             IT       MI 
   \   0000003E   0x427F             RSBMI    R7,R7,#+0
    188            
    189            // If the variance of the estimated speed is low enough...
    190            if(STO_IsSpeed_Reliable() == TRUE)
   \   00000040   0x.... 0x....      BL       STO_IsSpeed_Reliable
   \   00000044   0x2801             CMP      R0,#+1
   \   00000046   0xD10F             BNE.N    ??IsObserverConverged_0
    191            { 
    192              if(hEstimatedSpeed > MINIMUM_SPEED)
   \   00000048   0x2D61             CMP      R5,#+97
   \   0000004A   0xBFA1             ITTTT    GE 
   \   0000004C   0xB23F             SXTHGE   R7,R7
   \   0000004E   0x42BD             CMPGE    R5,R7
    193              {
    194                //...and the estimated value is quite close to the expected value... 
    195                if(hEstimatedSpeed >= hLowerThreshold)
   \   00000050   0xB236             SXTHGE   R6,R6
   \   00000052   0x42AE             CMPGE    R6,R5
    196                {
    197                  if(hEstimatedSpeed <= hUpperThreshold)
   \   00000054   0xDB08             BLT.N    ??IsObserverConverged_0
    198                  {
    199                    bConvCounter++;
   \   00000056   0x8860             LDRH     R0,[R4, #+2]
   \   00000058   0x1C41             ADDS     R1,R0,#+1
   \   0000005A   0x8061             STRH     R1,[R4, #+2]
    200                    if (bConvCounter >= NB_CONSECUTIVE_TESTS)
   \   0000005C   0xB289             UXTH     R1,R1
   \   0000005E   0x293C             CMP      R1,#+60
   \   00000060   0x4180             SBCS     R0,R0,R0
   \   00000062   0x43C0             MVNS     R0,R0
   \   00000064   0x0FC0             LSRS     R0,R0,#+31
    201                    {
    202                      // ...the algorithm converged.
    203                      return(TRUE);
   \   00000066   0xBDF2             POP      {R1,R4-R7,PC}
    204                    }
    205                    else
    206                    {
    207                      return(FALSE);
    208                    }            
    209                  }
    210                  else
    211                  { 
    212                    bConvCounter = 0;
    213                    return(FALSE);
    214                  }              
    215                }
    216                else
    217                { 
    218                  bConvCounter = 0;
    219                  return(FALSE);
    220                } 
    221              }
    222              else
    223              { 
    224                bConvCounter = 0;
    225                return(FALSE);
    226              } 
    227            }
    228            else
    229            { 
    230              bConvCounter = 0;
   \                     ??IsObserverConverged_0:
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x8060             STRH     R0,[R4, #+2]
    231              return(FALSE);
   \   0000006C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    232            }    
    233          }
    234          
    235          /*******************************************************************************
    236          * Function Name : STO_Get_Speed_Hz
    237          * Description : It returns the motor mechanical speed (Hz*10)
    238          * Input : None.
    239          * Output : None.
    240          * Return : hRotor_Speed_Hz.
    241          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    242          s16 STO_Get_Speed_Hz(void)
    243          {
   \                     STO_Get_Speed_Hz:
   \   00000000   0xB580             PUSH     {R7,LR}
    244            return (s16)((STO_Get_Speed()* SAMPLING_FREQ * 10)/(65536*POLE_PAIR_NUM));
   \   00000002   0x.... 0x....      BL       STO_Get_Speed
   \   00000006   0x....             LDR.N    R1,??DataTable6_11  ;; 0x23280
   \   00000008   0x4348             MULS     R0,R1,R0
   \   0000000A   0x1401             ASRS     R1,R0,#+16
   \   0000000C   0xEB00 0x30D1      ADD      R0,R0,R1, LSR #+15
   \   00000010   0x1440             ASRS     R0,R0,#+17
   \   00000012   0xBD02             POP      {R1,PC}          ;; return
    245          }
    246          
    247          /*******************************************************************************
    248          * Function Name : STO_Get_Mechanical_Angle
    249          * Description : It returns the rotor position (mechanical angle,s16) 
    250          * Input : None.
    251          * Output : None.
    252          * Return : hRotor_El_Angle/pole pairs number.
    253          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    254          s16 STO_Get_Mechanical_Angle(void)
    255          {
   \                     STO_Get_Mechanical_Angle:
   \   00000000   0xB580             PUSH     {R7,LR}
    256            return ((s16)(STO_Get_Electrical_Angle()/POLE_PAIR_NUM));
   \   00000002   0x.... 0x....      BL       STO_Get_Electrical_Angle
   \   00000006   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   0000000A   0x03C0             LSLS     R0,R0,#+15
   \   0000000C   0x1400             ASRS     R0,R0,#+16
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return
    257          }
    258          
    259          /*******************************************************************************
    260          * Function Name : STO_Start_Up
    261          * Description : This function implements the ramp-up by forcing a stator current 
    262          *               with controlled amplitude and frequency. If the observer 
    263          *               algorithm converged, it also assign RUN to State variable  
    264          * Input : details the input parameters.
    265          * Output : details the output parameters.
    266          * Return : details the return value.
    267          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    268          void STO_Start_Up(void)
    269          {
   \                     STO_Start_Up:
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
    270            s16 hAux;
    271          #ifdef NO_SPEED_SENSORS_ALIGNMENT
    272            static u32 wAlignmentTbase=0;
    273          #endif  
    274            
    275            switch(Start_Up_State)
   \   00000004   0x....             LDR.N    R5,??DataTable6_10
   \   00000006   0x7828             LDRB     R0,[R5, #+0]
   \   00000008   0xB120             CBZ.N    R0,??STO_Start_Up_0
   \   0000000A   0x2802             CMP      R0,#+2
   \   0000000C   0xD01C             BEQ.N    ??STO_Start_Up_1
   \   0000000E   0xD317             BCC.N    ??STO_Start_Up_2
   \   00000010   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}
    276            {
    277            case S_INIT:
    278              //Init Ramp-up variables
    279              if (hSpeed_Reference >= 0)
   \                     ??STO_Start_Up_0:
   \   00000014   0x68A8             LDR      R0,[R5, #+8]
   \   00000016   0x....             LDR.N    R1,??DataTable6_12
   \   00000018   0xF9B1 0x1000      LDRSH    R1,[R1, #+0]
   \   0000001C   0x2900             CMP      R1,#+0
   \   0000001E   0xD404             BMI.N    ??STO_Start_Up_3
    280              {
    281                hFreq_Inc = FREQ_INC;
   \   00000020   0x2110             MOVS     R1,#+16
    282                hI_Inc = I_INC;
   \   00000022   0x2239             MOVS     R2,#+57
    283                if (wTime == 0)
   \   00000024   0xB940             CBNZ.N   R0,??STO_Start_Up_4
    284                {
    285                  wStart_Up_I = FIRST_I_STARTUP *1024;
   \   00000026   0x....             LDR.N    R0,??DataTable6_13  ;; 0x21c400
   \   00000028   0xE005             B.N      ??STO_Start_Up_5
    286                }
    287              }
    288              else
    289              {
    290                hFreq_Inc = -(s16)FREQ_INC;
   \                     ??STO_Start_Up_3:
   \   0000002A   0xF06F 0x010F      MVN      R1,#+15
    291                hI_Inc = -(s16)I_INC; 
   \   0000002E   0xF06F 0x0238      MVN      R2,#+56
    292                if (wTime == 0)
   \   00000032   0xB908             CBNZ.N   R0,??STO_Start_Up_4
    293                {
    294                  wStart_Up_I = -(s32)FIRST_I_STARTUP *1024;
   \   00000034   0x....             LDR.N    R0,??DataTable6_14  ;; 0xffde3c00
   \                     ??STO_Start_Up_5:
   \   00000036   0x6128             STR      R0,[R5, #+16]
   \                     ??STO_Start_Up_4:
   \   00000038   0x616A             STR      R2,[R5, #+20]
   \   0000003A   0x80E9             STRH     R1,[R5, #+6]
    295                }
    296              }
    297              Start_Up_State = ALIGNMENT;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xE000             B.N      ??STO_Start_Up_6
    298              break;
    299              
    300            case ALIGNMENT:
    301          #ifdef NO_SPEED_SENSORS_ALIGNMENT
    302              wAlignmentTbase++;
    303              if(wAlignmentTbase <= SLESS_T_ALIGNMENT_PWM_STEPS)
    304              {                  
    305                hFlux_Reference = SLESS_I_ALIGNMENT * wAlignmentTbase / 
    306                                                              SLESS_T_ALIGNMENT_PWM_STEPS;               
    307                hTorque_Reference = 0;
    308                
    309                Stat_Curr_a_b = GET_PHASE_CURRENTS(); 
    310                Stat_Curr_alfa_beta = Clarke(Stat_Curr_a_b); 
    311                Stat_Curr_q_d = Park(Stat_Curr_alfa_beta, SLESS_ALIGNMENT_ANGLE_S16);  
    312                /*loads the Torque Regulator output reference voltage Vqs*/   
    313                Stat_Volt_q_d.qV_Component1 = PID_Regulator(hTorque_Reference, 
    314                                  Stat_Curr_q_d.qI_Component1, &PID_Torque_InitStructure);  
    315                /*loads the Flux Regulator output reference voltage Vds*/
    316                Stat_Volt_q_d.qV_Component2 = PID_Regulator(hFlux_Reference, 
    317                                    Stat_Curr_q_d.qI_Component2, &PID_Flux_InitStructure); 
    318          
    319                RevPark_Circle_Limitation();
    320          
    321                /*Performs the Reverse Park transformation,
    322                i.e transforms stator voltages Vqs and Vds into Valpha and Vbeta on a 
    323                stationary reference frame*/
    324          
    325                Stat_Volt_alfa_beta = Rev_Park(Stat_Volt_q_d);
    326          
    327                /*Valpha and Vbeta finally drive the power stage*/ 
    328                CALC_SVPWM(Stat_Volt_alfa_beta);
    329              }
    330              else
    331              {
    332                wAlignmentTbase = 0;                
    333                Stat_Volt_q_d.qV_Component1 = Stat_Volt_q_d.qV_Component2 = 0;
    334                hTorque_Reference = PID_TORQUE_REFERENCE;
    335                hFlux_Reference = PID_FLUX_REFERENCE;
    336                Start_Up_State = RAMP_UP;
    337                hAngle = SLESS_ALIGNMENT_ANGLE_S16;      
    338              }
    339          #else
    340              Start_Up_State = RAMP_UP;    
   \                     ??STO_Start_Up_2:
   \   00000040   0x2002             MOVS     R0,#+2
   \                     ??STO_Start_Up_6:
   \   00000042   0x7028             STRB     R0,[R5, #+0]
    341          #endif    
    342              break;
   \   00000044   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}
    343              
    344            case RAMP_UP:
    345              wTime ++;  
   \                     ??STO_Start_Up_1:
   \   00000048   0x68A8             LDR      R0,[R5, #+8]
   \   0000004A   0x1C40             ADDS     R0,R0,#+1
   \   0000004C   0x60A8             STR      R0,[R5, #+8]
    346              if (wTime <= I_STARTUP_PWM_STEPS)
   \   0000004E   0xF641 0x1151      MOVW     R1,#+6481
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xD209             BCS.N    ??STO_Start_Up_7
    347              {     
    348                wStart_Up_Freq += hFreq_Inc;
   \   00000056   0x68E8             LDR      R0,[R5, #+12]
   \   00000058   0xF9B5 0x1006      LDRSH    R1,[R5, #+6]
   \   0000005C   0x1808             ADDS     R0,R1,R0
   \   0000005E   0x60E8             STR      R0,[R5, #+12]
    349                wStart_Up_I += hI_Inc;
   \   00000060   0x6928             LDR      R0,[R5, #+16]
   \   00000062   0x6969             LDR      R1,[R5, #+20]
   \   00000064   0x1808             ADDS     R0,R1,R0
   \   00000066   0x6128             STR      R0,[R5, #+16]
   \   00000068   0xE00D             B.N      ??STO_Start_Up_8
    350              }
    351              else if (wTime <= FREQ_STARTUP_PWM_STEPS )
   \                     ??STO_Start_Up_7:
   \   0000006A   0x....             LDR.N    R1,??DataTable6_15  ;; 0x1de21
   \   0000006C   0x4288             CMP      R0,R1
   \   0000006E   0xD205             BCS.N    ??STO_Start_Up_9
    352              {
    353                wStart_Up_Freq += hFreq_Inc;
   \   00000070   0x68E8             LDR      R0,[R5, #+12]
   \   00000072   0xF9B5 0x1006      LDRSH    R1,[R5, #+6]
   \   00000076   0x1808             ADDS     R0,R1,R0
   \   00000078   0x60E8             STR      R0,[R5, #+12]
   \   0000007A   0xE004             B.N      ??STO_Start_Up_8
    354              }       
    355              else
    356              {
    357                MCL_SetFault(START_UP_FAILURE);
   \                     ??STO_Start_Up_9:
   \   0000007C   0x2004             MOVS     R0,#+4
   \   0000007E   0x.... 0x....      BL       MCL_SetFault
    358          	   //Æô¶¯Ê§°Ü´íÎó
    359                //Re_initialize Start Up
    360                STO_StartUp_Init();
   \   00000082   0x.... 0x....      BL       STO_StartUp_Init
    361              }
    362              
    363              //Add angle increment for ramp-up
    364              hAux = wStart_Up_Freq/65536;
    365              hAngle = (s16)(hAngle + (s32)(65536/(SAMPLING_FREQ/hAux)));
   \                     ??STO_Start_Up_8:
   \   00000086   0x68E8             LDR      R0,[R5, #+12]
   \   00000088   0x88A9             LDRH     R1,[R5, #+4]
   \   0000008A   0xF44F 0x5261      MOV      R2,#+14400
   \   0000008E   0x13C3             ASRS     R3,R0,#+15
   \   00000090   0xEB00 0x4013      ADD      R0,R0,R3, LSR #+16
   \   00000094   0x1400             ASRS     R0,R0,#+16
   \   00000096   0xFB92 0xF0F0      SDIV     R0,R2,R0
   \   0000009A   0xF44F 0x3280      MOV      R2,#+65536
   \   0000009E   0xFB92 0xF0F0      SDIV     R0,R2,R0
   \   000000A2   0x1840             ADDS     R0,R0,R1
   \   000000A4   0x80A8             STRH     R0,[R5, #+4]
    366                  
    367              Stat_Curr_a_b = GET_PHASE_CURRENTS(); 
   \   000000A6   0x.... 0x....      BL       SVPWM_3ShuntGetPhaseCurrentValues
   \   000000AA   0x....             LDR.N    R1,??DataTable6_16
   \   000000AC   0x6008             STR      R0,[R1, #+0]
   \   000000AE   0x9000             STR      R0,[SP, #+0]
    368              Stat_Curr_alfa_beta = Clarke(Stat_Curr_a_b); 
   \   000000B0   0x.... 0x....      BL       Clarke
   \   000000B4   0x....             LDR.N    R4,??DataTable6_17
   \   000000B6   0x6020             STR      R0,[R4, #+0]
   \   000000B8   0x9000             STR      R0,[SP, #+0]
    369              Stat_Curr_q_d = Park(Stat_Curr_alfa_beta, hAngle);
   \   000000BA   0xF9B5 0x1004      LDRSH    R1,[R5, #+4]
   \   000000BE   0x.... 0x....      BL       Park
   \   000000C2   0x....             LDR.N    R7,??DataTable6_18
   \   000000C4   0x6038             STR      R0,[R7, #+0]
    370              
    371              hAux = wStart_Up_I/1024;
    372              hTorque_Reference = hAux;       
   \   000000C6   0x6928             LDR      R0,[R5, #+16]
   \   000000C8   0x....             LDR.N    R5,??DataTable6_19
   \   000000CA   0x1241             ASRS     R1,R0,#+9
   \   000000CC   0xEB00 0x5091      ADD      R0,R0,R1, LSR #+22
   \   000000D0   0x1280             ASRS     R0,R0,#+10
   \   000000D2   0x8028             STRH     R0,[R5, #+0]
    373              hFlux_Reference = 0;
   \   000000D4   0x.... 0x....      LDR.W    R8,??DataTable6_20
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    374                     
    375              /*loads the Torque Regulator output reference voltage Vqs*/   
    376              Stat_Volt_q_d.qV_Component1 = PID_Regulator(hTorque_Reference, 
    377                                  Stat_Curr_q_d.qI_Component1, &PID_Torque_InitStructure);
   \   000000DE   0x....             LDR.N    R6,??DataTable6_21
   \   000000E0   0x....             LDR.N    R2,??DataTable6_22
   \   000000E2   0x5E39             LDRSH    R1,[R7, R0]
   \   000000E4   0x5E28             LDRSH    R0,[R5, R0]
   \   000000E6   0x.... 0x....      BL       PID_Regulator
   \   000000EA   0x8030             STRH     R0,[R6, #+0]
    378              /*loads the Flux Regulator output reference voltage Vds*/
    379              Stat_Volt_q_d.qV_Component2 = PID_Regulator(hFlux_Reference, 
    380                                    Stat_Curr_q_d.qI_Component2, &PID_Flux_InitStructure); 
   \   000000EC   0x....             LDR.N    R2,??DataTable6_23
   \   000000EE   0xF9B7 0x1002      LDRSH    R1,[R7, #+2]
   \   000000F2   0xF9B8 0x0000      LDRSH    R0,[R8, #+0]
   \   000000F6   0x.... 0x....      BL       PID_Regulator
   \   000000FA   0x8070             STRH     R0,[R6, #+2]
    381              
    382              RevPark_Circle_Limitation();
   \   000000FC   0x.... 0x....      BL       RevPark_Circle_Limitation
   \   00000100   0x6830             LDR      R0,[R6, #+0]
   \   00000102   0x9000             STR      R0,[SP, #+0]
    383            
    384              /*Performs the Reverse Park transformation,
    385              i.e transforms stator voltages Vqs and Vds into Valpha and Vbeta on a 
    386              stationary reference frame*/
    387              
    388              Stat_Volt_alfa_beta = Rev_Park(Stat_Volt_q_d);
   \   00000104   0x.... 0x....      BL       Rev_Park
   \   00000108   0x....             LDR.N    R7,??DataTable6_24
   \   0000010A   0x6038             STR      R0,[R7, #+0]
   \   0000010C   0x9000             STR      R0,[SP, #+0]
    389            
    390              /*Valpha and Vbeta finally drive the power stage*/ 
    391              CALC_SVPWM(Stat_Volt_alfa_beta);
   \   0000010E   0x.... 0x....      BL       SVPWM_3ShuntCalcDutyCycles
    392              
    393              STO_Calc_Rotor_Angle(Stat_Volt_alfa_beta,Stat_Curr_alfa_beta,MCL_Get_BusVolt());
   \   00000112   0x.... 0x....      BL       MCL_Get_BusVolt
   \   00000116   0x4602             MOV      R2,R0
   \   00000118   0x6820             LDR      R0,[R4, #+0]
   \   0000011A   0x9000             STR      R0,[SP, #+0]
   \   0000011C   0x6838             LDR      R0,[R7, #+0]
   \   0000011E   0x9001             STR      R0,[SP, #+4]
   \   00000120   0x9900             LDR      R1,[SP, #+0]
   \   00000122   0x.... 0x....      BL       STO_Calc_Rotor_Angle
    394             
    395              if (IsObserverConverged()==TRUE)
   \   00000126   0x.... 0x....      BL       IsObserverConverged
   \   0000012A   0x2801             CMP      R0,#+1
   \   0000012C   0xD113             BNE.N    ??STO_Start_Up_10
    396              {      
    397                PID_Speed_InitStructure.wIntegral = (s32)(hTorque_Reference*256);
   \   0000012E   0xF9B5 0x0000      LDRSH    R0,[R5, #+0]
   \   00000132   0x0200             LSLS     R0,R0,#+8
   \   00000134   0x....             LDR.N    R1,??DataTable6_25
   \   00000136   0x6148             STR      R0,[R1, #+20]
    398                STO_StartUp_Init();  
   \   00000138   0x.... 0x....      BL       STO_StartUp_Init
    399                State = RUN;
   \   0000013C   0x....             LDR.N    R0,??DataTable6_26
   \   0000013E   0x2103             MOVS     R1,#+3
   \   00000140   0x7001             STRB     R1,[R0, #+0]
    400                if ((wGlobal_Flags & SPEED_CONTROL) != SPEED_CONTROL)
   \   00000142   0x....             LDR.N    R0,??DataTable6_27
   \   00000144   0x6800             LDR      R0,[R0, #+0]
   \   00000146   0x07C0             LSLS     R0,R0,#+31
   \   00000148   0xD405             BMI.N    ??STO_Start_Up_10
    401                {
    402                  hTorque_Reference = PID_TORQUE_REFERENCE;
   \   0000014A   0xF44F 0x60B4      MOV      R0,#+1440
   \   0000014E   0x8028             STRH     R0,[R5, #+0]
    403                  hFlux_Reference = PID_FLUX_REFERENCE;
   \   00000150   0x2000             MOVS     R0,#+0
   \   00000152   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    404                }      
    405              }    
    406              break;
    407            default:
    408              break;
    409            }    
    410          }
   \                     ??STO_Start_Up_10:
   \   00000156   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return
    411          
    412          /*******************************************************************************
    413          * Function Name : STO_StartUp_Init
    414          * Description : This private function initializes the sensorless start-up
    415          * Input : details the input parameters.
    416          * Output : details the output parameters.
    417          * Return : details the return value.
    418          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    419          void STO_StartUp_Init(void)
    420          {
    421            //Re_initialize Start Up
    422            Start_Up_State = S_INIT;  
   \                     STO_StartUp_Init:
   \   00000000   0x....             LDR.N    R0,??DataTable6_10
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x7001             STRB     R1,[R0, #+0]
    423            hAngle = 0;
   \   00000006   0x8081             STRH     R1,[R0, #+4]
    424            wTime = 0;
   \   00000008   0x6081             STR      R1,[R0, #+8]
    425            wStart_Up_Freq = 0;
   \   0000000A   0x60C1             STR      R1,[R0, #+12]
    426            bConvCounter = 0; 
   \   0000000C   0x8041             STRH     R1,[R0, #+2]
    427          }      
   \   0000000E   0x4770             BX       LR               ;; return
    428                
    429          /*******************************************************************************
    430          * Function Name : STO_Obs_Gains_Update
    431          * Description : This function updates state observer gains after they have been
    432          *               changed by the user interface
    433          * Input : details the input parameters.
    434          * Output : details the output parameters.
    435          * Return : details the return value.
    436          *******************************************************************************/
    437          #ifdef OBSERVER_GAIN_TUNING

   \                                 In section .text, align 2, keep-with-next
    438          void STO_Obs_Gains_Update(void)
    439          {
   \                     STO_Obs_Gains_Update:
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    440            StateObserver_GainsUpdate STO_GainsUpdateStruct;
    441          
    442            STO_GainsUpdateStruct.PLL_P = hPLL_P_Gain;
   \   00000004   0x....             LDR.N    R0,??DataTable6_4
   \   00000006   0x8801             LDRH     R1,[R0, #+0]
   \   00000008   0xF8AD 0x1000      STRH     R1,[SP, #+0]
    443            STO_GainsUpdateStruct.PLL_I = hPLL_I_Gain;
   \   0000000C   0x8841             LDRH     R1,[R0, #+2]
   \   0000000E   0xF8AD 0x1002      STRH     R1,[SP, #+2]
    444            STO_GainsUpdateStruct.hC2 = HC2_INIT;  
   \   00000012   0x6841             LDR      R1,[R0, #+4]
   \   00000014   0x0389             LSLS     R1,R1,#+14
   \   00000016   0xF44F 0x5261      MOV      R2,#+14400
   \   0000001A   0xFB91 0xF1F2      SDIV     R1,R1,R2
   \   0000001E   0xF8AD 0x1004      STRH     R1,[SP, #+4]
    445            STO_GainsUpdateStruct.hC4 = HC4_INIT;            
   \   00000022   0x6880             LDR      R0,[R0, #+8]
   \   00000024   0x.... 0x....      BL       __aeabi_i2d
   \   00000028   0xF04F 0x3233      MOV      R2,#+858993459
   \   0000002C   0x....             LDR.N    R3,??DataTable6_5  ;; 0x40223333
   \   0000002E   0x.... 0x....      BL       __aeabi_dmul
   \   00000032   0x2200             MOVS     R2,#+0
   \   00000034   0x....             LDR.N    R3,??DataTable6_6  ;; 0x40320000
   \   00000036   0x.... 0x....      BL       __aeabi_ddiv
   \   0000003A   0x2200             MOVS     R2,#+0
   \   0000003C   0x....             LDR.N    R3,??DataTable6_7  ;; 0x40c00000
   \   0000003E   0x.... 0x....      BL       __aeabi_dmul
   \   00000042   0x2200             MOVS     R2,#+0
   \   00000044   0x....             LDR.N    R3,??DataTable6_8  ;; 0x40cc2000
   \   00000046   0x.... 0x....      BL       __aeabi_ddiv
   \   0000004A   0x.... 0x....      BL       __aeabi_d2iz
   \   0000004E   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    446            STO_Gains_Update(&STO_GainsUpdateStruct);
   \   00000052   0xA800             ADD      R0,SP,#+0
   \   00000054   0x.... 0x....      BL       STO_Gains_Update
    447          }      
   \   00000058   0xB003             ADD      SP,SP,#+12
   \   0000005A   0xBD00             POP      {PC}             ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x2E48E8A7         DC32     0x2e48e8a7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x400921FF         DC32     0x400921ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x3EF00000         DC32     0x3ef00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0xFFFFA856         DC32     0xffffa856

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x........         DC32     hPLL_P_Gain

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x40223333         DC32     0x40223333

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x40320000         DC32     0x40320000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x40C00000         DC32     0x40c00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x40CC2000         DC32     0x40cc2000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \   00000000   0x........         DC32     ??bCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \   00000000   0x........         DC32     Start_Up_State

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_11:
   \   00000000   0x00023280         DC32     0x23280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_12:
   \   00000000   0x........         DC32     hSpeed_Reference

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_13:
   \   00000000   0x0021C400         DC32     0x21c400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_14:
   \   00000000   0xFFDE3C00         DC32     0xffde3c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_15:
   \   00000000   0x0001DE21         DC32     0x1de21

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_16:
   \   00000000   0x........         DC32     Stat_Curr_a_b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_17:
   \   00000000   0x........         DC32     Stat_Curr_alfa_beta

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_18:
   \   00000000   0x........         DC32     Stat_Curr_q_d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_19:
   \   00000000   0x........         DC32     hTorque_Reference

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_20:
   \   00000000   0x........         DC32     hFlux_Reference

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_21:
   \   00000000   0x........         DC32     Stat_Volt_q_d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_22:
   \   00000000   0x........         DC32     PID_Torque_InitStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_23:
   \   00000000   0x........         DC32     PID_Flux_InitStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_24:
   \   00000000   0x........         DC32     Stat_Volt_alfa_beta

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_25:
   \   00000000   0x........         DC32     PID_Speed_InitStructure

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_26:
   \   00000000   0x........         DC32     State

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_27:
   \   00000000   0x........         DC32     wGlobal_Flags
    448          #endif      
    449          /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       24  IsObserverConverged
             24 -> STO_Get_Speed_Hz
             24 -> STO_IsSpeed_Reliable
        8  STO_Check_Speed_Reliability
              8 -> STO_IsSpeed_Reliable
        8  STO_Get_Mechanical_Angle
              8 -> STO_Get_Electrical_Angle
        8  STO_Get_Speed_Hz
              8 -> STO_Get_Speed
       16  STO_Obs_Gains_Update
             16 -> STO_Gains_Update
             16 -> __aeabi_d2iz
             16 -> __aeabi_ddiv
             16 -> __aeabi_dmul
             16 -> __aeabi_i2d
        0  STO_StartUp_Init
       32  STO_Start_Up
             32 -> Clarke
             32 -> IsObserverConverged
             32 -> MCL_Get_BusVolt
             32 -> MCL_SetFault
             32 -> PID_Regulator
             32 -> Park
             32 -> RevPark_Circle_Limitation
             32 -> Rev_Park
             32 -> STO_Calc_Rotor_Angle
             32 -> STO_StartUp_Init
             32 -> SVPWM_3ShuntCalcDutyCycles
             32 -> SVPWM_3ShuntGetPhaseCurrentValues
       40  STO_StateObserverInterface_Init
             40 -> STO_Gains_Init
             40 -> __aeabi_d2iz
             40 -> __aeabi_ddiv
             40 -> __aeabi_dmul
             40 -> __aeabi_i2d


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_12
       4  ??DataTable6_13
       4  ??DataTable6_14
       4  ??DataTable6_15
       4  ??DataTable6_16
       4  ??DataTable6_17
       4  ??DataTable6_18
       4  ??DataTable6_19
       4  ??DataTable6_2
       4  ??DataTable6_20
       4  ??DataTable6_21
       4  ??DataTable6_22
       4  ??DataTable6_23
       4  ??DataTable6_24
       4  ??DataTable6_25
       4  ??DataTable6_26
       4  ??DataTable6_27
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
     110  IsObserverConverged
      34  STO_Check_Speed_Reliability
      16  STO_Get_Mechanical_Angle
      20  STO_Get_Speed_Hz
      92  STO_Obs_Gains_Update
      16  STO_StartUp_Init
     346  STO_Start_Up
     216  STO_StateObserverInterface_Init
      24  Start_Up_State
          bConvCounter
          hAngle
          hFreq_Inc
          wTime
          wStart_Up_Freq
          wStart_Up_I
          hI_Inc
       1  bCounter
      12  hPLL_P_Gain
          hPLL_I_Gain
          wK1_LO
          wK2_LO

 
  25 bytes in section .bss
  12 bytes in section .data
 962 bytes in section .text
 
 962 bytes of CODE memory
  37 bytes of DATA memory

Errors: none
Warnings: 3
